<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Almango</title>
  <subtitle>天真永不消逝，浪漫至死不渝。</subtitle>
  <link href="https://mizuki.mysqil.com/" rel="alternate" type="text/html"/>
  <link href="https://mizuki.mysqil.com/atom.xml" rel="self" type="application/atom+xml"/>
  <id>https://mizuki.mysqil.com/</id>
  <updated>2025-11-15T05:45:09.978Z</updated>
  <language>zh_CN</language>
  <entry>
    <title>运营了半年的MC服务器的结档感言</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%8D%8A%E5%B9%B4%E7%9A%84mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%90%A5%E5%AE%8C%E7%BB%93%E6%84%9F%E6%83%B3/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%8D%8A%E5%B9%B4%E7%9A%84mc%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%90%A5%E5%AE%8C%E7%BB%93%E6%84%9F%E6%83%B3/</id>
    <published>2025-11-12T17:12:21.000Z</published>
    <updated>2025-11-12T17:12:21.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<p>2025年10月7日</p>
<p>我运营了半年的 Minecraft 服务器，终于画上了句点。这段旅程，历时6个月29天，吸引了超过40名玩家参与，共同创造了无数难忘的回忆。</p>
<p>一切的起点，要追溯到2025年4月9日。我为童年补了一票，并在单人游戏开了一个新档。但谁也没想到，这原本普通的个人存档，日后竟会变成十几个玩家共同的家园。</p>
<h2>从一个服务器说起</h2>
<p>故事的灵感来源于我体验过的另一个 MC 服务器。那个服务器拥有丰富的插件，一次偶然的 <code>/tpa</code> 传送，我来到了玩家 <code>bim543</code> 身边，眼前呈现出一个令我心驰神往的世外桃源：一个祥和的小镇，风格融合了中世纪与东方元素。作为一名 MC 养老玩家，我渴望也能建造一个属于自己的小镇。于是，我萌生了一个大胆的想法：何不开一个服务器，招募志同道合的养老玩家，共同打造理想中的家园？</p>
<h2>服务器的诞生</h2>
<p>在经过一番调研后，我选择了雨云租赁了一个配置普通的 Minecraft 服务器（MCS）面板服。我不喜欢整合包，所以选择了原汁原味的插件服，体验最纯粹的生存乐趣。我将单人存档导入服务器，添加了一些必要的插件，服务器就这样开始了运营。</p>
<p>到了中后期，为了解决内存问题，我经同学推荐，更换了星叶云联的 MC 面板服。配置与之前相差不大，但价格更实惠，还提供了 100GB 硬盘和额外的 4GB 运行内存。</p>
<p>由于身边玩 MC 的朋友不多，我邀请了他们一起参与服务器的开荒。同时，我也在 MCLISTS 网站上发布了服务器信息，希望能够吸引更多志同道合的玩家。（事实证明，这个方法确实奏效，我成功招募到了几位重要的玩家！）</p>
<h2>服务器信息</h2>
<ul>
<li><strong>游戏版本：</strong> Java 1.21.4 (考虑到插件的兼容性，选择了当时说新又不是很新的版本)</li>
<li><strong>服务器名称：</strong> 佳莉敦の世界 (一个听起来顺眼，又贴合养老主题的名字)</li>
<li><strong>服务器核心：</strong> Paper (主流核心，兼容性好)</li>
<li><strong>正版验证：</strong> 关闭 (为了方便更多玩家加入，避免 Mojang 验证服务器抽风)</li>
</ul>
<h2>开服的日子</h2>
<p>初期，我将大部分时间都投入到了建筑上，迫切地想搭建一个属于自己的世外桃源。那时服务器的日活只有3-4人，主要是我的室友和高中同学。我几乎所有空闲时间都用来建造房子和搭建自动化设备。
<img src="https://gitee.com/almango/image-bed/raw/master/album/game/game_mcserver_2.webp" alt="" /></p>
<p>中期是最热闹的阶段。通过网络招募，服务器涌入了几位新玩家，日活达到了 5-7 人。我逐渐放慢了建筑的脚步，开始更新插件，以提升玩家的游戏体验，例如权限组、生存飞行、连锁砍树、领地圈地等必备插件。同时，我也制定了一些规则，例如“禁止在房区垂直下挖”、“禁止跑到距离主城 2000 米范围外”、“禁止建造不可控的生电”等，目的是为了维护服务器环境，降低服务器压力（现在回想起来，我当时管得确实有点宽）。值得一提的是，我邀请了我的 MC 乌托邦启蒙者 <code>bim543</code> 来服务器参观，并得到了他的认可，这让我感到无比的荣幸。如果没有他，我可能根本不会有开服的想法。
<img src="https://gitee.com/almango/image-bed/raw/master/album/game/gameserver_mc_1.webp" alt="" /></p>
<p>到了后期，服务器人数又回落到 2-4 人，只有一些元老玩家和新玩家偶尔上线。这时，存档基本定型，资源也变得取之不尽。我更新了自定义村民商店，上架了一些必要物品，玩家可以用绿宝石进行交易，因此我们根本不缺资源。我和室友 <code>Nan</code> 还共同修建了一个天空主城，因为原本的主城已经不堪重负。站在地面上仰望，天空主城十分壮观。但总的来说，后期服务器比较冷清，我也很少上线。MC 就是这样，想玩的时候会沉迷其中，不想玩的时候则会放置很久。
<img src="https://gitee.com/almango/image-bed/raw/master/album/game/game_mcserver_3.webp" alt="" />
<img src="https://gitee.com/almango/image-bed/raw/master/album/game/game_mcserver_4.webp" alt="" /></p>
<h2>那些令人印象深刻的玩家</h2>
<ul>
<li>
<p><strong>GBZTX：</strong> 我的高中同学，一个狂热的社会主义拥护者。他在服务器内疯狂宣传红色文化，建造了“无产阶级站起来”雕像、马克思、斯大林、列宁纪念碑，甚至在自己的中世纪城堡上挂满了苏维埃旗帜。这些地标建筑在主城外格外显眼。虽然他不太懂指令，但我还是和他一起维护服务器。</p>
</li>
<li>
<p><strong>Scorching15：</strong> 我的室友，从开服一直活跃到停服，是一个建筑大佬。他在服务器中贡献了许多大型建筑，前期是他贡献了大部分生电设备：单核刷铁机（我依旧记得他从远处的村庄拉了很多村民过来繁殖，还徒手将村民运到了十多米高的生电塔内），全自动猪人塔。解决了前期资源不足的困境，同时他也拥有服务器的大部分资源...后期还建造了一个樱花别墅，还有一个大型樱花树，遗憾的是樱花树到停服也没完工。</p>
</li>
<li>
<p><strong>LAI：</strong> 我们都叫他山顶洞人（当然是私底下这么称呼的🤫）。他是最早一批加入的玩家之一，在开荒时期非常活跃，以至于到了末期还偶尔会上线。他是一个最纯粹的生存玩家。之所以叫他山顶洞人，是因为他在主城附近的小山堆里建了一个屋子，名为“山顶洞人快乐屋”。他还为服务器贡献了一些生电机器：史莱姆农场，掠夺者农场...</p>
</li>
<li>
<p><strong>sEvEyy：</strong> 和 <code>LAI</code> 一样，也是元老玩家。他是服务器里的肝帝。服务器中的大部分生电都是他建造的，包括多核猪人塔、多核刷铁机、黑曜石塔，以及和 <code>LAI</code> 共同建造的掠夺者农场。他用最短的时间通关游戏，拥有全服最强的装备和最多的资源，堪称服务器里的地主。更令人惊叹的是，他用几十帧的电脑，也能玩到这种程度。在中后期，他还顺手通关了其他服务器...
<img src="https://gitee.com/almango/image-bed/raw/master/album/game/game_mcserver_5.webp" alt="" /></p>
</li>
</ul>
<h2>那些不得不提的插曲</h2>
<p>服务器运营了这么久，自然少不了外挂玩家和搞破坏的玩家。我认为这是不可避免的，所有服务器都会遇到。</p>
<ul>
<li>
<p><strong>插件后门：</strong> 在中前期，由于插件不够完善，特别是权限组，有外挂玩家利用普通玩家的权限，获取了修改游戏模式的权限。他利用这个漏洞囤积了大量高附魔装备和半箱子的鞘翅，还顺手速通了末地。直到他再也没有上线后，我才在后台发现了这个漏洞。</p>
</li>
<li>
<p><strong>明目张胆的外挂：</strong> 还有一位加速+飞天的挂哥。他告诉我说是三叉戟的游戏 Bug，所以我容忍了一段时间。但随着他越来越猖狂，直接在我脸上开挂，我便更新了反外挂插件，当场将其 ID 和 IP 永久封禁。当时服务器甚至没有飞行插件，他开挂简直就是神仙。</p>
</li>
<li>
<p><strong>登录机制漏洞：</strong> Authme 插件有一个功能是当天登录过的玩家可以跳过登录。有人利用这个机制，使用我的 ID 登录我的账号，直接把我的家给抄了。虽然不知道是谁，不过我还是把登录 IP 给封禁了，后续也禁用了这个机制（这个机制只适用于正版验证服务器）。</p>
</li>
<li>
<p><strong>破坏行为：</strong> 破坏行为主要包括偷窃其他玩家的物品，以及破坏建筑。在没有加入领地插件之前，就有人跑到我室友家拆信标下的铁块，还有跑到我家偷东西的，甚至把我角色头颅挖走的...所以我只能大力推广领地插件了。</p>
</li>
</ul>
<h2>生日派对</h2>
<p>服务器还举办过一场生日派对，那是 <code>GBZTX</code> 的 21 岁生日。我们邀请了许多玩家一起庆祝。在一个纪念碑旁，我们临时改装成了一个主题公园，还搭建了一个生日蛋糕，并建造了一个 MC 标志性建筑。那天是那么的兴奋和难忘。（我也好想在游戏内举行生日派对呀，可是我还是太社恐了）
<img src="https://gitee.com/almango/image-bed/raw/master/album/game/game_mcserver_6.webp" alt="" />
<img src="https://gitee.com/almango/image-bed/raw/master/album/game/2025-07-29_20.10.33.webp" alt="" /></p>
<h2>终结</h2>
<p>经历了 6 个月 29 天的运营，服务器终于走到了末期。日活不超过 3 人，平均日活 0.5 人。资源爆满，末地频繁通过重置，有部分玩家甚至已经完成了游戏内的所有成就...已经没有什么东西能再吸引玩家继续游戏了，包括我也一样。以至于到这个时候，我的世外桃源也没能建成。不过，大家共同打造的世界显然已经成为了我们的“世外桃源”。这 6 个月 29 天虽然不长，但有 40 多个玩家注册了账号，并在游戏中经历了无数个日日夜夜：挖矿、打怪、建房子、聊天、探索世界，这些点滴足以构成一段宝贵的回忆。</p>
<p>感谢所有玩家的参与与付出。再见，佳莉敦の世界！</p>
<p><img src="https://gitee.com/almango/image-bed/raw/master/album/game/game_mcserver_1.webp" alt="" /></p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="推荐分享"></category>
  </entry>
  <entry>
    <title>Hexo Out，Astro In！！！</title>
    <link href="https://mizuki.mysqil.com/posts/hexo-outastro-in/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/hexo-outastro-in/</id>
    <published>2025-08-22T00:00:00.000Z</published>
    <updated>2025-08-22T00:00:00.000Z</updated>
    <summary>关于我退出了Hexo，转而加入了Astro这个更有权威的圈子。</summary>
    <content type="html"><![CDATA[<h3>框架使用</h3>
<ol>
<li>最初还是使用Wordpress作为博客框架的，但随着对样式要求的提高和更加经济，我换成了Hexo。</li>
<li>在此期间朋友推荐过我用Astro，但第一次尝的得Hexo的甜我也就懒得去换其他框架了，Hexo也就一直被我用到现在。</li>
<li>但随着对其他框架的不断了解，我才发现Hexo这个框架居然有一段历史了，网上那些主流的主题的也就那几个，对比了Astro一些主题和性能后，最终还是打算把这个老舅的Hexo换掉，另外，可能会有人觉得，写个文章而已，何必在意那么多。但我不一样，我比较注重样式和功能...</li>
</ol>
<blockquote>
<p><strong>Hexo</strong>：诞生于 2013 年，是一款专注于博客场景的轻量 SSG，核心目标是让用户快速搭建个人博客。它以 “简单、高效” 为设计原则，默认提供博客所需的基础功能（如文章管理、标签 / 分类、主题系统等），对非博客场景的支持较弱。</p>
</blockquote>
<blockquote>
<p><strong>Astro</strong>：2021 年推出的 “新兴全能型 SSG”，定位是 <code>“构建任何类型的静态网站”</code>，不仅支持博客，还能胜任企业官网、电商站点、文档站等复杂场景。它的设计理念是 “内容优先”，同时融合了现代前端框架的灵活性，更强调 “性能与开发体验的平衡”。</p>
</blockquote>
<h2>主题选择</h2>
<ol>
<li>
<p>其实Astro重新出现在我的视野是因为在网上看到了Muzuki主题，这个主题样式真的太棒了，给我的感觉就是有种柔和美，现代美...</p>
</li>
<li>
<p>我是因为Muzuki才后认识Fuwari的，也试着用了一下Fuwari，只能说太原生了，对于刚入门Astro的我来说确实需要下很多学习成本，Muzuki的功能相对就比较多，还有较全的文档，尽管目前还处于开发当中，我还是选择了Mizuki作为现在的博客主题。</p>
</li>
<li>
<p>另外由于新项目的原因，项目作者的更新频率挺高的，这就让我不得不长期使用一个版本，目前也不知道有什么方法可以在不重构的情况下更新主题（其实我是真希望能体验到更多新功能）</p>
</li>
<li>
<p>现在该做的就是对当前的主题版本进行一些小小的修改，让自己用着更舒服就行。</p>
</li>
<li>
<p>对了，我已经好久没更新过文章了，说不定这次换了框架和主题后，我的文章更新频率会高很多...</p>
</li>
<li>
<p>最后呢，我也把自己微改的Butterfly主题存到了Github中，毕竟魔改也花了很多精力的。</p>
</li>
</ol>
<p>::github{repo="Almango/Butterfly-mango_Modify"}</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="Astro"></category>
  </entry>
  <entry>
    <title>Minecraft插件配置【开服日志】</title>
    <link href="https://mizuki.mysqil.com/posts/minecraft%E6%8F%92%E4%BB%B6%E6%9C%8D%E5%BC%80%E6%9C%8D%E6%97%A5%E5%BF%97/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/minecraft%E6%8F%92%E4%BB%B6%E6%9C%8D%E5%BC%80%E6%9C%8D%E6%97%A5%E5%BF%97/</id>
    <published>2025-05-09T21:27:58.000Z</published>
    <updated>2025-05-09T21:27:58.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p><strong>文章内容</strong></p>
<ol>
<li>涉及到了新手开服的插件推荐与相关配置教程。</li>
<li>玩转各大好用的插件，用最简便的方法，展示出最佳的效果。</li>
</ol>
</blockquote>
<h1>前言</h1>
<ol>
<li>上个月又染上了MC，并在别人的服务器找到了灵感，于是我和朋友合资搞了一个3个月的服务器开一个插件服，我们是这样打算的，开一个永久不关的存档。</li>
<li>我去过很多他人的服务器，看着他们各种各样的插件，我也就有了美化服务器的打算，毕竟是插件服...</li>
</ol>
<h1>插件推荐</h1>
<blockquote>
<p>废话就不多说，来讲一下我都用过哪些好用的插件吧！</p>
</blockquote>
<h2>TAB (TAB面板美化插件)</h2>
<ul>
<li>兼容版本：<code>1.21.5</code> ~ <code>1.5.1</code></li>
<li>兼容核心：<code>paper</code>,<code>Waterfall</code>，<code>Velocity</code>，<code>Sponge</code>，<code>Spigot</code>，<code>Quilt</code>，<code>Purpur</code>....</li>
<li>使用文档：<a href="https://docs.superiormc.cn/tab-wiki">TAB-wiki</a></li>
<li>下载地址1：<a href="https://modrinth.com/plugin/tab-was-taken">TAB（Modrinth）</a></li>
<li>下载地址2：<a href="https://www.spigotmc.org/resources/tab-1-5-1-21-5.57806/">TAB（Spigot）</a></li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_plugins_1.png" alt="sss" /></p>
<ol>
<li>
<p>首先是TAB美化插件：<a href="https://modrinth.com/plugin/tab-was-taken">TAB (一个有效的一体化解决方案)</a></p>
</li>
<li>
<p>TAB是一个用于在不同位置显示信息的多功能插件，旨在在功能、兼容性和性能方面超越所有类似的插件。按照我的理解，它具备了美化TAB面板，记分板，和展示玩家名称前后缀，玩家ping值和头顶数值等功能。</p>
</li>
<li>
<p>关于它的配置项也十分的简单，这里只展示部分实用的功能:</p>
</li>
</ol>
<blockquote>
<p><code>/tab debug</code>：输出玩家的信息</p>
</blockquote>
<h3>TAB面板美化</h3>
<ol>
<li>我们可以在服务器核心的<code>plugins/TAB/config.yml</code>文件中对<code>header-footer</code>进行修改，改配置项对应的是TAB面板，你可以根据信息内容按照自己的想法进行修改：</li>
<li>其中里面用到了许多变量：<code>%staffonline%</code>（在线管理员人数），<code>%online%</code>（在线玩家人数），<code>%player%</code>（我的名称），<code>%memory-used%``（占用内存），</code>%memory-max%<code>（最大内存），</code>%world%`（所在世界）等，</li>
</ol>
<pre><code># https://github.com/NEZNAMY/TAB/wiki/Feature-guide:-Header-&amp;-Footer
header-footer:
  enabled: true
  header:
    - "&amp;d&amp;l《佳莉敦の世界》"
    - "&lt;#FFFFFF&gt;&amp;m                                        &lt;/#FFFF00&gt;"
    #- "&amp;f-------------------------"
    # - "&amp;r&amp;7&amp;l&gt;&gt; %animation:Welcome%&amp;3 &amp;l%player%&amp;7&amp;l! &amp;7&amp;l&lt;&lt;"
    # - "&amp;6在线管理员: &amp;e%staffonline%"
    - "&amp;r&amp;b在线人数: &amp;f%online%"
    - ""
  footer:
    # - "%animation:time%"
    # - "&amp;2Ping: %ping%"
    # - "&amp;7&amp;l 内存监控: %memory-used% MB / %memory-max% MB"
    #- "&amp;f-------------------------"
    - ""
    - "&amp;b玩家QQ群：&amp;a1153119841"
    - "&lt;#FFFFFF&gt;&amp;m                                        &lt;/#FFFF00&gt;"
  disable-condition: '%world%=disabledworld'
  per-world:
    world1:
      header:
        - "an example of world with custom"
      footer:
        - "header/footer and prefix/suffix"
    world2;world3:
      header:
        - "This is a shared header for"
        - "world2 and world3"
  per-server:
    server1:
      header:
        - "an example of server with custom header"
</code></pre>
<ol>
<li>通过启用<code>playerlist-objective</code>，我们可以在TAB中显示其他玩家和自己的延迟。</li>
</ol>
<pre><code>playerlist-objective:
  enabled: true
  value: "%ping%"
  fancy-value: "&amp;7Ping: %ping%"
  title: "Java Edition is better" # Only visible on Bedrock Edition
  render-type: INTEGER
  disable-condition: '%world%=disabledworld'
</code></pre>
<h3>玩家名称样式</h3>
<ol>
<li>我们可以对TAB上的名称样式进行修改。例如在游戏中输入以下指令：</li>
<li><code>/tab playeruuid &lt;玩家名称&gt; tabprefix &lt;前缀&gt;</code>：给玩家设置一个<code>前缀</code>。</li>
<li><code>/tab playeruuid &lt;玩家名称&gt; tabsuffix &lt;后缀&gt;</code>：给玩家设置一个<code>后缀</code>。</li>
<li><code>/tab playeruuid &lt;玩家名称&gt; customtabname &lt;后缀&gt;</code>：<code>自定义玩家名称</code>。</li>
</ol>
<blockquote>
<p>playeruuid是识别玩家唯一的ID值。</p>
</blockquote>
<h3>分组</h3>
<ol>
<li>
<p>TAB默认会给定几个组: <code>default</code>，<code>Owner</code>，<code>Admin</code>，<code>Mod</code>，<code>Helper</code>...</p>
</li>
<li>
<p>当然我们也可以在<code>plugins/TAB/group.yml</code>中删除和添加组。</p>
</li>
<li>
<p>我们可以对组进行样式的编辑，例如：可以通过给组绑定前缀（称号）来让所在组的玩家显示组内分配的前缀（称号），举个栗子：“玩家A处在admin组中，而admin组内绑定了管理员称号，那么玩家A的称号就会显示在TAB面板中”。</p>
</li>
<li>
<p>打开<code>plugins/TAB/group.yml</code>文件，在<code>_DEFAULT_</code>配置项下方可以新增组或删除组，此外<code>_DEFAULT_</code>（默认组）是无法删除的。</p>
</li>
<li>
<p>没有分配组的玩家会被默认归属到<code>_DEFAULT_</code>组内。</p>
</li>
<li>
<p>被分配组的玩家，其前缀，后缀，自定义名称，和标签都会与组内的进行同步。</p>
</li>
</ol>
<pre><code> # default settings for all groups, all groups will take properties from this section unless player's primary group overrides a specific setting
_DEFAULT_:
  tabprefix: "[ &amp;7玩家 &amp;r] &amp;r"
  tagprefix: "%luckperms-prefix%"
  customtabname: "%player%"
  tabsuffix: "%luckperms-suffix%"
  tagsuffix: "%luckperms-suffix%"
  
admin:
  tabprefix: "[ &amp;e管理 &amp;r] &amp;r"
  tagprefix: "%luckperms-prefix%"
  customtabname: "%player%"
  tabsuffix: "%luckperms-suffix%"
  tagsuffix: "%luckperms-suffix%"
  ...... 
</code></pre>
<ol>
<li>当然了，组的在TAB排列方式（权重）也是有规则的。</li>
<li>我们可以在<code>plugins/TAB/config.yml</code>文件对<code>primary-group-finding-list</code>配置项进行修改。</li>
<li>其中组名越是靠前权重就越高，在TAB面板中显示的位置也就越靠前。</li>
</ol>
<pre><code>primary-group-finding-list:
  - Owner
  - Admin
  - Mod
  - Helper
  - default
</code></pre>
<h3>记分板</h3>
<ol>
<li>TAB有一个特别的功能，就是新增了右侧记分板。不过，这个功能我用的不多，通常来讲它需要搭配<code>PlaceholderAPI</code>插件来使用才能够显得更强大。这里就不过多叙述。</li>
<li>打开文件<code>plugins/TAB/config.yml</code>，根据注释进行修改......</li>
</ol>
<pre><code># https://github.com/NEZNAMY/TAB/wiki/Feature-guide:-Scoreboard
scoreboard:
  enabled: false
  toggle-command: /sb
  remember-toggle-choice: false
  hidden-by-default: false
  use-numbers: true
  static-number: 0
  delay-on-join-milliseconds: 0
  scoreboards:
    scoreboard-1.20.3+:
      title: "&lt;#E0B11E&gt;MyServer&lt;/#FF0000&gt;"
      display-condition: "%player-version-id%&gt;=765;%bedrock%=false" # Only display it to players using 1.20.3+ AND NOT bedrock edition
      lines:
        - "&amp;7%date%"
        - "%animation:MyAnimation1%"
        - "&amp;6Online:"
        - "* &amp;eOnline&amp;7:||%online%"
        - "* &amp;eCurrent World&amp;7:||%worldonline%"
        - "* &amp;eStaff&amp;7:||%staffonline%"
        - ""
        - "&amp;6Personal Info:"
        - "* &amp;bRank&amp;7:||%group%"
        - "* &amp;bPing&amp;7:||%ping%&amp;8ms"
        - "* &amp;bWorld&amp;7:||%world%"
        - "%animation:MyAnimation1%"
    scoreboard:
      title: "&lt;#E0B11E&gt;MyServer&lt;/#FF0000&gt;"
      lines:
        - "&amp;7%date%"
        - "%animation:MyAnimation1%"
        - "&amp;6Online:"
        - "* &amp;eOnline&amp;7: &amp;f%online%"
        - "* &amp;eCurrent World&amp;7: &amp;f%worldonline%"
        - "* &amp;eStaff&amp;7: &amp;f%staffonline%"
        - ""
        - "&amp;6Personal Info:"
        - "* &amp;bRank&amp;7: &amp;f%group%"
        - "* &amp;bPing&amp;7: &amp;f%ping%&amp;8ms"
        - "* &amp;bWorld&amp;7: &amp;f%world%"
        - "%animation:MyAnimation1%"


</code></pre>
<blockquote>
<p>最后，如果是想对玩家个人进行信息修改可以直接在<code>plugins/TAB/user.yml</code>文件中进行具体的修改</p>
</blockquote>
<h2>TPA (简易传送插件)</h2>
<ul>
<li>兼容版本：<code>1.21.4</code> ~ <code>1.7.10</code></li>
<li>兼容核心：<code>Spigot</code>，<code>Purpur</code>，<code>Paper</code>，<code>Folia</code>，<code>Bukkit</code></li>
<li>下载地址：<a href="https://modrinth.com/plugin/tpa.66666">TPA（Modrinth）</a></li>
<li>使用文档：<a href="https://modrinth.com/plugin/tpa.66666">TPA（Modrinth教程）</a></li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_plugins_2.png" alt="" /></p>
<ol>
<li>TPA是一个支持 Folia 的简易传送插件，支持 Bukkit/Spigot/Paper/Folia。</li>
<li>该插件使用起来十分简单，你甚至都不需要打开它的配置文件。</li>
<li>由于十分简单，我甚至可以直接搬运官方教程了...</li>
</ol>
<h3>玩家间传送</h3>
<ol>
<li>
<p><code>/tpa &lt;玩家名称&gt;</code>：向玩家发送传送请求。</p>
</li>
<li>
<p><code>/tphere &lt;玩家名称&gt;</code>：请求玩家传送到你身边。</p>
</li>
<li>
<p><code>/tpall [player/warp/spawn]</code>：强制将所有在线玩家传送到目标位置（如果不加参数，默认传送到使用者身边）。</p>
</li>
<li>
<p><code>/tplogout</code> &lt;玩家名称&gt;：传送到该玩家最后一次下线的位置。</p>
</li>
<li>
<p><code>/tpaccept</code>：接受传送请求（你可以点击聊天框里的 [接受] 来直接接受）。</p>
</li>
<li>
<p><code>/tpdeny</code>：拒绝传送请求（你可以点击聊天框里的 [拒绝] 来直接拒绝，点击聊天框中的 [拒绝并拉黑] 将拒绝请求并且拉黑该玩家）。</p>
</li>
<li>
<p><code>/denys [add/remove] [玩家名称]</code>：列出玩家的黑名单列表。</p>
</li>
</ol>
<h3>传送点</h3>
<ol>
<li><code>/warp &lt;坐标&gt;</code>：传送到传送点。</li>
<li><code>/setwarp &lt;坐标&gt;</code>：设置传送点。</li>
<li><code>/delwarp &lt;坐标&gt;</code>：删除传送点。</li>
</ol>
<h3>家（公开权限）</h3>
<ol>
<li><code>/home &lt;家名称&gt;</code>：传送到家。</li>
<li><code>/homes</code>：列出你设置的家。</li>
<li><code>/sethome &lt;家名称&gt;</code>：设置家。</li>
<li><code>/setdefaulthome &lt;家名称&gt;</code>：设置默认的家。</li>
<li><code>/delhome &lt;家名称&gt;</code>：删除家。</li>
</ol>
<h3>主城</h3>
<ol>
<li><code>/spawn</code>：传送到主城。</li>
<li><code>/setspawn</code>：设置主城。</li>
<li><code>/delspawn</code>：删除主城。</li>
</ol>
<h3>其他</h3>
<ol>
<li><code>/back</code>：传送到上一次死亡的位置。</li>
<li><code>/rtp</code>：随机传送。</li>
<li><code>/tpa version</code>：检查插件更新。</li>
<li><code>/tpa setlang &lt;clear/语言&gt;</code>：设置客户端显示语言。</li>
<li><code>/tpa reload</code>：重新加载配置文件。</li>
</ol>
<h3>关闭自动更新与检查</h3>
<ol>
<li>打开配置文件：<code>plugins/TPA/config.yml</code>，将<code>update_check</code>的值修改为false.</li>
</ol>
<pre><code>update_check: false
</code></pre>
<h2>LuckPerms（权限组插件）</h2>
<ul>
<li>兼容版本：<code>1.21.4</code> ~ <code>1.8.9</code></li>
<li>兼容核心：<code>Waterfall</code>，<code>Velocity</code>，<code>Spigot</code>，<code>Paper</code>，<code>NeoForge</code>，<code>Forge</code>，<code>Fabric</code>，<code>BungeeCord</code>，<code>Bukkit</code></li>
<li>使用文档：<a href="https://izzelaliz.gitbooks.io/luckperms-wiki/content/">LuckPerms Wiki</a></li>
<li>下载地址1：<a href="https://luckperms.net/">LuckPerms（官方）</a></li>
<li>下载地址2：<a href="https://modrinth.com/plugin/luckperms">LuckPerms（Modrinth）</a></li>
</ul>
<ol>
<li>LuckPerms是一个用于 Minecraft 服务器的<code>权限插件/模组</code>。</li>
<li>它的好用之处在于它可以搭配其他插件，例如：EssentialsX，TAB使得不同组内的权限分配与应用变的更加强大。</li>
</ol>
<h3>组</h3>
<ol>
<li>
<p><code>/lp creategroup &lt;组名&gt;</code>使用该指令来创建一个新的组</p>
</li>
<li>
<p><code>/lp deletegroup &lt;组名&gt;</code>：删除一个组</p>
</li>
<li>
<p><code>/lp user &lt;玩家名&gt; parent set &lt;组名&gt;</code>：将玩家的主要组设置为某组（主要组）</p>
</li>
<li>
<p><code>/lp user &lt;玩家名&gt; parent add &lt;组名&gt;</code>：将玩家添加到组（次要组）</p>
</li>
<li>
<p><code>/lp user &lt;玩家名&gt; parent remove &lt;组名&gt;</code>：将玩家从所在的组移除</p>
</li>
<li>
<p><code>/lp user &lt;玩家名&gt; info</code>：查看玩家的组权信息
<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_plugins_3.jpg" alt="" /></p>
</li>
<li>
<p>此外你也可以对组进行编辑，例如我可以给组设置一个前缀，这样组内的玩家就会显示一个固定的前缀。</p>
</li>
<li>
<p><code>/lp group admin meta setweight &lt;权重值&gt;</code>：设置组的权重（数字越大权重越高）</p>
</li>
<li>
<p><code>/lp group admin meta addprefix &lt;前缀名&gt;</code>：给组设置前缀。</p>
</li>
<li>
<p><code>/lp group admin meta removeprefix</code>：移除组的前缀</p>
</li>
</ol>
<blockquote>
<p>关于LuckPerms插件的部分内容就介绍到这里，后续可能会更新...</p>
</blockquote>
<h2>LPC（LuckPerms Chat聊天系统）</h2>
<ul>
<li>兼容版本：<code>1.21.4</code> ~ <code>1.7.10</code></li>
<li>兼容核心：<code>Paper</code>，<code>Spigot</code>，<code>Sponge</code>...</li>
<li>使用文档：null</li>
<li>下载地址：<a href="https://www.spigotmc.org/resources/lpc-chat-formatter-1-7-10-1-21-4.68965/update?update=336651">LPC （Spigot）</a></li>
</ul>
<ol>
<li>LuckPerms Chat一个用于 <code>LuckPerms</code> 的聊天格式插件。</li>
<li>这是一个与<code>LuckPerms</code>完全兼容和配套的插件。</li>
<li>LPC十分的轻便，你只需要对<code>plugins/LPC/config.yml</code>进行一个简单的配置就可以使用了，甚至不需要用到任何游戏指令。</li>
</ol>
<h3>简单配置</h3>
<ol>
<li>
<p>config文件中只有两个配置项，分别是<code>chat-format</code>和<code>group-formats</code></p>
</li>
<li>
<p><code>chat-format</code>表示的是<code>普通聊天格式</code>，当玩家发送消息时，它只会显示一个前缀，名称和聊天信息，偏向简约，我这里是不推荐的开启的。</p>
</li>
<li>
<p><code>group-formats</code>表示的是<code>组聊天格式</code>，它会根据不同的组显示不同的聊天格式，例如普通玩家显示默认组内的前缀，管理员则显示Admin组内的前缀。</p>
</li>
<li>
<p><code>group-formats</code>你还可以针对不同的组的信息格式进行自定义修改，比如，给不同组的玩家的聊天信息前缀赋予不一样的颜色。</p>
</li>
<li>
<p>这里说一下变量，里面的变量都是和<code>LuckPerms</code>的数据挂钩的，例如：前缀<code>prefix</code>，后缀<code>suffix</code>，此外还有默认变量：所处世界<code>world</code>，玩家名称<code>name</code>，聊天消息<code>message</code>等。</p>
</li>
<li>
<p>最后，如果你不想使用<code>普通聊天格式</code>，只需将<code>配置项注释掉</code>即可。</p>
</li>
</ol>
<pre><code># To reload the configuration, run '/lpc reload' command. Make sure you have the 'lpc.reload' permission assigned.
# More information can be found at https://www.spigotmc.org/resources/68965.
chat-format: "{prefix}{name}&amp;r: {message}"

# Set the format per group.
# Note: Option for more advanced users. Remove comments to run.
group-formats:
  default: "[ &amp;7玩家 &amp;r] [ &amp;2{world} &amp;r] &lt;&amp;b{name}&gt;&amp;r: {message}"
  special: "[ &amp;3{prefix} &amp;r] [ &amp;2{world} &amp;r] &lt;&amp;b{name}&gt;&amp;r: {message}"
  admin: "[ &amp;e{prefix} &amp;r] [ &amp;2{world} &amp;r] &lt; &amp;b{name}&gt;&amp;r: {message}"
</code></pre>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_plugins_4.png" alt="" /></p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="Minecraft"></category>
  </entry>
  <entry>
    <title>Node.JS Express</title>
    <link href="https://mizuki.mysqil.com/posts/nodejs%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/nodejs%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</id>
    <published>2025-03-08T22:35:50.000Z</published>
    <updated>2025-03-08T22:35:50.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h1>创建HTTP服务器</h1>
<ol>
<li>
<p>引入'http'插件，</p>
</li>
<li>
<p>创建一个HTTP服务器实例，并使用一个常量server来接收</p>
</li>
<li>
<p>设置端口。</p>
</li>
<li>
<p>随后设置'request' 监听，每当收到http请求时触发。server.on提供了两个参数event（要监听的事件名称），listener（事件触发时要执行的回调函数。）</p>
</li>
<li>
<p>最后启动服务，输出语句</p>
</li>
</ol>
<pre><code>node demo.js
</code></pre>
<pre><code>const http = require('http'); // 引入 Node.js 的 http 模块

const server = http.createServer(); // 创建一个 HTTP 服务器实例

const port = 3000; // 定义服务器监听的端口号

// 监听 'request' 事件，每当有 HTTP 请求到达服务器时触发
server.on('request', function(req, res) {
    const me = req.method; // 获取请求的方法（如 GET、POST 等）
    console.log(me); // 打印请求方法
});

// 监听端口，启动服务器
server.listen(port, function() {
    console.log("Web服务器启动成功：http://127.0.0.1:3000");
});
</code></pre>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>server.on()</td>
<td>event，listener</td>
<td>用于为 http.Server 或 https.Server 对象添加事件监听器。</td>
</tr>
<tr>
<td>server.listen()</td>
<td>port， callback</td>
<td>用于启动服务器并监听指定的端口或文件描述符。</td>
</tr>
</tbody>
</table>
<h2>GET与POST</h2>
<blockquote>
<p>GET 和 POST 是 HTTP 协议中最常用的两种请求方法，它们用于客户端与服务器之间的通信。每种方法都有其特定的用途和行为。</p>
</blockquote>
<p><strong>GET</strong>：请求用于从服务器获取资源。它是 HTTP 请求中最常用的方法之一，通常用于请求网页、API 数据等。</p>
<p><strong>POST</strong>：请求用于向服务器提交数据，通常用于创建新资源或更新现有资源。例如，用户提交表单数据时通常使用 POST 请求。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody>
<tr>
<td>用途</td>
<td>获取资源</td>
<td>提交数据</td>
</tr>
<tr>
<td>参数传递</td>
<td>通过 URL 查询字符串</td>
<td>通过请求体</td>
</tr>
<tr>
<td>安全性</td>
<td>参数暴露在 URL 中，不安全</td>
<td>参数在请求体中，相对安全</td>
</tr>
<tr>
<td>缓存</td>
<td>可缓存</td>
<td>不可缓存</td>
</tr>
<tr>
<td>书签</td>
<td>可书签</td>
<td>不可书签</td>
</tr>
<tr>
<td>长度限制</td>
<td>URL 长度有限制</td>
<td>请求体长度无限制</td>
</tr>
</tbody>
</table>
<h2>Request与Response</h2>
<blockquote>
<p>在 Node.js 的 HTTP 模块中，req 和 res 是两个非常重要的对象，分别代表 HTTP 请求和 HTTP 响应。它们是处理 HTTP 通信的核心对象，提供了丰富的属性和方法来处理请求和发送响应。</p>
</blockquote>
<p><strong>req</strong>：它代表客户端的 <code>HTTP 请求</code>。它包含了请求的所有信息，例如请求方法、URL、请求头、请求体等。
<strong>res</strong>：它对象代表服务器发送给客户端的 <code>HTTP 响应</code>。它提供了方法来设置响应头、状态码和发送响应体。</p>
<ol>
<li>例如，我们可以使用<code>req</code>的各种方法<code>拿到客户端返回的请求数据</code>：</li>
</ol>
<pre><code>server.on('request', function(req,res){
    console.log(`收到请求：${req.method} ${req.url}`);
    console.log('请求头：', req.headers);
    console.log('请求方法：', req.method);
    console.log('请求 URL：', req.url);
})
</code></pre>
<ol>
<li>我们也可以使用<code>res</code>的各种方法来<code>将内容响应给客户端</code>。</li>
</ol>
<pre><code>server.on('request', function(req,res){
    res.statusCode = 200;
    // 设置响应头
    res.setHeader('Content-Type', 'text/plain');
    // 发送响应体
    res.send('Hello, World!');
})

</code></pre>
<table>
<thead>
<tr>
<th>属性/方法</th>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>req.method</td>
<td>NULL</td>
<td>用于为获取客户端返回的请求类型（GET、POST、PUT、DELETE等）</td>
</tr>
<tr>
<td>req.httpVersion</td>
<td>NULL</td>
<td>用于获取HTTP 版本</td>
</tr>
<tr>
<td>req.headers</td>
<td>NULL</td>
<td>用于获取请求头，一个对象，包含所有请求头字段。</td>
</tr>
<tr>
<td>req.url</td>
<td>NULL</td>
<td>用于获取请求的 URL</td>
</tr>
<tr>
<td>res.statusCode</td>
<td>NULL</td>
<td>用于获取响应状态码。</td>
</tr>
<tr>
<td>req.on()</td>
<td>event， listener</td>
<td>用于监听事件</td>
</tr>
<tr>
<td>res.setHeader()</td>
<td>name，value</td>
<td>用于设置响应头</td>
</tr>
</tbody>
</table>
<h1>Express.js</h1>
<h2>创建服务器</h2>
<ol>
<li>
<p>只需要导入express模块，再创建express实例，最后启动服务器即可。</p>
</li>
<li>
<p>可以发现，服务器创建方式与http不同的是，express不用直接创建服务器实例，只需要创建一个express实例即可，这事因为express内部<code>对http进行了封装</code>。</p>
</li>
<li>
<p>在监听方面，需要单独对某一个页面的请求方法进行监听，例如下列代码中对<code>'/'</code>页面进行的GET请求的监听</p>
</li>
</ol>
<pre><code>const express = require('express')   // 导入express模块

const app = express()   // 创建express实例

app.get('/', function(req, res){   // 监听GET请求
    res.send("Index")
})

app.listen(3000, function(req, res){    // 启动服务器
    console.log("服务器启动成功：http://127.0.0.1:80")
})
</code></pre>
<h2>静态资源绑定</h2>
<blockquote>
<p>静态资源（如 HTML 文件、CSS 文件、JavaScript 文件、图片等）可以通过 express.static 中间件来提供服务。</p>
</blockquote>
<p><code>express.static</code> 是一个内置的中间件，用于提供静态文件服务。它允许你指定一个目录路径，该目录中的文件将被公开访问。你可以通过 express.static 提供一个 URL 参数，将该参数映射为服务器的 URL 前缀。这样，客户端可以通过指定的 URL 前缀访问静态文件。例如，如果你将 public 目录映射到 /static，那么客户端可以通过 /static 前缀访问 public 目录中的文件。</p>
<ol>
<li>假设我们现有的静态资源目录为：</li>
</ol>
<pre><code>project/
└─── public/
    ├── login.html
    └── app.js

</code></pre>
<ol>
<li>例如通过以下代码，我们可以访问到html资源：http://localhost/login.html</li>
</ol>
<pre><code>const express = require('express')

const app = express()

app.use(express.static('../public'))

app.listen(3000, function(req, res){
    console.log("服务器启动成功：http://127.0.0.1:3000")
})
</code></pre>
<h2>路由模块</h2>
<blockquote>
<p><code>路由（Router）</code> 是一个非常重要的概念，它定义了应用程序如何响应客户端的请求。具体来说，路由决定了当用户访问某个 URL 或提交某个请求时，应用程序应该执行哪些操作。</p>
</blockquote>
<ol>
<li>
<p>在 Express 中，路由是通过 app 对象的 get、post、put、delete 等方法定义的。每个方法对应一种 HTTP 请求方法，并且可以指定一个或多个处理函数。</p>
</li>
<li>
<p>我们可以通过新建一个js文件来专门地挂载路由，并通过module将router对象共享出去。</p>
</li>
</ol>
<pre><code>const express = require('express')  // 导入express模块
const router = express.Router()     // 创建路由对象

router.get('/', function(req, res){
    res.send("Welcome to MangoChat Index")
})

router.get('/about', function(req, res){
    res.send("There is about for MangoChat")
})

module.exports = router
</code></pre>
<ol>
<li>回到index,js，我们将共享的router对象接收，最后绑定路由即可使用。</li>
</ol>
<pre><code>const router = require('./router.js')
app.use(router)
</code></pre>
<h2>中间件</h2>
<blockquote>
<p>中间件（Middleware） 是一个非常强大的功能，它允许你在请求和响应的生命周期中插入自定义逻辑。中间件可以执行各种任务，例如解析请求体、验证用户身份、日志记录、错误处理等。</p>
</blockquote>
<ol>
<li>中间件是一个函数，它接收 req（请求对象）、res（响应对象）和 next（一个函数，用于将控制权传递给下一个中间件或路由处理函数）作为参数。中间件可以执行以下操作：</li>
</ol>
<ul>
<li>访问请求和响应对象：通过 req 和 res 访问请求和响应的详细信息。</li>
<li>执行任意代码：在请求处理过程中执行自定义逻辑。</li>
<li>调用堆栈中的下一个中间件：通过调用 next() 将控制权传递给下一个中间件或路由处理函数。</li>
<li>终止请求-响应周期：通过调用 res.send()、res.json() 或其他响应方法来结束响应。</li>
</ul>
<p><strong>中间件的类型</strong>
Express 中间件可以分为以下几种类型：</p>
<ul>
<li>应用级中间件：绑定到 app 对象，使用 <code>app.use()</code>或路由方法（如 app.get()、app.post() 等）。</li>
<li>路由级中间件：绑定到 Router 对象，使用 <code>router.use()</code> 或路由方法（如 router.get()、router.post() 等）。</li>
<li>错误处理中间件：专门用于捕获和处理错误，通常有四个参数：err、req、res 和 next。</li>
<li>内置中间件：Express 自带的中间件，如 <code>express.static</code>。</li>
<li>第三方中间件：由社区提供的中间件，如 <code>body-parser</code>、<code>cookie-parser</code>、<code>morgan</code> 等。</li>
</ul>
<blockquote>
<p>如果当前中间件函数没有结束请求-响应循环，它必须调用 <code>next()</code> 将控制权传递给下一个中间件函数。否则，请求将被挂起。</p>
</blockquote>
<h3>全局中间件</h3>
<blockquote>
<p>全局中间件 是一种应用级中间件，它会在每个请求和响应的生命周期中被调用，而不管请求的路径或方法是什么。</p>
</blockquote>
<ol>
<li>将中间件绑定到<code>路由</code>或者<code>app.use()</code>中，便即可实现全局中间件的效果，每当有客户端向服务器发生请求必定触发该中间件。</li>
</ol>
<pre><code>var Mw = function(req, res, next){
    console.log("成功调用一个全局中间件")
    next()
}
router.use(Mw)
</code></pre>
<ol>
<li>为了更加优雅，我们也可以写成一下形式。</li>
</ol>
<pre><code>router.use((req, res, next)=&gt;{
    console.log("成功调用一个全局中间件")
    next()
})
</code></pre>
<h3>局部中间件</h3>
<blockquote>
<p>局部中间件会在指定的请求页面中被调用。</p>
</blockquote>
<ol>
<li>只需要将中间件放到需要监听的位置即可。</li>
</ol>
<pre><code>const mv = function(req,res, next){
    console.log("局部中间件")
}
router.get('/',function(req, res){
    res.send("Welcome to MangoChat Index")
})
</code></pre>
<h2>MySQL数据库</h2>
<h4>配置数据库</h4>
<ol>
<li>安装<code>mysql</code>模块</li>
</ol>
<pre><code>npm install mysql
</code></pre>
<ol>
<li>导入<code>mysql</code>模块，并创建mysql的连接对象。</li>
<li>这里通过 <code>mysql.createConnection()</code> 方法创建了一个数据库连接对象。配置对象中包含了连接数据库所需的参数：</li>
</ol>
<ul>
<li>host：数据库服务器地址（通常是 localhost）。</li>
<li>user：数据库用户名。</li>
<li>password：数据库密码。</li>
<li>database：要连接的数据库名称。</li>
</ul>
<ol>
<li>接着我们执行一个简单的查询，查询语句是 <code>select 1</code>，这是一个简单的测试查询，用于检查连接是否正常。</li>
<li>其中<code>err</code> 和 <code>result</code> 是 mysql 模块在执行数据库操作时，回调函数中返回的<code>两个参数</code>，它们分别代表了操作的<code>错误信息</code>和<code>操作</code>的结果。</li>
<li>当返回<code>[ RowDataPacket { '1': 1 } ]</code>则表示连接和查询成功了，否则输出报错。</li>
</ol>
<pre><code>const mysql = require('mysql')

const connect = mysql.createConnection({
    host: 'localhost',
    user: 'root',
    password: 'root',
    database: 'mc_user',
})

connect.query('select 1', (err, result)=&gt;{
    if(err) return console.log(err.message)
    console.log(result)
})
</code></pre>
<h3>查询与插入</h3>
<h4>查询</h4>
<ol>
<li>补充一下上面的query方法</li>
<li><code>query</code>是 <code>mysql 模块提供的一个核心方法</code>，用于执行 SQL 查询语句。它是 mysql 模块中最常用的方法之一，允许开发者在 Node.js 中与 MySQL 数据库交互。</li>
<li>例如如下代码，我们可以通过在query中给定一个SQL语句：<code>SELECT * FROM user_info</code>，来查询到表<code>user_info</code>中的所有数据并输出在控制台。</li>
</ol>
<pre><code>connect.query('SELECT * FROM user_info', (err, result)=&gt;{
    if(err) return console.log(err.message)
    console.log(result)
})
</code></pre>
<h4>插入</h4>
<ol>
<li>当我们需要插入数据的时候，可以先定义一个对象方便插入。</li>
<li>为了语句更加优雅，所以我们将SQL写在字面量中。</li>
<li>在<code>(id, user_name, user_password, user_creatdata)</code>括号中的分别都是表中已经定义好的表字段。<code>VALUES()</code>则表示以何种数据类型的方式进行插入，默认使用<code>?</code>，它作用是将用户输入的值<code>安全地插入到 SQL 查询中</code>，从而<code>防止 SQL 注入</code>攻击。</li>
<li>最后在判断语句中利用<code>affectedRows</code>的值来判断插入是否成功。affectedRows表示的是受当前 SQL 操作影响的行数，当值为<code>1</code>时，则表明语句执行成功。</li>
</ol>
<pre><code>// 定义插入的对象数据
const user = {id:2, user_name:'Boom', user_password:'root', user_creatdata:'2025-03-02'}   
const SQLexpress = 'INSERT INTO user_info (id, user_name, user_password, user_creatdata) VALUES(?, ?, ?, ?)'  

// 定义SQL语句
connect.query(SQLexpress, [user.id, user.user_name, user.user_password, user.user_creatdata], function(err, result){
        if(err) return console.log(err.message)   // 出现错误则报错
        if(result.affectedRows == 1) console.log(result) 
        console.log("数据插入成功")   // 输出成功
}) 
</code></pre>
<h4>更新</h4>
<ol>
<li>当我们需要更新的时候，也可以使用同样的方法，下面是一个模拟了用户更改密码的例子。</li>
<li>定一个对象，例如，用户almango想将旧密码修改为'123'。</li>
<li>SQL语句：<code>'UPDATE user_info SET user_password = ? WHERE user_name = ?'</code>，可以理解为从user_name开始修改字段为：user_password的内容。</li>
<li>和上面的一样，当affectedRows为1，则执行成功。</li>
</ol>
<pre><code>const update_user = {user_name:'almango', user_password: '123'}
const SQLexpress = 'UPDATE user_info SET user_password = ? WHERE user_name = ?'
    
connect.query(SQLexpress, [update_user.user_password, update_user.user_name, ], function(err, result){
    if(err) return console.log(err.message)   // 出现错误则报错
    if(result.affectedRows == 1) console.log(result)
    console.log("数据修改成功")   // 输出成功
})
</code></pre>
<h4>删除</h4>
<pre><code>const SQLexpress = 'DELETE FROM user_info WHERE user_name=?';
    connect.query(SQLexpress, [NAME], function(err, result){
        if(err) return console.log(err.message)   // 出现错误则报错
        if(result.affectedRows == 1) console.log(result)  // 输出成功
        console.log("数据删除成功")
})
</code></pre>
<blockquote>
<p>本人不敢苟同，我认为意大利面就应该拌42号混泥土，因为螺丝钉的长度会直接影响到挖掘机的扭矩</p>
</blockquote>
<h3>用户注册</h3>
<ol>
<li>编写好html的注册页面</li>
<li>将<code>method</code>设置为<code>post</code>，action为当前页面的路径</li>
<li>注意一下input的<code>name属性，一定要设置</code>，因为提交的数据会自动生成一个json数据，name对应的就是用户和密码。</li>
</ol>
<pre><code>&lt;body&gt;
   &lt;div class="container"&gt;
      &lt;p style="font-size: 25px; text-align: center;padding: 30px;font-family: 'Josefin Sans', sans-serif;"&gt;MangoChat&lt;/p&gt;
      &lt;div class="input-box"&gt;
      &lt;form method="post" action="/register"&gt;
         &lt;input type="text" placeholder="请输入账户ID" required="required" name="username" autocomplete="off"&gt;&lt;br&gt;&lt;br&gt;
         &lt;input type="password" placeholder="请输入账户密码" required name="password"&gt;&lt;br&gt;&lt;br&gt;
         &lt;input type="password" placeholder="请输入再次确认密码" required name="res_password"&gt;&lt;br&gt;&lt;br&gt;
         &lt;input id="submit" type="submit" value="注册"&gt;
            &lt;p class="register-now"style="text-align: left;"&gt;已有账户？&lt;a href="/login.html" style="color: rgb(68, 116, 218);text-decoration: none;"&gt;前往登录&lt;/a&gt;&lt;/p&gt;
         &lt;/form&gt;
      &lt;/div&gt;
   &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<pre><code>const mysql = require('mysql')
const connect = mysql.createConnection({
    host: 'localhost',
    user: 'root',
    password: 'root',
    database: 'mc_user',
})
function SQLInsert(NAME, PASSWORD, CREATION_DATE) {
    const user = {user_name: NAME, user_password: PASSWORD, user_creationdate: CREATION_DATE }   // 定义插入的对象数据
    const SQLexpress = 'INSERT INTO user_info (user_name, user_password, user_creationdate) VALUES(?, ?, ?)'  // 定义SQL语句

    connect.query(SQLexpress, [user.user_name, user.user_password, user.user_creationdate], function (err, result) {
        if (err) return console.log(err.message)   // 出现错误则报错
        if (result.affectedRows == 1) console.log(result)  // 输出成功
        console.log("数据插入成功")
    })
}
module.exports = {SQLInsert,};
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Vue3部署与基本语法实例【1】</title>
    <link href="https://mizuki.mysqil.com/posts/vue3%E9%83%A8%E7%BD%B2%E4%B8%8E%E8%AF%AD%E6%B3%95%E5%88%9D%E5%A7%8B1/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/vue3%E9%83%A8%E7%BD%B2%E4%B8%8E%E8%AF%AD%E6%B3%95%E5%88%9D%E5%A7%8B1/</id>
    <published>2025-02-14T18:51:00.000Z</published>
    <updated>2025-02-14T18:51:00.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h1>Vue</h1>
<p>1 . <strong>Vue</strong>是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。</p>
<h1>渐进式框架</h1>
<p><strong>Vue</strong> 是一个框架，也是一个生态。其功能覆盖了大部分前端开发常见的需求。但 Web 世界是十分多样化的，不同的开发者在 Web 上构建的东西可能在形式和规模上会有很大的不同。考虑到这一点，Vue 的设计非常注重灵活性和“可以被逐步集成”这个特点。根据你的需求场景，你可以用不同的方式使用 Vue：</p>
<ul>
<li>无需构建步骤，渐进式增强静态的 HTML</li>
<li>在任何页面中作为 Web Components 嵌入</li>
<li>单页应用 (SPA)</li>
<li>全栈 / 服务端渲染 (SSR)</li>
<li>Jamstack / 静态站点生成 (SSG)</li>
<li>开发桌面端、移动端、WebGL，甚至是命令行终端中的界面</li>
</ul>
<h1>部署</h1>
<blockquote>
<p>所需环境: Node.js</p>
</blockquote>
<p>1 . 创建Vue项目</p>
<pre><code>npm init vue@latest
</code></pre>
<p>2 .安装Vue依赖项</p>
<pre><code>npm install
</code></pre>
<h1>目录描述</h1>
<p>1 . 用于了解创建好的Vue项目目录结构(下面做了一些的修改，忽略了src下的一些子文件)</p>
<pre><code>Vue3-Project/
├── node_modules/             # 项目所依赖的Node模块
├── public/                   # 公共资源目录
│   └── favicon.ico           # 图标
├── src/                      # 源代码目录
│   ├── assets/               # 静态资源，如图像、字体等
│   ├── components/           # 存放 Vue 组件，每个组件都是一个独立的 .vue 文件
│   ├── views/                # 存放视图组件
│   │   └── Home.vue          # 默认生成的主页组件。
│   ├── App.vue               # 根组件，整个应用的入口组件。
│   ├── main.js               # 应用的入口文件，负责创建 Vue 实例并挂载到 DOM 上。
│   └── router/               # 存放路由配置文件。
│       └── index.js          # 路由的配置文件，定义了应用的路由规则。
├── .gitignore                # Git 忽略文件列表，指定哪些文件和目录不被包含在版本控制中
├── index.html                # 应用的主 HTML 文件，Vue CLI 会在构建时自动注入生成的静态资源链接。
├── babel.config.js           # Babel 配置文件，指定 Babel 的编译规则。
├── package.json              # 项目的依赖、脚本和其他元数据。
├── README.md                 # 项目的说明文件
├── vue.config.js             # Vue CLI 的配置文件，用于修改默认配置。
└── yarn.lock or package-lock.json   # 锁定安装的依赖版本，确保项目依赖的一致性。
</code></pre>
<h1>运行</h1>
<pre><code>npm run dev
</code></pre>
<h1>选项式与组合式</h1>
<p>1 . 在 Vue 中，选项式 API（<code>Options API</code>）和组合式 API（<code>Composition API</code>）是两种不同的组件编写方式，选项式属于Vue2的编写风格，组合式是Vue3的编写风格。两者各有优缺点，适用于不同的场景。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/vue3_1_1.png" alt="" /></p>
<blockquote>
<p>我仿照<code>大帅老猿（掘金）</code>的动图设计了一张简易图纸，我们也可以查看下列代码来区别两者</p>
</blockquote>
<ul>
<li><strong>选项式 API</strong>：通过一组选项（如 data、methods、computed、watch 等）来定义组件的状态、逻辑和行为。</li>
</ul>
<pre><code>export default {
  data() {
    return { count: 0 };
  },
  methods: {
    increment() {
      this.count++;
    }
  },
  computed: {
    doubleCount() {
      return this.count * 2;
    }
  }
};
</code></pre>
<ul>
<li><strong>组合式 API</strong>：通过 setup 函数组织逻辑，允许将相关逻辑集中在一起，不受选项划分的限制。</li>
</ul>
<pre><code>import { ref, computed } from 'vue';

export default {
  setup() {
    const count = ref(0);
    const increment = () =&gt; count.value++;
    const doubleCount = computed(() =&gt; count.value * 2);

    return { count, increment, doubleCount };
  }
};
</code></pre>
<p>2 . 可以看到，组合式编写风格是要比选项式编写风格要简洁许多的。
3 . 在<code>Options API</code>中的代码是需要进行严格规范的，比如，所有的<code>方法</code>统一写到<code>methods()</code>函数中，所有声明的数据必须写在<code>data()</code>函数中，最后通过<code>return()</code>函数将内容返回给渲染页面。这就导致原本一起的代码变得十分的分散，这是选项式API的一大弊端，而<code>Composition API</code>则更像Javascript，你声明完变量后可以立马在下面接着写方法.....
4 . 事实上组合式提供更强的灵活性和复用能力，适合大型项目和复杂业务逻辑，而选项式代码逻辑直观且易于维护。
5 . 由于我们学习的Vue3的语法，所以我们会选择更新颖的<code>组合式编写风格</code>。</p>
<p>6 . 另外，组合式还有一种更优雅的返回方法，这样就不需要在写一个return()了。</p>
<pre><code>&lt;script setup&gt;
    const count = ref(0);
    const increment = () =&gt; count.value++;
    const doubleCount = computed(() =&gt; count.value * 2);
&lt;/script&gt;
</code></pre>
<h1>条件渲染</h1>
<h2>v-if</h2>
<blockquote>
<p>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回真值时才被渲染。
1 . 很明显，p标签并<code>不会</code>在页面显示出来，因为返回值都为假。</p>
</blockquote>
<pre><code>&lt;p v-if="expression"&gt;Hello World&lt;/p&gt;
&lt;p v-if="number === 2"&gt;你好世界！&lt;/p&gt;
</code></pre>
<pre><code>&lt;script setup&gt;
    const expression = false;
    const number = 3;
&lt;/script&gt;
</code></pre>
<h2>v-else</h2>
<blockquote>
<p>当v-if不成立时，执行该语句</p>
</blockquote>
<p>1 . 我们继续沿用上面的代码，在此基础上加一个注入了<code>v-else</code>的b标签。expression仍为false，所以最终会<code>显示b标签</code></p>
<pre><code>&lt;p v-if="expression"&gt;Hello World&lt;/p&gt;
&lt;p v-if="number === 2"&gt;你好世界！&lt;/p&gt;
&lt;b v-else&gt;Hello Vue&lt;/b&gt;
</code></pre>
<pre><code>&lt;script setup&gt;
    const expression = false;
    const number = 3;
&lt;/script&gt;
</code></pre>
<h2>v-else-if</h2>
<blockquote>
<p>v-else-if 提供的是相应于 v-if 的“else if 区块”。它可以连续多次重复使用：</p>
</blockquote>
<pre><code>&lt;div v-if="type === 'A'"&gt;
  A
&lt;/div&gt;
&lt;div v-else-if="type === 'B'"&gt;
  B
&lt;/div&gt;
&lt;div v-else-if="type === 'C'"&gt;
  C
&lt;/div&gt;
&lt;div v-else&gt;
  Not A/B/C
&lt;/div&gt;
</code></pre>
<h2>v-show</h2>
<blockquote>
<p>元素无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换。</p>
</blockquote>
<p>1 . <code>v-if</code>和<code>v-show</code>十分相似，但内在原理不同。当条件成立时，v-if会将元素渲染，否则不渲染，而v-show不管成不成立，元素都会被渲染，但受css的display控制是否显示在页面。</p>
<pre><code>&lt;p v-show&gt;无论如何都会被渲染&lt;/p&gt;
</code></pre>
<blockquote>
<p>总的来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 v-show 较好；如果在运行时绑定条件很少改变，则 v-if 会更合适。</p>
</blockquote>
<h1>列表渲染</h1>
<h2>vue-for</h2>
<blockquote>
<p>我们可以使用 v-for 指令基于一个数组来渲染一个列表。</p>
</blockquote>
<p>1 . v-for像极了JavaScript中的迭代器，例如下方代码：在p标签中，name每循环一次会抽取一次space中的值，直到最后......
2 . 结果我们会看到，我们只用了一个p标签，就实现渲染了4个p标签。</p>
<pre><code>&lt;p v-for="name in space"&gt;{{ name }}&lt;/p&gt;
</code></pre>
<pre><code>&lt;script setup&gt;
    const space = ["北京", "江西", "四川", "云南"]
&lt;/script&gt;
</code></pre>
<p>3 . 在上述代码中，我们也可以使用<code>v-for="name of space"</code>,来写，<code>in</code>和<code>of</code>功能上本质是一致的。</p>
<h2>vue-for与对象</h2>
<blockquote>
<p>我们可以使用 v-for 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 Object.values() 的返回值来决定。</p>
</blockquote>
<p>1 . 当我们用到数组对象时，需要分别渲染出数组中的对象时，我们同样可以使用 v-for，并且使用这一功能十分高效！
2 . 我们会使用到三个基本的属性：value、index 和 key。</p>
<ul>
<li>value 表示数组中每个对象的值。</li>
<li>index 表示对象在数组中的下标索引。</li>
<li>key 是一个特殊的属性，用于为 Vue 提供唯一标识，以优化 DOM 更新。它通常是一个字符串，可以是对象的某个唯一属性（如 id），也可以是数组的索引。</li>
</ul>
<p>3 . 下方代码中，我们在div中注入了<code>v-for</code>，使用<code>value</code>和<code>index</code>将取到的值返回给p标签和img标签，这样我分别得到的值为序号，地名和图片链接。其实当我们看到结果的时候会发现，并不是p和img循环了，而是整个div元素(处container外)。</p>
<pre><code>
  &lt;div class="container"&gt;
    &lt;div v-for="(value, index) in trip"&gt;
      &lt;p&gt;{{ value.space }}&lt;/p&gt;
      &lt;img :src="value.img"&gt;
    &lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<pre><code>&lt;script setup&gt;
  const trip = [
        {
          space: "北京",
          img: "https://ts1.cn.mm.bing.net/th/id/R-C.f3838fb03a54d25118a6607861e1bce9?rik=y0XZao50qB2TzA&amp;riu=http%3a%2f%2fimg95.699pic.com%2fphoto%2f50112%2f1130.jpg_wh860.jpg&amp;ehk=%2bT2S%2bRcrhCvzxqKiJqGrKAe6XlXFzKu1kNje3i4F3oE%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0",
          creattime: "2025-2-15-20:41"
        },
        {
          space: "西藏",
          img: "https://ts1.cn.mm.bing.net/th/id/R-C.162267d7399d5a97fa7f18e16009a8e1?rik=as93Op7T1kND7Q&amp;riu=http%3a%2f%2fhimg2.huanqiu.com%2fattachment2010%2f2017%2f0609%2f16%2f24%2f20170609042446633.jpg&amp;ehk=Lt0gA8N3Od1Qpvew3inPQenGQjRZSOcEm8f8eH%2blM9I%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0",
          creattime: "2025-2-15-20:41"
        },
        {
          space: "扬州",
          img: "https://www.szyou.net/uploadpic/20225161848098822.jpg",
          creattime: "2025-2-15-20:41"
        },
        {
          space: "上海",
          img: "https://tse3-mm.cn.bing.net/th/id/OIP-C.6mfrs-U8Vixytje3TtlLLQHaE7?rs=1&amp;pid=ImgDetMain",
          creattime: "2025-2-15-20:41"
        },
      ]
&lt;/script&gt;
</code></pre>
<pre><code>.container {
  width: 90%;
  height: 800px;
  margin: 0 auto;
  box-shadow: rgba(0, 0, 0, 0.15) 1.95px 1.95px 2.6px;
  border-radius: 15px;
  display: flex;
}
.container div{
  padding: 39px;
  text-align: center;
}
.container img{
  width: 300px;
  height: 200px;
  border-radius: 15px;
  transition: all 0.1s ease 0.1s;
  box-shadow: rgba(0, 0, 0, 0.24) 0px 3px 8px;
}
.container img:hover{margin-top: 10px;}
</code></pre>
<h1>响应式</h1>
<blockquote>
<p>Vue.js 是一个构建用户界面的渐进式框架，其核心特性之一是响应式系统。Vue 的响应式系统允许开发者以声明式的方式构建用户界面，当数据发生变化时，视图会自动更新以反映这些变化。</p>
</blockquote>
<p>1 .Vue 的响应式系统不仅仅是简单的数据绑定，Vue 能够自动追踪数据的依赖关系，只有当相关数据发生变化时，才会触发视图更新，Vue 的响应式系统与组件化架构紧密结合，每个组件都有自己的数据和逻辑，便于复用和维护，不仅如此，Vue还提供了丰富的生态系统，如 Vuex（状态管理）、Vue Router（路由管理）等，进一步增强了响应式系统的功能。</p>
<h2>ref函数</h2>
<blockquote>
<p>在组合式 API 中，推荐使用 ref() 函数来声明响应式状态：</p>
</blockquote>
<pre><code>import { ref } from 'vue'
const number = ref(0)
</code></pre>
<p>1 . 例如我们可以使用简单的响应式来实现一个按钮递增的效果。</p>
<pre><code>&lt;button @click="change"&gt;数字递增{{ number }}&lt;/button&gt;
</code></pre>
<pre><code>import { ref } from 'vue';
    const number = ref(0);
    function change(){
        number.value ++;
}
</code></pre>
<blockquote>
<p>#<a href="https://cn.vuejs.org/guide/essentials/reactivity-fundamentals#why-refs">为什么使用ref()？</a></p>
</blockquote>
<h2>reactive函数</h2>
<blockquote>
<p>reactive函数与将内部值包装在特殊对象中的 ref 不同，reactive() 将使对象本身具有响应性。
其实，ref也同样可以做到将对象数据类型响应化，不过它的原理也是调用了reactive函数。</p>
</blockquote>
<pre><code>const Objectlist = reactive(
  [
    {
    name: "Boom",
    password: "123root",
    creattime: "2025-2-15-20:46"
    },
    {
    name: "Lizhi",
    password: "123456",
    creattime: "2025-2-15-20:46"
    }
  ]
)
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Markdown Tutorial</title>
    <link href="https://mizuki.mysqil.com/posts/markdown-tutorial/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/markdown-tutorial/</id>
    <published>2025-01-20T00:00:00.000Z</published>
    <updated>2025-01-20T00:00:00.000Z</updated>
    <summary>A simple example of a Markdown blog post.</summary>
    <content type="html"><![CDATA[<h1>Markdown Tutorial</h1>
<p>A markdown example shows how to write a markdown file. This document integrates core syntax and extensions (GMF).</p>
<ul>
<li><a href="#block-elements">Block Elements</a>
<ul>
<li><a href="#paragraphs-and-line-breaks">Paragraphs and Line Breaks</a></li>
<li><a href="#headers">Headers</a></li>
<li><a href="#blockquotes">Blockquotes</a></li>
<li><a href="#lists">Lists</a></li>
<li><a href="#code-blocks">Code Blocks</a></li>
<li><a href="#horizontal-rules">Horizontal Rules</a></li>
<li><a href="#table">Table</a></li>
</ul>
</li>
<li><a href="#span-elements">Span Elements</a>
<ul>
<li><a href="#links">Links</a></li>
<li><a href="#emphasis">Emphasis</a></li>
<li><a href="#code">Code</a></li>
<li><a href="#images">Images</a></li>
<li><a href="#strikethrough">Strikethrough</a></li>
</ul>
</li>
<li><a href="#miscellaneous">Miscellaneous</a>
<ul>
<li><a href="#automatic-links">Automatic Links</a></li>
<li><a href="#backslash-escapes">Backslash Escapes</a></li>
</ul>
</li>
<li><a href="#inline-html">Inline HTML</a></li>
</ul>
<h2>Block Elements</h2>
<h3>Paragraphs and Line Breaks</h3>
<h4>Paragraphs</h4>
<p>HTML Tag: <code>&lt;p&gt;</code></p>
<p>One or more blank lines. (A blank line is a line containing nothing but <strong>spaces</strong> or <strong>tabs</strong> is considered blank.)</p>
<p>Code:</p>
<pre><code>This will be
inline.

This is second paragraph.
</code></pre>
<p>Preview:</p>
<hr />
<p>This will be
inline.</p>
<p>This is second paragraph.</p>
<hr />
<h4>Line Breaks</h4>
<p>HTML Tag: <code>&lt;br /&gt;</code></p>
<p>End a line with <strong>two or more spaces</strong>.</p>
<p>Code:</p>
<pre><code>This will be not
inline.
</code></pre>
<p>Preview:</p>
<hr />
<p>This will be not<br />
inline.</p>
<hr />
<h3>Headers</h3>
<p>Markdown supports two styles of headers, Setext and atx.</p>
<h4>Setext</h4>
<p>HTML Tags: <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code></p>
<p>"Underlined" using <strong>equal signs (=)</strong> as <code>&lt;h1&gt;</code> and <strong>dashes (-)</strong> as <code>&lt;h2&gt;</code> in any number.</p>
<p>Code:</p>
<pre><code>This is an H1
=============
This is an H2
-------------
</code></pre>
<p>Preview:</p>
<hr />
<h1>This is an H1</h1>
<h2>This is an H2</h2>
<hr />
<h4>atx</h4>
<p>HTML Tags: <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>, <code>&lt;h4&gt;</code>, <code>&lt;h5&gt;</code>, <code>&lt;h6&gt;</code></p>
<p>Uses 1-6 <strong>hash characters (#)</strong> at the start of the line, corresponding to <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code>.</p>
<p>Code:</p>
<pre><code># This is an H1
## This is an H2
###### This is an H6
</code></pre>
<p>Preview:</p>
<hr />
<h1>This is an H1</h1>
<h2>This is an H2</h2>
<h6>This is an H6</h6>
<hr />
<p>Optionally, you may "close" atx-style headers. The closing hashes <strong>don't need to match</strong> the number of hashes used to open the header.</p>
<p>Code:</p>
<pre><code># This is an H1 #
## This is an H2 ##
### This is an H3 ######
</code></pre>
<p>Preview:</p>
<hr />
<h1>This is an H1</h1>
<h2>This is an H2</h2>
<h3>This is an H3</h3>
<hr />
<h3>Blockquotes</h3>
<p>HTML Tag: <code>&lt;blockquote&gt;</code></p>
<p>Markdown uses email-style <strong>&gt;</strong> characters for blockquoting. It looks best if you hard wrap the text and put a &gt; before every line.</p>
<p>Code:</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&gt;
&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&gt; id sem consectetuer libero luctus adipiscing.
</code></pre>
<p>Preview:</p>
<hr />
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
<hr />
<p>Markdown allows you to be lazy and only put the &gt; before the first line of a hard-wrapped paragraph.</p>
<p>Code:</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
</code></pre>
<p>Preview:</p>
<hr />
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
</blockquote>
<blockquote>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
<hr />
<p>Blockquotes can be nested (i.e. a blockquote-in-a-blockquote) by adding additional levels of &gt;.</p>
<p>Code:</p>
<pre><code>&gt; This is the first level of quoting.
&gt;
&gt; &gt; This is nested blockquote.
&gt;
&gt; Back to the first level.
</code></pre>
<p>Preview:</p>
<hr />
<blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
<hr />
<p>Blockquotes can contain other Markdown elements, including headers, lists, and code blocks.</p>
<p>Code:</p>
<pre><code>&gt; ## This is a header.
&gt;
&gt; 1.   This is the first list item.
&gt; 2.   This is the second list item.
&gt;
&gt; Here's some example code:
&gt;
&gt;     return shell_exec("echo $input | $markdown_script");
</code></pre>
<p>Preview:</p>
<hr />
<blockquote>
<h2>This is a header.</h2>
<ol>
<li>This is the first list item.</li>
<li>This is the second list item.</li>
</ol>
<p>Here's some example code:</p>
<pre><code>return shell_exec("echo $input | $markdown_script");
</code></pre>
</blockquote>
<hr />
<h3>Lists</h3>
<p>Markdown supports ordered (numbered) and unordered (bulleted) lists.</p>
<h4>Unordered</h4>
<p>HTML Tag: <code>&lt;ul&gt;</code></p>
<p>Unordered lists use <strong>asterisks (*)</strong>, <strong>pluses (+)</strong>, and <strong>hyphens (-)</strong>.</p>
<p>Code:</p>
<pre><code>*   Red
*   Green
*   Blue
</code></pre>
<p>Preview:</p>
<hr />
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<hr />
<p>is equivalent to:</p>
<p>Code:</p>
<pre><code>+   Red
+   Green
+   Blue
</code></pre>
<p>and:</p>
<p>Code:</p>
<pre><code>-   Red
-   Green
-   Blue
</code></pre>
<h4>Ordered</h4>
<p>HTML Tag: <code>&lt;ol&gt;</code></p>
<p>Ordered lists use numbers followed by periods:</p>
<p>Code:</p>
<pre><code>1.  Bird
2.  McHale
3.  Parish
</code></pre>
<p>Preview:</p>
<hr />
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<hr />
<p>It's possible to trigger an ordered list by accident, by writing something like this:</p>
<p>Code:</p>
<pre><code>1986. What a great season.
</code></pre>
<p>Preview:</p>
<hr />
<ol>
<li>What a great season.</li>
</ol>
<hr />
<p>You can <strong>backslash-escape (\)</strong> the period:</p>
<p>Code:</p>
<pre><code>1986\. What a great season.
</code></pre>
<p>Preview:</p>
<hr />
<p>1986. What a great season.</p>
<hr />
<h4>Indented</h4>
<h5>Blockquote</h5>
<p>To put a blockquote within a list item, the blockquote's &gt; delimiters need to be indented:</p>
<p>Code:</p>
<pre><code>*   A list item with a blockquote:

    &gt; This is a blockquote
    &gt; inside a list item.
</code></pre>
<p>Preview:</p>
<hr />
<ul>
<li>
<p>A list item with a blockquote:</p>
<blockquote>
<p>This is a blockquote
inside a list item.</p>
</blockquote>
</li>
</ul>
<hr />
<h5>Code Block</h5>
<p>To put a code block within a list item, the code block needs to be indented twice — <strong>8 spaces</strong> or <strong>two tabs</strong>:</p>
<p>Code:</p>
<pre><code>*   A list item with a code block:

        &lt;code goes here&gt;
</code></pre>
<p>Preview:</p>
<hr />
<ul>
<li>
<p>A list item with a code block:</p>
<pre><code>&lt;code goes here&gt;
</code></pre>
</li>
</ul>
<hr />
<h5>Nested List</h5>
<p>Code:</p>
<pre><code>* A
  * A1
  * A2
* B
* C
</code></pre>
<p>Preview:</p>
<hr />
<ul>
<li>A
<ul>
<li>A1</li>
<li>A2</li>
</ul>
</li>
<li>B</li>
<li>C</li>
</ul>
<hr />
<h3>Code Blocks</h3>
<p>HTML Tag: <code>&lt;pre&gt;</code></p>
<p>Indent every line of the block by at least <strong>4 spaces</strong> or <strong>1 tab</strong>.</p>
<p>Code:</p>
<pre><code>This is a normal paragraph:

    This is a code block.
</code></pre>
<p>Preview:</p>
<hr />
<p>This is a normal paragraph:</p>
<pre><code>This is a code block.
</code></pre>
<hr />
<p>A code block continues until it reaches a line that is not indented (or the end of the article).</p>
<p>Within a code block, <strong><em>ampersands (&amp;)</em></strong> and angle <strong>brackets (&lt; and &gt;)</strong> are automatically converted into HTML entities.</p>
<p>Code:</p>
<pre><code>    &lt;div class="footer"&gt;
        &amp;copy; 2004 Foo Corporation
    &lt;/div&gt;
</code></pre>
<p>Preview:</p>
<hr />
<pre><code>&lt;div class="footer"&gt;
    &amp;copy; 2004 Foo Corporation
&lt;/div&gt;
</code></pre>
<hr />
<p>Following sections Fenced Code Blocks and Syntax Highlighting are extensions, you can use the other way to write the code block.</p>
<h4>Fenced Code Blocks</h4>
<p>Just wrap your code in <code>```</code> (as shown below) and you won't need to indent it by four spaces.</p>
<p>Code:</p>
<pre><code>Here's an example:

```
function test() {
  console.log("notice the blank line before this function?");
}
```
</code></pre>
<p>Preview:</p>
<hr />
<p>Here's an example:</p>
<pre><code>function test() {
  console.log("notice the blank line before this function?");
}
</code></pre>
<hr />
<h4>Syntax Highlighting</h4>
<p>In your fenced block, add an optional language identifier and we'll run it through syntax highlighting (<a href="https://github.com/github/linguist/blob/master/lib/linguist/languages.yml">Support Languages</a>).</p>
<p>Code:</p>
<pre><code>```ruby
require 'redcarpet'
markdown = Redcarpet.new("Hello World!")
puts markdown.to_html
```
</code></pre>
<p>Preview:</p>
<hr />
<pre><code>require 'redcarpet'
markdown = Redcarpet.new("Hello World!")
puts markdown.to_html
</code></pre>
<hr />
<h3>Horizontal Rules</h3>
<p>HTML Tag: <code>&lt;hr /&gt;</code>
Places <strong>three or more hyphens (-), asterisks (*), or underscores (_)</strong> on a line by themselves. You may use spaces between the hyphens or asterisks.</p>
<p>Code:</p>
<pre><code>* * *
***
*****
- - -
---------------------------------------
___
</code></pre>
<p>Preview:</p>
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<h3>Table</h3>
<p>HTML Tag: <code>&lt;table&gt;</code></p>
<p>It's an extension.</p>
<p>Separates column by <strong>pipe (|)</strong> and header by <strong>dashes (-)</strong>, and uses <strong>colon (:)</strong> for alignment.</p>
<p>The outer <strong>pipes (|)</strong> and alignment are optional. There are <strong>3 delimiters</strong> each cell at least for separating header.</p>
<p>Code:</p>
<pre><code>| Left | Center | Right |
|:-----|:------:|------:|
|aaa   |bbb     |ccc    |
|ddd   |eee     |fff    |

 A | B
---|---
123|456


A |B
--|--
12|45
</code></pre>
<p>Preview:</p>
<hr />
<table>
<thead>
<tr>
<th>Left</th>
<th>Center</th>
<th>Right</th>
</tr>
</thead>
<tbody>
<tr>
<td>aaa</td>
<td>bbb</td>
<td>ccc</td>
</tr>
<tr>
<td>ddd</td>
<td>eee</td>
<td>fff</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>123</td>
<td>456</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>45</td>
</tr>
</tbody>
</table>
<hr />
<h2>Span Elements</h2>
<h3>Links</h3>
<p>HTML Tag: <code>&lt;a&gt;</code></p>
<p>Markdown supports two style of links: inline and reference.</p>
<h4>Inline</h4>
<p>Inline link format like this: <code>[Link Text](URL "Title")</code></p>
<p>Title is optional.</p>
<p>Code:</p>
<pre><code>This is [an example](http://example.com/ "Title") inline link.

[This link](http://example.net/) has no title attribute.
</code></pre>
<p>Preview:</p>
<hr />
<p>This is <a href="http://example.com/">an example</a> inline link.</p>
<p><a href="http://example.net/">This link</a> has no title attribute.</p>
<hr />
<p>If you're referring to a local resource on the same server, you can use relative paths:</p>
<p>Code:</p>
<pre><code>See my [About](/about/) page for details.
</code></pre>
<p>Preview:</p>
<hr />
<p>See my <a href="/about/">About</a> page for details.</p>
<hr />
<h4>Reference</h4>
<p>You could predefine link references. Format like this: <code>[id]: URL "Title"</code></p>
<p>Title is also optional. And the you refer the link, format like this: <code>[Link Text][id]</code></p>
<p>Code:</p>
<pre><code>[id]: http://example.com/  "Optional Title Here"
This is [an example][id] reference-style link.
</code></pre>
<p>Preview:</p>
<hr />
<p>This is <a href="http://example.com/">an example</a> reference-style link.</p>
<hr />
<p>That is:</p>
<ul>
<li>Square brackets containing the link identifier (<strong>not case sensitive</strong>, optionally indented from the left margin using up to three spaces);</li>
<li>followed by a colon;</li>
<li>followed by one or more spaces (or tabs);</li>
<li>followed by the URL for the link;</li>
<li>The link URL may, optionally, be surrounded by angle brackets.</li>
<li>optionally followed by a title attribute for the link, enclosed in double or single quotes, or enclosed in parentheses.</li>
</ul>
<p>The following three link definitions are equivalent:</p>
<p>Code:</p>
<pre><code>[foo]: http://example.com/  "Optional Title Here"
[foo]: http://example.com/  'Optional Title Here'
[foo]: http://example.com/  (Optional Title Here)
[foo]: &lt;http://example.com/&gt;  "Optional Title Here"
</code></pre>
<p>Uses an empty set of square brackets, the link text itself is used as the name.</p>
<p>Code:</p>
<pre><code>[Google]: http://google.com/
[Google][]
</code></pre>
<p>Preview:</p>
<hr />
<p><a href="http://google.com/">Google</a></p>
<hr />
<h3>Emphasis</h3>
<p>HTML Tags: <code>&lt;em&gt;</code>, <code>&lt;strong&gt;</code></p>
<p>Markdown treats <strong>asterisks (*)</strong> and <strong>underscores (_)</strong> as indicators of emphasis. <strong>One delimiter</strong> will be <code>&lt;em&gt;</code>; *<em>double delimiters</em> will be <code>&lt;strong&gt;</code>.</p>
<p>Code:</p>
<pre><code>*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
</code></pre>
<p>Preview:</p>
<hr />
<p><em>single asterisks</em></p>
<p><em>single underscores</em></p>
<p><strong>double asterisks</strong></p>
<p><strong>double underscores</strong></p>
<hr />
<p>But if you surround an * or _ with spaces, it'll be treated as a literal asterisk or underscore.</p>
<p>You can backslash escape it:</p>
<p>Code:</p>
<pre><code>\*this text is surrounded by literal asterisks\*
</code></pre>
<p>Preview:</p>
<hr />
<p>*this text is surrounded by literal asterisks*</p>
<hr />
<h3>Code</h3>
<p>HTML Tag: <code>&lt;code&gt;</code></p>
<p>Wraps it with <strong>backtick quotes (`)</strong>.</p>
<p>Code:</p>
<pre><code>Use the `printf()` function.
</code></pre>
<p>Preview:</p>
<hr />
<p>Use the <code>printf()</code> function.</p>
<hr />
<p>To include a literal backtick character within a code span, you can use <strong>multiple backticks</strong> as the opening and closing delimiters:</p>
<p>Code:</p>
<pre><code>``There is a literal backtick (`) here.``
</code></pre>
<p>Preview:</p>
<hr />
<p><code>There is a literal backtick (`) here.</code></p>
<hr />
<p>The backtick delimiters surrounding a code span may include spaces — one after the opening, one before the closing. This allows you to place literal backtick characters at the beginning or end of a code span:</p>
<p>Code:</p>
<pre><code>A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
</code></pre>
<p>Preview:</p>
<hr />
<p>A single backtick in a code span: <code>`</code></p>
<p>A backtick-delimited string in a code span: <code>`foo`</code></p>
<hr />
<h3>Images</h3>
<p>HTML Tag: <code>&lt;img /&gt;</code></p>
<p>Markdown uses an image syntax that is intended to resemble the syntax for links, allowing for two styles: inline and reference.</p>
<h4>Inline</h4>
<p>Inline image syntax looks like this: <code>![Alt text](URL "Title")</code></p>
<p>Title is optional.</p>
<p>Code:</p>
<pre><code>![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg "Optional title")
</code></pre>
<p>Preview:</p>
<hr />
<p><img src="https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp" alt="Alt text" /></p>
<p><img src="https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp" alt="Alt text" title="Optional title" /></p>
<hr />
<p>That is:</p>
<ul>
<li>An exclamation mark: !;</li>
<li>followed by a set of square brackets, containing the alt attribute text for the image;</li>
<li>followed by a set of parentheses, containing the URL or path to the image, and an optional title attribute enclosed in double or single quotes.</li>
</ul>
<h4>Reference</h4>
<p>Reference-style image syntax looks like this: <code>![Alt text][id]</code></p>
<p>Code:</p>
<pre><code>[img id]: https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp  "Optional title attribute"
![Alt text][img id]
</code></pre>
<p>Preview:</p>
<hr />
<p><img src="https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp" alt="Alt text" title="Optional title attribute" /></p>
<hr />
<h3>Strikethrough</h3>
<p>HTML Tag: <code>&lt;del&gt;</code></p>
<p>It's an extension.</p>
<p>GFM adds syntax to strikethrough text.</p>
<p>Code:</p>
<pre><code>~~Mistaken text.~~
</code></pre>
<p>Preview:</p>
<hr />
<p><s>Mistaken text.</s></p>
<hr />
<h2>Miscellaneous</h2>
<h3>Automatic Links</h3>
<p>Markdown supports a shortcut style for creating "automatic" links for URLs and email addresses: simply surround the URL or email address with angle brackets.</p>
<p>Code:</p>
<pre><code>&lt;http://example.com/&gt;

&lt;address@example.com&gt;
</code></pre>
<p>Preview:</p>
<hr />
<p><a href="http://example.com/">http://example.com/</a></p>
<p><a href="mailto:address@example.com">address@example.com</a></p>
<hr />
<p>GFM will autolink standard URLs.</p>
<p>Code:</p>
<pre><code>https://github.com/emn178/markdown
</code></pre>
<p>Preview:</p>
<hr />
<p>https://github.com/emn178/markdown</p>
<hr />
<h3>Backslash Escapes</h3>
<p>Markdown allows you to use backslash escapes to generate literal characters which would otherwise have special meaning in Markdown's formatting syntax.</p>
<p>Code:</p>
<pre><code>\*literal asterisks\*
</code></pre>
<p>Preview:</p>
<hr />
<p>*literal asterisks*</p>
<hr />
<p>Markdown provides backslash escapes for the following characters:</p>
<p>Code:</p>
<pre><code>\   backslash
`   backtick
*   asterisk
_   underscore
{}  curly braces
[]  square brackets
()  parentheses
#   hash mark
+   plus sign
-   minus sign (hyphen)
.   dot
!   exclamation mark
</code></pre>
<h2>Inline HTML</h2>
<p>For any markup that is not covered by Markdown's syntax, you simply use HTML itself. There's no need to preface it or delimit it to indicate that you're switching from Markdown to HTML; you just use the tags.</p>
<p>Code:</p>
<pre><code>This is a regular paragraph.

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Foo&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

This is another regular paragraph.
</code></pre>
<p>Preview:</p>
<hr />
<p>This is a regular paragraph.</p>
<p>&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;Foo&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;</p>
<p>This is another regular paragraph.</p>
<hr />
<p>Note that Markdown formatting syntax is <strong>not processed within block-level HTML tags</strong>.</p>
<p>Unlike block-level HTML tags, Markdown syntax is <strong>processed within span-level tags</strong>.</p>
<p>Code:</p>
<pre><code>&lt;span&gt;**Work**&lt;/span&gt;

&lt;div&gt;
    **No Work**
&lt;/div&gt;
</code></pre>
<p>Preview:</p>
<hr />
<p>&lt;span&gt;<strong>Work</strong>&lt;/span&gt;</p>
<p>&lt;div&gt;
<strong>No Work</strong>
&lt;/div&gt;</p>
<hr />
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="Examples"></category>
  </entry>
  <entry>
    <title>2024年度总结报告</title>
    <link href="https://mizuki.mysqil.com/posts/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/</id>
    <published>2025-01-01T21:10:01.000Z</published>
    <updated>2025-01-01T21:10:01.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>序言</h2>
<blockquote>
<p>1 . 很久没写文章了呢……这里就先祝家人们元旦新年快乐！</p>
</blockquote>
<p>2 . 咳！如果不是元旦，恐怕我都懒得动手写了哈哈。
3 . 这里还是和往年一样，===这次我就不再长篇大论了，咱们长话短说。</p>
<p><strong>我印象中2024年的似乎是从六月份开始的，我始终记不起上半年所发生的一切，但唯独那年三月......</strong></p>
<h2>24年大事记</h2>
<ul>
<li><strong>1月</strong>：我使用Hexo框架成功搭建了我的第一个博客，但那个时候并没有得到我的重视，不过能 用到Hexo已经是一个很大的跨越了，相比WordPress，我还是选择了样式更加丰富的Hexo。</li>
<li><strong>6月</strong>：我迎来了人生中的第一次高考，尽管结果并不是很理想，但这代表不了什么，也不会就此抹杀掉我曾经奋斗过的痕迹。新的征程我会继续</li>
<li><strong>7月</strong>：我如愿以偿地拿到了我的第一部新手机，这对于一个用了5年"OPPO A5"的人来说，是何等好事啊😅，这个月，我还申请了一个顶级域名：almango.cn，这个时候我开始魔改Butterfly主题，该博客命运的齿轮也由此开始转动。</li>
<li><strong>8月</strong>：第一次和同学去电影院看动漫《你的名字》，这也是我第一次去电影院。宅男就是这样的，外面世界虽比网络精彩，就算有机会，也懒得抓住。</li>
<li><strong>9月</strong>：我拿到了哥哥给我买的高性能游戏本，哈哈，如果没有它，我甚至不知道我大学过的有多难受。这个月我开始了我新的征程：上大学啦！在这里我认识了许多同学，接触了许多新的事物，这是一个新的生活。</li>
<li><strong>10月</strong>：军训有时候会迟到，但从不缺席，这个月学院举行了长达21天的军训。虽然很多时候我有想过旷训，但终究还是挺过去了，只能说长时间的训练才是最致命的。（高中由于疫情，我为逃过一劫而沾沾自喜）</li>
<li><strong>11月</strong>：为了心底的对音乐的热爱，我买了一把吉他，想象着能和网上的大佬一样炫酷。不过现实还是很现实的，自学的难度甚至有时候会让我放弃，好在几个玩吉他室友，以及打心底的热爱，我还是坚持了下来，至少现在每天都会练习。</li>
<li><strong>12月</strong>：这个月似乎没有什么可说的，唯一能让我说的出嘴都可能是31号晚上的元旦晚会吧......真的是丢人现眼哈哈哈😅😅😅</li>
</ul>
<h2>所见所闻</h2>
<p>1 . 原本这个暑假是要去南昌打暑假工的，但没有找到合适的厂，就顺便去了一次万寿宫玩。虽然我不太喜欢古风，但这里的美食是真的好吃，哈哈😁😁
<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/photos/life_wanshougong_1.jpg" alt="" />
<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/photos/life_wanshougong_2.jpg" alt="" />
2 . 8月份，我和爸妈去南昌八一广场看了升国旗，为了耽误时间，我们凌晨就出发了，遗憾的是人实在是太多了，我们只能站在最外边看，其实这次我并不是很想出来，但呦不过爸妈，不过，这对于我来说算是一个人生体验吧。（其实后面我才意识过来，难得有这样的机会，应该多和父母出去玩玩，长大后怕就没有这种体验了）
<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/photos/life_81_1.jpg" alt="" />
<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/photos/life_81_2.jpg" alt="" /></p>
<p>3 . 开学期间，随便去了一趟仙女湖，怎么说呢，那里没有我想象中的那么浪漫，人不多。也可能是没有什么活动吧，总而言之就是十分到冷清，自然。
<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/photos/life_xiannvu_2.jpg" alt="" /></p>
<h2>所作所为</h2>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/photos/2024life.png" alt="" /></p>
<p>1 . 对于学习方面，2024年，我从Python转入了C++的学习，在此过程中我感到无比的轻松，从指针到链表我才停止了下来。嗯，虽然大一也学C语言，但是目前老师所讲的都是很早就学过的，除了一些细节和技巧以外，我没有怎么去听过课，真的不如自己去自学。我不知道为什么软件技术还要学Office，我是十分反感的，但话又说回来，我的office技术是真的不行，而大部分技能都是在帮助朋友的过程中学到的。
很遗憾的是，我现在没有再写过什么代码了，可以看到，我的博客的最近更新时间也是在11月份，动力寥寥无几了......</p>
<p>2 . 如果说我目前最热爱的是是什么，那只能说是弹吉他🎸了，明天晚上我都会费尽心思的去找一些好听又好练习的曲子，可我现在还刚学一个月呀，尽管再困难我也要坚持下去。在此过程中，我发现，如果初学者想坚持练习，最重要的是学会一首曲子，这样你才有成就感，才能有动力的学下去，这是对业余者而言的。希望新的一年，我的电吉他技术能突飞猛进哈哈。😘😘</p>
<p>3 . 最近游戏玩的有点多了，希望能抽点空去做点更有意义的事情.....</p>
<h3>游戏</h3>
<p>1 . 今年我接触到了一款很新颖的游戏：《米塔Miside》，这是我目前玩过的最棒的一款单机游戏了，接下来说一下我的游戏感受吧。
2 .其实最早我是在抖音刷到的，已经刷到过好多次了，就是那种剪辑视频，动人的BGM加上病娇女主的游戏画面，让人忍不住多看几眼。评论区很多人说这是一款恐怖游戏，这种反差让我产生了强烈的好奇，这么粉嫩的画风，“怎么可能是恐怖游戏啊！”，所以经不住好奇的我最终48￥入库了。
3 . 我花了差不多3个小时一口气通关了所有剧情。我就直接讲一下剧情吧，当然这是我的理解：</p>
<h2>结余</h2>
<blockquote>
<p>我没有选择真正意义上的跨年，因为我太困了，凌晨两点醒，一觉醒来的落差感，就感觉自己被世界抛弃在某个角落......</p>
</blockquote>
<p>1 .<strong>All in all</strong>在这新的一年，望自己在事业上有所成就，学习上突飞猛进，热爱更上一层楼。"向着更加光明的未来砥砺前行"
2 . "无论晴空万里还是雨雪霏霏，愿被岁月温柔以待。时光能缓，故人不散。2024再见，2025你好"。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/photos/2025.webp" alt="" /></p>
<blockquote>
<p>年度总结就到这里吧，。写的有点多了，明年记得来看我的年度总结哈😁😁</p>
</blockquote>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="年度总结"></category>
  </entry>
  <entry>
    <title>我的世界Java版本搭建本地服务器：实现开服与联机自由</title>
    <link href="https://mizuki.mysqil.com/posts/minecraft%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8_%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E8%81%94%E6%9C%BA%E8%87%AA%E7%94%B1/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/minecraft%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8_%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E8%81%94%E6%9C%BA%E8%87%AA%E7%94%B1/</id>
    <published>2024-11-15T14:34:01.000Z</published>
    <updated>2024-11-15T14:34:01.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p>最近因为某些原因，我和兄弟临时转MC玩了，开始是考虑了一下冈易我的世界，但想到冈易那代理mc环境跟一坨一样，甚至高质量的光影全要钱，干脆不如玩纯净版的MC，于是就想着自己搭建一个本地服务器。虽然第一次有点麻烦，但我还是将全过程记录了下来。</p>
</blockquote>
<p>本期介绍的是Java版我的世界本地服务器和实现多人联机的实现过程：<code>仅供参考</code></p>
<h2>前提条件</h2>
<blockquote>
<ul>
<li>Java 11或以上版本1</li>
<li>Minecraft Edition 任意版本</li>
</ul>
</blockquote>
<h2>部署Server核心</h2>
<blockquote>
<p>服务器核心文件是一个JAR文件，内部的文件按下列结构组织，是用于运行服务器的软件。在这个软件中，有几个核心要素是关键的，它们共同构成了服务器的基础架构。以下是我的世界服务器核心的主要组成部分</p>
</blockquote>
<p>常用的Minecraft服务器核心有以下几种：</p>
<ul>
<li><strong>Bukkit</strong></li>
<li><strong>Paper</strong></li>
<li><strong>Velocity</strong></li>
<li><strong>Spigot</strong></li>
</ul>
<p>这里我就以<code>Spigot</code>为例，搭建一个本地服务器。</p>
<blockquote>
<p>注意：Spigot版本不能低于Minecraft游戏版本。</p>
</blockquote>
<p>1 . 首先下载Server核心：Getbukkit官网网站：https://getbukkit.org/download/spigot/</p>
<ul>
<li>备用地址1：<a href="https://www.fastmirror.net/#/home">https://www.fastmirror.net/#/home</a></li>
<li>备用地址2：<a href="https://sync.mcsl.com.cn/">https://sync.mcsl.com.cn/</a></li>
</ul>
<p>2 . 创建一个目录用于存放服务器文件，并将下载好的<code>核心文件.jar</code>放进去（目录名称不能存在中文或特殊字符）</p>
<p>3 . 在该目录新建一个文本文档，并进行编辑：</p>
<pre><code>@echo off
java -Xmx2g -Xms1g -jar Spigot-1.20.4-4074.jar
pause
</code></pre>
<blockquote>
<p>Spigot-1.20.4-4074.jar：服务器核心文件名称
Xmx2g：申请本地的最大~最小内存为2G（可自定义<code>&gt;= 1G</code>）</p>
</blockquote>
<p>4 . 保存后，将其名称及后缀名改为<code>Launch.bat</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_mcserver_1.png" alt="" /></p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_mcserver_3.png" alt="" /></p>
<p>5 .双击运行<code>Launch.bat</code>
6 . 这个时候，会弹出终端并初始化服务器所需的配置文件。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_mcserver_2.png" alt="" /></p>
<p>7 . 当提示“<code>请按任意键继续...</code>”时，退出终端。
8 . 这个时候目录就已经生成了一个名为<code>eula.text</code>的文本文档。我们将其打开，并将代码<code>eula</code>的值改为<code>true</code>。
9 . 重新打开<code>Launch.bat</code>，等待加载。
10 . 当出现如下图所示，则说明服务器核心已配置完成，可以正常使用。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_mcserver_4.png" alt="" /></p>
<h2>加入服务器</h2>
<p>1 . 我们打开游戏，点击多人游戏，并添加服务器地址：<code>127.0.0.1:25565</code>，这个时候可以看到添加后的服务器状态是正常的，随即进入服务器。
2 . 这里有两个点要注意：</p>
<blockquote>
<ul>
<li>如果你是盗版用户，默认是无法加入游戏的，进去时会弹出：<code>验证用户名失败！</code>，需要将服务器配置文件<code>server.properties</code>中的代码<code>online-mode</code>值设置为<code>false</code></li>
<li>服务器IP默认端口是<code>25565</code></li>
<li>服务器核心会默认选择你的最新存档作为地图。</li>
</ul>
</blockquote>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_mcserver_5.png" alt="" /></p>
<h2>互联网多人联机</h2>
<blockquote>
<p>此时的状态，只有局域网内才能联机，广域网的玩家是无法看到的。这个时候我们可以用到<code>内网穿透</code>来实现互联网范围的多人联机。</p>
</blockquote>
<p>1 . 注册一个樱花内网穿透账号：<a href="https://www.natfrp.com/?page=panel&amp;module=download">SAKURA FRP</a>
2 . 登录官网，随机在官网打开控制面板，点击导航栏的用户页面中的<code>重设用户密钥</code>，并将新的密钥复制下来。
3 . 下载并安装樱花内网穿透软件：<a href="https://www.natfrp.com/tunnel/download">前往官网下载</a></p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_mcserver_6.png" alt="" /></p>
<p>4 . 启动<code>SakuraFrp启动器</code>，并在设置中登录自己的密钥。
5 . 点击侧边栏的隧道。并创建一个新的隧道。
6 . 在创建面板中：</p>
<ul>
<li>节点你可以选择一个离你比较近的<code>节点</code></li>
<li>隧道类型选择：<code>TCP隧道</code>，</li>
<li>随后输入隧道名（可自定义）</li>
<li>主机IP为：<code>127.0.0.1</code>，</li>
<li>端口为MC服务器的端口<code>25565</code>，</li>
</ul>
<p>7 . 其他的可以默认不填，随即创建隧道。
8 . 随后你就可以在隧道面板中启动隧道了，启动后打开日志，下图所示的链接就是服务器的IP地址了。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_mcserver_7.png" alt="" /></p>
<p>9 . 下次启动服务器就一直会用到这串地址，广域网的玩家也可以通过这个IP来找到你的服务器并一起游戏。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_mcserver_8.png" alt="" /></p>
<h2>自定义服务器配置文件</h2>
<blockquote>
<p>在服务器核心目录，我们可以找到名为：<code>server.properties</code>的文件，这个就是服务器的配置文件，我们可以通过修改其参数来调整服务器，例如：游戏模式，最大玩家数，游戏难度，服务器IP和端口等...</p>
</blockquote>
<p>1 . <code>online-mode</code>：正版用户验证（建议关闭）</p>
<p>2 . <code>server-port</code>：服务器端口（不建议修改）</p>
<p>3 . <code>max-players</code>：最大玩家数</p>
<p>4 . <code>enable-command-block</code>：是否启用命令方块</p>
<p>5 . <code>motd</code>：服务器描述</p>
<p>Server.properties各参数详解可参考：<a href="https://zh.minecraft.wiki/w/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F?variant=zh">Minecraft Wiki</a> 或者 <a href="https://spigotmc-cn.netlify.app/">Spigot中文开发指南</a></p>
<blockquote>
<p>必须保证在服务器关闭的前提下修改配置参数，重新启动后才会生效。</p>
</blockquote>
<h2>使用命令</h2>
<p>1 . 我们可以直接通过服务器核心来使用指令。
2 . 例如</p>
<pre><code># 赋予玩家管理员权限
op [玩家名]
# 踢出玩家
kick [玩家名]
# 死亡不掉落
gamerule keepinventory true
</code></pre>
<p>3 . 你也可以通过<code>help</code>来查看指令集
4 . 当然，如果你是服主，可以给自己赋予管理员权限，这样你就可以在游戏内使用指令了。</p>
<blockquote>
<p>至于如何添加mod和地图，这个后续会再次补充...</p>
</blockquote>
<blockquote>
<p>到这里服务器就已经配置完成啦，快去和小伙伴们一起冒险吧！</p>
</blockquote>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="Minecraft"></category>
  </entry>
  <entry>
    <title>Unity2D开发记录_游戏场景搭建【1】</title>
    <link href="https://mizuki.mysqil.com/posts/unity2d%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95_%E6%B8%B8%E6%88%8F%E5%9C%BA%E6%99%AF%E6%90%AD%E5%BB%BA1/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/unity2d%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95_%E6%B8%B8%E6%88%8F%E5%9C%BA%E6%99%AF%E6%90%AD%E5%BB%BA1/</id>
    <published>2024-11-09T12:49:34.000Z</published>
    <updated>2024-11-09T12:49:34.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p>时隔一年，我又重新回到了Unity2D，但这次我是带着一个新的希望来的。
在此之前我做好了充足的准备：在这里，我不会再和之前一样优哉游哉，而是把所有走过的路全都记录下来，Unity这东西，不记不用很容易生疏，当然了，更多细节这里会一笔带过，重要的会明提。</p>
</blockquote>
<blockquote>
<p>关于搭建Unity啥的就不用说了，这里直接从搭建场景开始吧......</p>
</blockquote>
<h2>创建场景</h2>
<blockquote>
<p>完成场景搭建主要经过以下几个步骤：</p>
</blockquote>
<ul>
<li>下载与导入地形素材</li>
<li>创建<code>Tilemap</code></li>
<li>配置<code>Tile Palette</code></li>
<li>编辑场景</li>
</ul>
<h3>下载场景素材</h3>
<blockquote>
<p>可前往Unity官方商店Assets Store下载一些免费的素材</p>
</blockquote>
<p>直达链接：<a href="https://assetstore.unity.com/zh-CN?category=2d&amp;free=true&amp;orderBy=1">https://assetstore.unity.com/zh-CN?category=2d&amp;free=true&amp;orderBy=1</a></p>
<p>1 . 找到喜欢的素材后，可以直接添加到Unity编辑器。
2 . 然后在 Window &gt; Asset store 找到并点击<code>download</code>来安装素材
3 . 最后点击<code>import</code>导入素材即可</p>
<h3>创建Tilemap</h3>
<blockquote>
<p>Tilemap主要起到为编辑场景的辅助作用，它会在场景面板中显示网格，以帮助我们在对应的网格编辑场景。</p>
</blockquote>
<p>1 . 右键Hierarchy（层级窗口）窗口，点击2D object &gt; Tilmap &gt; Rectangual，之后层级窗口就会新增一个Grid对象，这就说明Tilmap创建成功了，可以看到，Scene中出现了网格</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_unity1_1.png" alt="" /></p>
<h3>配置Tile Palette。</h3>
<p>1 . 现在我们需要去配置Tile Palette。
2 . 点击 菜单栏的 Window &gt; 2D &gt; Tile Palette。
3 . 此时的Tile Palette可能是空的，我们需要创建一个新的Palette，点击<code>Creat New Palette</code>，可以新建一个文件夹打开。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_unity1_%202.png" alt="" /></p>
<p>4 . 随后，我们需要找到我们所导入的素材文件（一般位于<code>Texture</code>目录中），在关闭Tilp Palette编辑模式的前提下，直接<code>将素材文件拖入到Palette</code>中，再点击右上角的网格图标，这样就能显示网格了。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_unity1_%203.png" alt="" /></p>
<h3>编辑场景</h3>
<p>1 . 现在我们就可以编辑场景了。
2 . 我们点击Tile Palette的<code>画笔工具</code>，选择要用的场景像素，随后在Scene场景中<code>点画编辑</code>即可。</p>
<blockquote>
<p>当然，我们1也可以在Tile Palette中使用其他工具，例如橡皮工具，区域块工具，选择工具等等……</p>
</blockquote>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_unity1_%204.png" alt="" /></p>
<p><strong>编辑完成后，保存即可，而这个地形场景位于Gird &gt; Tilemap中。</strong></p>
<h2>问题解疑</h2>
<blockquote>
<p>在上述过程中也难免会遇到一些问题，这里是我在应用时所遇到的问题。</p>
</blockquote>
<h3>素材像素与Tilemap网格大小不匹配</h3>
<p>1 . 出现这种问题只需要点击素材文件，在右边弹出的<code>Inspector</code>(检查器窗口)中，修改<code>Pixels Per Uint</code>的数值即可，这个数值需要和素材本身的像素大小一样，也就是说，这个素材是16像素，那么这个值也得是16像素。</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Electron桌面应用开发_环境搭建与应用打包</title>
    <link href="https://mizuki.mysqil.com/posts/electron%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91_%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%89%93%E5%8C%85/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/electron%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91_%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%89%93%E5%8C%85/</id>
    <published>2024-10-20T09:36:01.000Z</published>
    <updated>2024-10-20T09:36:01.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p><strong>这是我写的一篇关于Electron的文章</strong>，这也代表着我已经开始学习桌面应用开发了。很难Electron居然是通过Html，css，js这三件套来开发应用的，想到我已经近三年没有写过web了（除了Hexo和css），没想到居然能在这应用上我最擅长的……😁😁，太幸运了。
当时我学习C++的时候，一部分原因就是因为QT（我想开发桌面应用），但Electron的出现让我有了转机，我可以通过web快速的构建一个理想美观的应用程序，我一开始以为需要vue或者react，后来才知道，这两个只是Electron所支持的两个框架而已……关于这两个框架我以后再说吧……</p>
</blockquote>
<blockquote>
<p><strong>Electron</strong>是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入 Chromium 和 Node.js 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux——不需要本地开发 经验。</p>
</blockquote>
<h2>创建项目</h2>
<p>1 . 创建项目之前，需要先新建一个项目目录（目录名称为软件的标题名）</p>
<h3>初始化配置文</h3>
<p>1 . 打开项目目录，在该目录中打开终端，输入：<code>npm init -y</code>。
2 . 之后该目录内就会生成一个名为<code>package.json</code>配置文件，它用于<code>描述项目的元数据信息和依赖项</code>
3 . 将<code>package.json</code>中的<code>test</code>改为：</p>
<pre><code>"scripts": {
    "start": "electron ."
  },
</code></pre>
<p>3 . 继续新建一个名称为：<code>.npmrc</code>的文件，输入以下代码：</p>
<pre><code>registry=https://registry.npmmirror.com/
electron mirror=https://npmmirror.com/mirrors/electron/
electron_builder_binaries_mirror=https://registry.npmmirror.com/-/binary/electron-builder-binaries/
</code></pre>
<h3>部署Electron</h3>
<p>1 . 在项目根目录的终端输入：<code>npm i electron -d</code>
2 . 新建一个文件：<code>index.js</code>，并在该文件中输入以下代码：</p>
<pre><code>const { app, BrowserWindow } = require('electron')

const createWindow = () =&gt; {
  const win = new BrowserWindow({
    width: 800,  // 窗体宽度
    height: 600,  // 窗体长度
    //autoHideMenuBar: true, // 自动隐藏菜单栏
  })

  win.loadFile('index.html')
}

app.whenReady().then(() =&gt; {
  createWindow()
})

//创建托盘
//  const createTray = () =&gt; {
//     const icon = path.resolve(__dirname,"img/icon.ico") //托盘图标
//   }
</code></pre>
<h3>运行项目</h3>
<p>1 . 在终端输入：<code>npm start</code>即可。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_electron1_1.png" alt="" /></p>
<h2>打包（两种方式）</h2>
<h3>构建安装包（1）</h3>
<blockquote>
<p>该打包方式会生成安装包，运行安装包会有安装向导，可以在package中自定义安装行为，软件安装后，它会自动在桌面生成一个快捷键，当你想删除的时候，可以通过第三方卸载软件删除，也可以在根目录的<code>Uninstall.exe</code>程序卸载。这还是十分方便的，就和我们安装QQ，微信，vscode等软件一样。</p>
</blockquote>
<p>1 . 在<code>package.json</code>中的<code>script</code>下面插入代码：</p>
<pre><code>"build": {
  "productName": "QQ",   // 项目名称
  "appId": "app.almango.cn",  // 软件标识（自定义）
  "win": {
    "icon": "/img/icon.ico",  // 软件图标
    "target": [
      {
        "target": "nsis",  // 安装行为
        "arch": [
          "x64"   // 架构支持
        ]
      }
    ]
  },
  "nsis": {
    "oneClick": false, // 是否一键安装（true）还是辅助安装（false）。
    "perMachine": true,  // 是否为user安装（true）,还是全局安装（false）
    "allowToChangeInstallationDirectory": true  是否可以自定义安装目录（只对为user安装有效）
  }
},
</code></pre>
<p>2 . 对于nsis各参数的作用可以参考文章：<a href="https://juejin.cn/post/7004398823082557476">「稀土掘金」electron-builder打包，NSIS脚本的一些使用</a>
3 . 最后在终端运行代码：<code>npm run build</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_electron1_2.png" alt="" /></p>
<p>4 . 可以看到，安装完成后，桌面生成了一个软件快捷键，点击后可以正常运行，和其他软件的启动方式是一致的。我个人还是比较喜欢用这种方法打包应用程序。</p>
<h3>免安装打包（2）</h3>
<blockquote>
<p>这种方法就更加直接了，它不需要安装软件，打包后就是一个文件应用程序需要自己去文件夹中打开，不会和上面的方式一样创建快捷键，不仅如此，当你想卸载的时候，卸载软件也无法索引到，需要自己将整个目录删除才行。这种方法一般后期都会被封装为压缩包……</p>
</blockquote>
<p>1 . 打包很简单，只需要在终端输入一串命令：<code>npm run pack</code>
2 . 个人不太推荐，除非是用于测试软件，不然挺繁琐的。</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C++数据结构_单链表的删替插装功能实现2【7】</title>
    <link href="https://mizuki.mysqil.com/posts/cpp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E6%9B%BF%E6%8F%92%E8%A3%85%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B02/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/cpp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E6%9B%BF%E6%8F%92%E8%A3%85%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B02/</id>
    <published>2024-10-12T11:26:02.000Z</published>
    <updated>2024-10-12T11:26:02.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h1>链表的基本功能</h1>
<blockquote>
<p>水激石则鸣，人激志则宏。——秋瑾</p>
</blockquote>
<p>1 . 基于上次写的学生管理链表，我做了一定的修改，把结构体的名称和数据域的名称修改了所以会和上次的不一样。
2 . 这次我们来继续完善链表中欠缺的功能，比如：<code>替换</code>，<code>插入</code>，<code>删除</code>，<code>封装</code>等……
3 .若搞不清代码，可参考上期的博客：<a href="https://www.almango.cn/2024/10/05/Cpp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%89%96%E6%9E%90%E5%BA%94%E7%94%A8/">C++数据结构_单链表的实例剖析与应用1【6】</a></p>
<h2>替换函数</h2>
<h3>分析</h3>
<p>1 . 替换功能还是比较简单的。</p>
<blockquote>
<p>2 .开始我是想到了两种方法，一种是将整个节点替换成新的，一种是将节点的中的数据域换成新的。但目前只实践了第二种方法，个人觉得还是很直白易懂的，第一种方法也可以用，但需要先使用delete删除实例化的节点，在重新赋值，</p>
</blockquote>
<p>3 . 这里说一下整个实践过程：首先是找到这个要替换的节点，可以以数据域中的某一个数据为参照物，使用while循环来查找匹配，当匹配到了，就直接给该节点的数据域赋一个新值，还有一种情况，就是当头节点就是要被替换的节点，这种就直接使用if判断一下，是则直接替换头节点的数据域。
4 . 下面的图片应该会更加直白，这就相当于直接换了一个节点的数据域嘛。</p>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_cpp7_1.png" alt="" /></p>
<h3>代码实现与解析</h3>
<p>1 . 多说无益，直接上代码。</p>
<p>2 . 创建一个函数<code>ReplaceLinkNode()</code>，<code>oidName</code>为要被替换节点的参照物，<code>newAge</code>和<code>newName</code>为要替换的新值。
3 . 使用<code>if判断一下头节点是不是要替换的节点</code>。如果是，则直接<code>直接将指针指向头节点的数据域</code>，并赋予新的值替换掉，如果不是，则<code>从头节点开始循环</code>查找，直到找到为止并替换。
4 . 这里存在一个<code>新的可能性</code>：就是当链表不存在要找的节点参照物。这种情况都是在循环到达最后一个节点的时候发生的，我们只需要写个判断if(FindOut-&gt;Pointer_Next == nullptr)，意思是访问最后一个节点的指针域是否为nullptr，是则输出“不存在目标”。</p>
<p>5 . 由于while的条件是<code>FindOut-&gt;Person_Name != oidName</code>，当循环结束只会有两种结果，一种是已经匹配到目标，一种是找不到目标，所以可以直接在while外面给当前的指针空间赋值。</p>
<pre><code>void ReplaceLinkNode(string oidName, int newAge, string newName)
{
    // LinkNodeBaseStruct * NewLinkNode = CreatLinkNode(newAge,newName);
    if (HeadNode-&gt;Person_Name == oidName)
    {
        // LinkNodeBaseStruct *TempPointer = HeadNode -&gt; Pointer_Next;
        HeadNode-&gt;Person_Age = newAge;
        HeadNode-&gt;Person_Name = newName;
        //	HeadNode -&gt; Pointer_Next = TempPointer;
    }
    else
    {
        LinkNodeBaseStruct *FindOut = HeadNode;
        while (FindOut-&gt;Person_Name != oidName &amp;&amp; FindOut != nullptr)
        {
            FindOut = FindOut-&gt;Pointer_Next;
            if (FindOut-&gt;Pointer_Next == nullptr)
            {
                cout &lt;&lt; "Error: Not Found 没有找到要替换的目标" &lt;&lt; endl;
                break;
            }
        }
        FindOut-&gt;Person_Age = newAge;
        FindOut-&gt;Person_Name = newName;
    }
}
</code></pre>
<p>5 . 以上是替换节点的操作，也不能完全说是替换节点吧，只是把数据域替换了。</p>
<h2>插入函数</h2>
<h3>分析</h3>
<p>1 . 这里我会实现一个往指定链表节点后面插入新的节点的功能（方法）
2 . 注意了，是往指定节点的<code>后面</code>插入新节点。
3 . 实现方法也很简单：只要通过While循环来查找指定节点，再插入新的节点，把指定节点的指针域赋值给新节点即可，这样就完美衔接了整个链表。</p>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_cpp7_2.png" alt="" /></p>
<h3>代码实现与解析</h3>
<p>1 . 代码十分简短。
2 . 首先我们需要设置好形参，<code>target</code>为要指定参照节点，<code>Person_Age</code>和<code>Person_Name</code>为要插入的节点数据域内容。
3 . 调用<code>CreatNode方法</code>来创建一个节点。
4 . 设置循环，直到找到指定的参照节点才停下来，当循环结束后也就说明找到了参照节点，当然了，如果不存在指定参照节点，则会通过判断来终止循环。
5 . 此时的指针<code>已经指向了参照节点</code>，这时我们需要先将该参照节点的指针域保存到一个临时变量中，再将该参照节点的指针域修改指向新的链表，最后把临时变量赋值给新节点的指针域，这样就完美衔接了整个链表。</p>
<pre><code>void InsertLinkNode(string target, int Person_Age, string Person_Name)
{
	LinkNodeBaseStruct *NewLinkNode = CreatNode(Person_Age, Person_Name);
	LinkNodeBaseStruct *FindOut = HeadNode;
	while (FindOut-&gt;Person_Name != target)
	{
		FindOut = FindOut-&gt;Pointer_Next;
		if (FindOut-&gt;Pointer_Next == nullptr &amp;&amp; FindOut-&gt;Person_Name != target)
		{
			cout &lt;&lt; "Error: Not Found 没有找到要操作的目标参照物" &lt;&lt; endl;
			break;
		}
	}
	LinkNodeBaseStruct *tempnode = FindOut-&gt;Pointer_Next;
	NewLinkNode-&gt;Pointer_Next = tempnode;
	FindOut-&gt;Pointer_Next = NewLinkNode;
}
</code></pre>
<p>6 . 这样，便实现了一个插入节点的功能，当然也可以以此类推实现一个在某个节点的<code>前面插入节点</code>的功能。</p>
<h2>删除指定节点函数</h2>
<blockquote>
<p>这里讲的是<code>删除指定的节点</code>。</p>
</blockquote>
<h3>分析</h3>
<p>1 . 删除节点的原理很简单，但对于我来说，操作起来会有点麻烦。
2 . 实现原理是通过循环来查找要删除的节点，将要删除的上一个节点的指针域重新赋值为要删除节点的下一个节点，也就是说将该节点的两端切断，最后删除。另外，删除指定节点需要注意一种情况，就是当头节点为要删除的节点，这个时候需要将头节点重新赋值为头节点的指针域，相当于头节点被第二个节点覆盖了，第二个节点成为了头节点。</p>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_cpp7_3.png" alt="" /></p>
<h3>代码实现与解析</h3>
<p>1 . 代码的实现这里我就不过多分析了，该说的，上面基本上已经提到了。
2 . 说实话，这代码是我无意中摸索出来的，这指针已经把我头都搞大了。</p>
<pre><code>void DeleteLinkNode(string target_name)
{
	LinkNodeBaseStruct *Pointer = HeadNode;
	if (Pointer != nullptr &amp;&amp; Pointer-&gt;Person_Name == target_name)
	{
		HeadNode = Pointer-&gt;Pointer_Next;
        delete Pointer;
	}
	else
	{
		while (Pointer-&gt;Pointer_Next-&gt;Person_Name != target_name)
		{
			Pointer = Pointer-&gt;Pointer_Next;
		}
		LinkNodeBaseStruct *temp = Pointer-&gt;Pointer_Next-&gt;Pointer_Next;
		delete Pointer-&gt;Pointer_Next;
		Pointer-&gt;Pointer_Next = temp;
	}
}
</code></pre>
<h2>封装链表</h2>
<h3>分析</h3>
<p>1 . 当我们想使用链表来实现某一个功能的时候，只需要直接通过调用几个基本功能即可，例如：添加节点<code>AppendLinkNode("张三", 16)</code>。但是，如果我们要使用链表去实现多种事件的时候，例如：将<code>一班的学生信息和二班的学生信息分开</code>存储，当前的链表肯定是不支持一表多用的。
2 . 这个时候就需要使用<code>class类来封装</code>起来，之后当我们就可以<code>创建多个链表对象</code>，每个链表对象都可以分门别类的存储不同的数据。
3 . 这里可以在class中分别用private来封装结构体,头节点，创建节点函数。public来封装各个功能函数。
4 . 这样，我们就可以通过创建对象来分开使用链表空间。</p>
<h3>代码实现</h3>
<blockquote>
<p>下面是整个单链表及其已实现的基本功能</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;

using namespace std;
// using namespace LinkNode;

class LinkNode
{
private:
	struct LinkNodeBaseStruct
	{
		int Person_Age;
		string Person_Name;
		LinkNodeBaseStruct *Pointer_Next;
	};

	LinkNodeBaseStruct *HeadNode = NULL;

	LinkNodeBaseStruct *CreatNode(int age, string name) // 仅创建一个链表节点，但不插入到链表中
	{
		LinkNodeBaseStruct *p1 = new LinkNodeBaseStruct;
		p1-&gt;Person_Age = age;
		p1-&gt;Person_Name = name;
		p1-&gt;Pointer_Next = nullptr;
		// cout &lt;&lt; p1 -&gt; Person_Age &lt;&lt; p1 -&gt; Person_Name &lt;&lt; endl;
		return p1;
	}

public:
	void AppendNodeToLinkNode(int Person_Age, string Person_Name)
	{
		LinkNodeBaseStruct *NewLinkNode = CreatNode(Person_Age, Person_Name);
		if (HeadNode == NULL)
		{
			HeadNode = NewLinkNode;
		}
		else
		{
			LinkNodeBaseStruct *PointerToNext = HeadNode;
			while (PointerToNext-&gt;Pointer_Next != nullptr)
			{
				PointerToNext = PointerToNext-&gt;Pointer_Next;
			}
			PointerToNext-&gt;Pointer_Next = NewLinkNode; // 将新节点连接到链表的尾部
		}
		// cout &lt;&lt; HeadNode -&gt; Person_Age &lt;&lt; endl;
	}
	void ReplaceLinkNode(string oidName, int newAge, string newName)
	{
		// LinkNodeBaseStruct * NewLinkNode = CreatLinkNode(newAge,newName);
		if (HeadNode-&gt;Person_Name == oidName)
		{
			// LinkNodeBaseStruct *TempPointer = HeadNode -&gt; Pointer_Next;
			HeadNode-&gt;Person_Age = newAge;
			HeadNode-&gt;Person_Name = newName;
			//	HeadNode -&gt; Pointer_Next = TempPointer;
		}
		else
		{
			LinkNodeBaseStruct *FindOut = HeadNode;
			while (FindOut-&gt;Person_Name != oidName &amp;&amp; FindOut != nullptr)
			{
				FindOut = FindOut-&gt;Pointer_Next;
				if (FindOut-&gt;Pointer_Next == nullptr)
				{
					cout &lt;&lt; "Error: Not Found 没有找到要替换的目标" &lt;&lt; endl;
					break;
				}
			}
			FindOut-&gt;Person_Age = newAge;
			FindOut-&gt;Person_Name = newName;
		}
	}
	void InsertLinkNode(string target, int Person_Age, string Person_Name)
	{
		LinkNodeBaseStruct *NewLinkNode = CreatNode(Person_Age, Person_Name);
		LinkNodeBaseStruct *FindOut = HeadNode;
		while (FindOut-&gt;Person_Name != target)
		{
			FindOut = FindOut-&gt;Pointer_Next;
			if (FindOut-&gt;Pointer_Next == nullptr &amp;&amp; FindOut-&gt;Person_Name != target)
			{
				cout &lt;&lt; "Error: Not Found 没有找到要操作的目标参照物" &lt;&lt; endl;
				break;
			}
		}
		LinkNodeBaseStruct *tempnode = FindOut-&gt;Pointer_Next;
		NewLinkNode-&gt;Pointer_Next = tempnode;
		FindOut-&gt;Pointer_Next = NewLinkNode;
	}
	void DeleteLinkNode(string target_name)
	{
		LinkNodeBaseStruct *Pointer = HeadNode;
		if (Pointer != nullptr &amp;&amp; Pointer-&gt;Person_Name == target_name)
		{
			HeadNode = Pointer-&gt;Pointer_Next;
			delete Pointer;
		}
		else
		{
			while (Pointer-&gt;Pointer_Next-&gt;Person_Name != target_name)
			{
				Pointer = Pointer -&gt; Pointer_Next;
			}
			LinkNodeBaseStruct *temp = Pointer-&gt;Pointer_Next -&gt; Pointer_Next;
			delete Pointer-&gt;Pointer_Next;
			Pointer -&gt; Pointer_Next = temp;
		}
	}
	void PrintLinkNode()
	{
		LinkNodeBaseStruct *Start = HeadNode;
		while (Start != nullptr)
		{
			cout &lt;&lt; Start-&gt;Person_Name &lt;&lt; "，" &lt;&lt; Start-&gt;Person_Age &lt;&lt; "岁" &lt;&lt; endl;
			Start = Start-&gt;Pointer_Next;
		}
	}
};
int main()
{
	LinkNode L;
	L.AppendNodeToLinkNode(28, "张三");  // 追加
	L.AppendNodeToLinkNode(15, "李四");  // 追加
	L.AppendNodeToLinkNode(18, "王五");  // 追加
	L.AppendNodeToLinkNode(21, "赵六");  // 追加
	L.DeleteLinkNode("王五");   // 删除

	L.PrintLinkNode();
}
</code></pre>
<p><strong>运行结果</strong>：</p>
<pre><code>张三，28岁
马牛逼，10岁
赵六，21岁
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C++数据结构_单链表的实例剖析与应用1【6】</title>
    <link href="https://mizuki.mysqil.com/posts/cpp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%89%96%E6%9E%90%E5%BA%94%E7%94%A8/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/cpp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%89%96%E6%9E%90%E5%BA%94%E7%94%A8/</id>
    <published>2024-10-05T12:45:21.000Z</published>
    <updated>2024-10-05T12:45:21.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h1>单链表</h1>
<blockquote>
<p>👍要想写单链表，首先得搞明白链表的概念</p>
</blockquote>
<p><strong>链表</strong>：是一种物理存储单元上<code>非连续</code>、<code>非顺序</code>的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的<code>数据域</code>，另一个是存储下一个结点地址的<code>指针域</code>。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
<p><strong>链表节点</strong>：链表节点是链表的单元，分为<code>头节点</code>和<code>子节点</code>，头节点是链表的第一个节点，子节点是在头节点其后的节点。</p>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/photos/post_cpp6_1.png" alt="" /></p>
<blockquote>
<p>上面是简易的结构图，虽然丑了些……将就看吧。</p>
</blockquote>
<h2>手搓一个<code>单链表</code></h2>
<h3>定义结构体</h3>
<p>1 . 先定义一个结构体作为链表的结构
2 . 一个链表的节点被分为两个区域，一个是<code>数据域</code>（存放数据），一个是<code>指针域</code>（用于指向下一个链表节点）
3 . 这里我们在数据域声明两个变量，用于储存学生的名称和年龄。随后是指针域，因为这个指针属于这个结构体，所以指针的类型就是这个结构体。</p>
<pre><code>struct StudentLinkNode
{
    int student_age;
    string Student_name;
    StudentLinkNode * PointerToNext;
};
</code></pre>
<h3>定义头节点</h3>
<p>1 . 此外，我们还需要在全局变量范围下定义一个头节点，这个头节点在整个链表中至关重要，它主要用于标识一个链表，在实现头插法和遍历链表都离不开头节点。</p>
<pre><code>StudentLinkNode * HeadNode = nullptr;
</code></pre>
<blockquote>
<p><strong>注意</strong>：这里为什么要在全局变量呢？主要是因为如果是在局部变量环境下，当我们想插入一个节点，那么它将只能在这个局部环境下生效。我之前就犯过这个错误：在插入节点方法内定义了传入头节点的形参，导致插入时不生效……</p>
</blockquote>
<h3>创建链表节点</h3>
<p>1 . 结构体定义好之后就可以创建节点了
2 . 我们写一个带返回值的函数用来封装，这样可以获取到创建好的节点。
3 . 在函数内实例化一个节点对象，并将指针指向student_age和Student_name来<code>接收形参传入的年龄和姓名</code>。另外，指针域PointerToNext接收一个<code>nullptr</code>值，以防止野指针导致内存泄漏。
4 . 最后就可以将这个创建好的新节点对象返回出来，后续以便更好的插入到链表中。</p>
<pre><code>StudentLinkNode * CreatNodeForStudent(int age, string name)
{
    StudentLinkNode * newnode = new StudentLinkNode;
    newnode -&gt; student_age = age;
    newnode -&gt; Student_name = name;
    newnode -&gt; PointerToNext = nullptr;
    return newnode;
}
</code></pre>
<h3>将新节点插入链表（尾插法）</h3>
<p>1 . 我们实现了链表节点的创建，现在可以将新节点插入到链表中了。（这里的尾插法虽然说是插入，但其实是追加，至于在某个节点前后插入，这个后面会学到，<code>暂时先用尾插法演示</code>）
2 . 其实这个可以照搬上面的创建节点的代码了，形参是一致的，无非是在创建新的节点对象时额外调用了CreatNodeForStudent()函数来传参，那为什么不将创建节点和插入节点合并呢？我的观点其实是为了图个简洁明了。
3 . 紧接其后，我们写一个<code>if来判断一下头节点是否为空</code>，如果为空，则<code>将新节点赋值给头节点</code>，这个不为空，则<code>实例化一个指向头节点的指针对象，再用while循环来一步一步往后查找，当一个节点的指针域为空时，则把新节点赋值给这个指针域</code>，这样不管有没有节点，我们都可以向链表插入新的节点。</p>
<pre><code>void InsertNodeForStudent(int age, string name)
{
    StudentLinkNode * newnode = CreatNodeForStudent(age, name);
    if (HeadNode == nullptr)
    {
        HeadNode = newnode;
    }
    else
    {
        StudentLinkNode * IterativeNext = HeadNode;
        while (IterativeNext -&gt; PointerToNext != nullptr)
        {
            IterativeNext = IterativeNext -&gt; PointerToNext;
        }
        IterativeNext -&gt; PointerToNext = newnode;
    }
    cout &lt;&lt; newnode -&gt; student_age &lt;&lt; endl;
}
</code></pre>
<blockquote>
<p><strong>温馨提示</strong>：当链表存在多个节点，而我们要插入新的节点，为什么非得使用循环来查查找空指针域呢？这是因为链表是非连续，非顺序的存储结构，不能像数组那样可以使用下标索引，这也就是为什么链表的搜索效率低。</p>
</blockquote>
<h3>遍历链表</h3>
<p>1 . 这一步就非常简单了。
2 . 只需要用到while循环即可。
3 . 解释一下：这个跟上面的循环很相似，先实例化一个指向头节点的指针对象。节点不为空时输出该节点的student_age和student_name。这样一来，<code>只要节点不为空就会不断迭代输出节点的内容</code>。</p>
<pre><code>void TraversalLinkNode()
{
    StudentLinkNode * TraversalNode = HeadNode;
    while (TraversalNode != nullptr)
    {
        cout &lt;&lt; TraversalNode -&gt; student_age &lt;&lt; "岁, 姓名：" &lt;&lt; TraversalNode -&gt; student_name &lt;&lt; endl;
        TraversalNode = TraversalNode -&gt; PointerToNext;
    }   
}
</code></pre>
<blockquote>
<p><strong>温馨提示</strong>：这里要注意的是，while的条件和上面的不太一样，当我们要判断一个<code>节点的指针域</code>是否为空时，用的是while(IterativeNext -&gt; PointerToNext != nullptr)，当我们要判断一个<code>节点</code>是否为空时，用的是while(TraversalNode != nullptr)，这两个是有区别的。</p>
</blockquote>
<p>4 . 最后运行一下代码，看看结果：</p>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_cpp6_2.png" alt="" /></p>
<p>5 . 结果是没什么问题的，到这里也就结束了。</p>
<h2>总结</h2>
<p>1 . 这里我先将代码整理出来，以方便阅读。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;

using namespace std;

struct StudentLinkNode   // 定义结构体
{
    int student_age;    // 数据域
    string student_name; 
    StudentLinkNode * PointerToNext; // 指针域
};

StudentLinkNode * HeadNode = nullptr;   // 全局变量下的头节点

StudentLinkNode * CreatNodeForStudent(int age, string name)   // 创建节点
{
    StudentLinkNode * newnode = new StudentLinkNode;
    newnode -&gt; student_age = age;
    newnode -&gt; student_name = name;
    newnode -&gt; PointerToNext =nullptr;
    return newnode;
}

void InsertNodeForStudent(int age, string name)   // 插入节点
{ 
    StudentLinkNode * newnode = CreatNodeForStudent(age, name);  // 调用创建节点函数
    if (HeadNode == nullptr)  // 当头节点为空则将新节点赋值给头节点
    {
        HeadNode = newnode;
    }
    else // 当头节点不为空，则循环查找空的指针域，并赋值给空的指针域
    {
        StudentLinkNode * IterativeNext = HeadNode;
        while (IterativeNext -&gt; PointerToNext != nullptr)
        {
            IterativeNext = IterativeNext -&gt; PointerToNext;
        }
        IterativeNext -&gt; PointerToNext = newnode;
    }
}

void TraversalLinkNode()   // 遍历链表
{
    StudentLinkNode * TraversalNode = HeadNode;
    while (TraversalNode != nullptr)
    {
        cout &lt;&lt; TraversalNode -&gt; student_age &lt;&lt; "岁, 姓名：" &lt;&lt; TraversalNode -&gt; student_name &lt;&lt; endl;
        TraversalNode = TraversalNode -&gt; PointerToNext;
    }
    
}
int main()
{
    InsertNodeForStudent(18, "Almango");
    InsertNodeForStudent(17, "Boom");
    InsertNodeForStudent(20, "Fun");
    TraversalLinkNode();
}
</code></pre>
<p>3 . 链表作为一种比较常用的数据结构还是需要我们去掌握的，当然，我第一次学习确实挺困难的，但只要多练习，多去举一反三，链表也是不在话下，不仅如此这对于更加深入的去理解指针也有着很大的帮助。
4 . 这次单链表就到这里，如果不是为了加深记忆，我是真懒得写……
5 . 后面会尝试一下双链表，头插法等功能操作。</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Butterfly_一图流背景与页脚美化</title>
    <link href="https://mizuki.mysqil.com/posts/butterfly_%E4%B8%80%E5%9B%BE%E6%B5%81%E8%83%8C%E6%99%AF%E4%B8%8E%E9%A1%B5%E8%84%9A%E7%BE%8E%E5%8C%96/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/butterfly_%E4%B8%80%E5%9B%BE%E6%B5%81%E8%83%8C%E6%99%AF%E4%B8%8E%E9%A1%B5%E8%84%9A%E7%BE%8E%E5%8C%96/</id>
    <published>2024-10-03T13:20:03.000Z</published>
    <updated>2024-10-03T13:20:03.000Z</updated>
    <summary>将文章封面与背景于一体，让页脚显示更高档。</summary>
    <content type="html"><![CDATA[<h2>一图流背景</h2>
<p>1.一图流背景简单来说就将背景作为文章的顶部封面，相当于把原有的封面去除了，这样看起来会更加清爽。
2.本站参考了博主<strong>闪闪发光的 ZZZ</strong>：<a href="https://blog.captainz.cc/posts/hexo_butterfly_top_img.html">Hexo+Butterfly 主题一图流背景与顶部图修改</a></p>
<p><strong>效果图</strong>：
<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_bgandfoot_1.png" alt="" /></p>
<h3>代码</h3>
<p>1.将主题文件中的<code>index_img:</code>设为<code>transparent透明</code>。
2.在<code>background:</code>处设置自己喜欢的背景。</p>
<pre><code># The banner image of home page
index_img: transparent
————————————————————————————————————————————
# If the banner of page not setting, it will show the top_img
default_top_img: false         
# The banner image of archive page
archive_img: false
......
# Website Background (設置網站背景)
background: url(/img/background/g.jpg) top / cover no-repeat
</code></pre>
<p>3.在目录<code>source/css/</code>内新建一个文件：<code>modify.styl</code>，参入以下内容。</p>
<pre><code>@import 'nib'

// 顶部图
#page-header
  background: transparent !important

  &amp;.post-bg, &amp;.not-home-page
    height: 280px !important
     
  #post-info          // 标题居中
    bottom: 40px !important
    text-align: center
  #page-site-info     // 标题下信息居中
    top: 140px !important

  @media screen and (max-width: 768px)
    &amp;.not-home-page
      height: 200px !important
    #post-info
      bottom: 10px !important
    #page-site-info
      top: 100px !important

.top-img
  height: 250px
  margin: -50px -40px 50px
  border-top-left-radius: inherit
  border-top-right-radius: inherit
  background-position: center center
  background-size: cover
  transition: all 0.3s

  @media screen and (max-width: 768px)
    height: 230px
    margin: -36px -14px 36px

  [data-theme='dark'] &amp;
    filter: brightness(0.8)

// 页脚
#footer:before
  background-color: alpha(#FFF, .5)

  [data-theme='dark'] &amp;
    background-color: alpha(#000, .5)

#footer-wrap, #footer-wrap a
  color: #111
  transition: unset

  [data-theme='dark'] &amp;
    color: var(--light-grey) 
</code></pre>
<p>4.最后在主题文件内引入<code>modify.css</code>即可</p>
<blockquote>
<p>modify.styl 会被 Hexo 渲染成 modify.css 文件，所以此处应为 modify.css。</p>
</blockquote>
<pre><code># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前
inject:
  head:
    - &lt;link rel="stylesheet" href="/css/modify.css"&gt;
</code></pre>
<h2>页脚美化</h2>
<p>1.本期页脚美化新增了快速回到顶栏的功能。
2.本站参考了博主<strong>ichika</strong>：<a href="https://ichika.cc/Article/beautiful_MyBeautiful/#%E9%A1%B5%E8%84%9A">本站的一些样式魔改</a> 的教程
<strong>效果图</strong>：
<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_bgandfoot_2.png" alt="" /></p>
<h3>代码</h3>
<p>1.打开<code>layout/includes/footer.pug</code>，覆盖上以下代码：（记得将信息改为自己的）</p>
<pre><code>#footer-wrap
  #footer-left
    .footer-title
      span= config.title + ' | '
      if theme.footer.owner.enable
        - var now = new Date()
        - var nowYear = now.getFullYear()
      if theme.footer.owner.since &amp;&amp; theme.footer.owner.since != nowYear
        span.footer-copyright!= `&amp;copy;${theme.footer.owner.since} - ${nowYear} By ${config.author}`
      else
        span.footer-copyright!= `&amp;copy;${nowYear} By ${config.author}`
    .footer-button
      a(title='GitHub' href='https://github.com/Almango')
        i.fab.fa-github
      a(title='微博' href='https://weibo.com/u/7936064867')
        i.fab.fa-weibo
      a(title='bilibili' href='https://space.bilibili.com/18247019?spm_id_from=333.1007.0.0')
        i.fab.fa-bilibili
      a(title='twitterb' href='https://twitter.com/Receiver99xkk?t=UoMBRIY0a-csS_gUb9aIRg&amp;s=09')
        &lt;i class="fa-brands fa-x-twitter"&gt;&lt;/i&gt;
      a(title='Email' href='https://www.microsoft.com/zh-cn/microsoft-365/outlook/email-and-calendar-software-microsoft-outlook?deeplink=%2fowa%2f0%2f%3fstate%3d1%26redirectTo%3daHR0cHM6Ly9vdXRsb29rLmxpdmUuY29tL21haWwvMC8&amp;sdf=0')
        &lt;i class="fa-solid fa-envelope"&gt;&lt;/i&gt;
    .wordcount
    - let allword = totalcount(site)
    span= 'Almano已经写了 ' + allword + ' 字，'
    if isNaN(allword)
      - allword= Number(allword.replace('k', ''))
      if allword&lt; 50
        span= "还在努力更新中.. 加油！加油啦！"
      else if allword&lt; 70
        span= "好像写完一本 埃克苏佩里 的 《小王子》 了啊"
      else if allword&lt; 90
        span= "好像写完一本 鲁迅 的 《呐喊》 了啊"
      else if allword&lt; 100
        span= "好像写完一本 林海音 的 《城南旧事》 了啊"
      else if allword&lt; 110
        span= "好像写完一本 马克·吐温 的 《王子与乞丐》了！ 了啊"
      else if allword&lt; 120
        span= "好像写完一本 鲁迅 的 《彷徨》 了啊"
      else if allword&lt; 130
        span= "好像写完一本 余华 的 《活着》 了啊"
      else if allword&lt; 140
        span= "好像写完一本 曹禺 的 《雷雨》 了啊"
      else if allword&lt; 150
        span= "好像写完一本 史铁生 的 《宿命的写作》 了啊"
      else if allword&lt; 160
        span= "好像写完一本 伯内特 的 《秘密花园》 了啊"
      else if allword&lt; 170
        span= "好像写完一本 曹禺 的 《日出》 了啊"
      else if allword&lt; 180
        span= "好像写完一本 马克·吐温 的 《汤姆·索亚历险记》 了啊"
      else if allword&lt; 190
        span= "好像写完一本 沈从文 的 《边城》 了啊"
      else if allword&lt; 200
        span= "好像写完一本 亚米契斯 的 《爱的教育》 了啊"
      else if allword&lt; 210
        span= "好像写完一本 巴金 的 《寒夜》 了啊"
      else if allword&lt; 220
        span= "好像写完一本 东野圭吾 的 《解忧杂货店》 了啊"
      else if allword&lt; 230
        span= "好像写完一本 莫泊桑 的 《一生》 了啊"
      else if allword&lt; 250
        span= "好像写完一本 简·奥斯汀 的 《傲慢与偏见》 了啊"
      else if allword&lt; 280
        span= "好像写完一本 钱钟书 的 《围城》 了啊"
      else if allword&lt; 300
        span= "好像写完一本 张炜 的 《古船》 了啊"
      else if allword&lt; 310
        span= "好像写完一本 茅盾 的 《子夜》 了啊"
      else if allword&lt; 320
        span= "好像写完一本 阿来 的 《尘埃落定》 了啊"
      else if allword&lt; 340
        span= "好像写完一本 艾米莉·勃朗特 的 《呼啸山庄》 了啊"
      else if allword&lt; 350
        span= "好像写完一本 雨果 的 《巴黎圣母院》 了啊"
      else if allword&lt; 360
        span= "好像写完一本 东野圭吾 的 《白夜行》 了啊"
      else
        span= "好像写完一本我国著名的 四大名著 了！！！"
    else
      span= "还在努力更新中.. 加油！加油啦！"
  #footer-right
    .footer-totop
      i.fas.fa-chevron-up(onclick='scrollToTop()')
    .footer-info
      p= '使用Hexo框架 | 本站基于butterfly主题魔改'
      
      a(title='萌ICP备号 20240146' href='https://icp.gov.moe/?keyword=20240146') #[img(src='/img/footer_moe.png' alt='备案图标' style='height: 16px;margin-right: 3px;filter: grayscale(1);')]萌ICP备号: 20240146号
     
      a(title='喵喵ICP备案: 20240008号' href='https://www.nyaicp.xyz/?id=20240008" target="_blank"') #[img(src='https://520524.xyz/icptb/' alt='备案图标' style='height: 16px;margin-right: 3px;filter: grayscale(1);')]喵喵ICP备案: 20240008号

    .footer-service
      a(title='腾讯云' href='https://cloud.tencent.com')
        img(alt='腾讯云' src='https://cdn.ichika.cc/typora/202211071552681.png!towebp')
      a(title='51LA' href='https://www.51.la')
        img(alt='51LA' src='https://cdn.ichika.cc/typora/202211071552427.png!towebp')
      a(title='CC BY-NC-SA 4.0' href='https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh')
        img(alt='CC BY-NC-SA 4.0' src='https://cdn.ichika.cc/typora/202211071552856.png!towebp')
</code></pre>
<p>2.在<code>source/css</code>内新建一个<code>custom.css</code>，并参入以下代码：</p>
<pre><code>/* 页脚 */
.footer_custom_text a{
    margin:0 5px;
}

#footer::before{
    content:none;
}

#footer-wrap{
    color:var(--font-color);
    padding:50px 5% 35px 5%;
    display:flex;
    flex-wrap:wrap;
    background:var(--ichika-footer-bg);
    position:relative;
}

#footer-wrap &gt; div{
    width:50%;
}

#footer-left{
    text-align:left
   
}

.footer-title{
    font-size:1.5rem;
    font-weight:bold;
}

.footer-copyright{
    font-size:1rem;
    font-weight:normal;
}

#footer-wrap .footer-button {
    display: flex;
    margin: 15px 0;
}

#footer-wrap .footer-button &gt; a {
    font-size: 1.3rem;
    margin-right:24px;
    transition: 0.2s;
    background: black;
    width: 40px;
    height: 40px;
    display: flex;
    border-radius: 50%;
    color: white;
}

#footer-wrap .footer-button &gt; a:hover{
    background: pink;
    transition:0.2s;
    text-decoration-line: none;
}

#footer-wrap .footer-button &gt; a i{
    margin:auto;
    margin-left: 9.5px;
    margin-bottom: 1px;
    line-height:42px;
}

#footer-wrap .iconfont{
    font-size:1.3rem;
}

#footer-right {
    text-align: right;
    height: max-content;
    margin-top: auto;
}

#footer-right p,#footer-right a{
    color:var(--ichika-font-grey);
}

.footer-totop {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
}

.footer-totop i {
    font-size: 2rem;
    animation: footerToTop 1.2s linear infinite;
}

.footer-info p{
    font-size:14px;
    margin:0;
}

.footer-info a{
    margin-left:20px;
    transition:0.2s;
}

.footer-info a:hover{
    color:var(--ichika-color)!important;
    transition:0.2s;
}

.footer-info a:hover img{
    filter: none!important;
    transition:0.2s;
}

.footer-service img{
    height:20px;
    filter:grayscale(1);
    margin-left:20px;
    margin-top:10px;
    transition:0.2s;
}

.footer-service img:hover{
    filter:none;
    transition:0.2s;
}

@keyframes footerToTop{
    0%{
        transform:translateY(0);
    }
    60% {
        transform: translateY(-25%);
    }
    100% {
        transform: translateY(0);
    }
}

@media screen and (max-width:768px) {
    #footer-wrap &gt; div {
        width: 100%;
        text-align:center;
    }

    #footer-wrap .footer-button &gt; a{
        margin:0 auto;
    }
}

</code></pre>
<p>3.在<code>source/js</code>内新建一个custom.js文件，参入以下代码：</p>
<pre><code>function scrollToTop() {
    btf.scrollToDest(0, 500);
}
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="魔改"></category>
  </entry>
  <entry>
    <title>分享我在电脑内的学习与开发环境</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%88%86%E4%BA%AB%E6%88%91%E5%9C%A8%E7%94%B5%E8%84%91%E5%86%85%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%88%86%E4%BA%AB%E6%88%91%E5%9C%A8%E7%94%B5%E8%84%91%E5%86%85%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</id>
    <published>2024-09-03T14:46:51.000Z</published>
    <updated>2024-09-03T14:46:51.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>Google Chrome插件</h2>
<h3>iTab 新标签页</h3>
<p>1 . iTab是一款免费无广告的组件式浏览器主页插件。
2 . iTab 新标签页可能是我见过最美观的主导航页面了，你可以在该主页内自定义自己常用的网站快捷方式，也可以添加一些小组件，它还提供了分层页面，帮助你将主页的网站快捷方式进行分类。
3 . 多的不说，iTab功能太多了，且还保持着页面的整洁。我只能说浏览器扩展的唯一真神！！！</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_selfpc_7.png" alt="" /></p>
<p>4 . 下载链接：<a href="https://itab.link/?from=itab">https://itab.link/?from=itab</a>
5 . 下载完成后，只需要将文件拖到Chrome浏览器的扩展管理页面<code>chrome://extensions/</code>内，并启动插件即可。</p>
<h3>Cat-catch</h3>
<p>1 . 猫抓(cat-catch) 是一款<a href="https://github.com/xifangczy/cat-catch?tab=readme-ov-file">开源</a>的资源嗅探扩展，能够帮你筛选列出当前页面的资源。
2 . 它能够将你正在访问的页面内的资源（如mp3，mp4，png，gif……等资源）抓取出来，并且可以直接下载该资源。
3 . 当然了，该插件只能获取非会员的资源，毕竟非法抓取资源是需要追究侵权责任的。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_selfpc_8.png" alt="" /></p>
<p>4 . 官方下载：<a href="https://chrome.google.com/webstore/detail/jfedfbgedapdagkghmgibemcoggfppbb">https://chrome.google.com/webstore/detail/jfedfbgedapdagkgh</a>（需要挂梯子）</p>
<h2>Geek</h2>
<p>1 . <code>Geek Uninstaller</code> 是一款功能强大、操作简便的软件卸载工具，帮助您彻底移除不需要的软件，保持系统的清洁和高效。无论是个人用户还是企业用户，Geek Uninstaller 都能满足需求，提供一流的卸载体验。</p>
<p>2 . Geek不仅可以快速的卸载掉一些不用的软件，不仅如此它还能够将该软件在注册表留下的信息全都清理掉，十分高效，别说怎么用，就连刚接触电脑的小白也能轻松使用，小白直呼：<code>终于不用在360软件管家卸载软件啦！！！</code></p>
<p>3 . 下载链接：<a href="https://geekuninstaller.com/download">https://geekuninstaller.com/download</a></p>
<h2>Windows Terminal</h2>
<p>1 . <code>Windows Terminal</code>是一款新式、快速、高效、强大且高效的终端应用程序，适用于命令行工具和命令提示符，PowerShell和 WSL 等 Shell 用户。主要功能包括多个选项卡、窗格、Unicode、和 UTF-8 字符支持，GPU 加速文本渲染引擎以及自定义主题、样式和配置。</p>
<p>2 . 相当于传统的命令提示符和PowerShell，Windows Terminal提供了更多功能，并且有着很高的自由度。可以说是windows用户人手必备，当然现在大部分pc都会自带这一应用，没有的话也可以在微软商店下载安装。
<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_selfpc_6.png" alt="" /></p>
<p>3 . 例如，例如你可以通过安装<code>Oh My Posh</code>来美化你的终端样式，不同主题的效果如下：</p>
<p><img src="https://ohmyposh.dev/assets/images/iterm2-71c33326b1f03dfaa3ea963b4bd8e19a.png" alt="" /></p>
<p><img src="https://ohmyposh.dev/assets/images/mt-90ef4a3aa3913a7dd3225bdc0e9a524e.png" alt="" /></p>
<p>4 . 当然了，我也懒得美化，想美化还得看教程.......</p>
<p>5 . <code>安装</code>也很简单，直接在<code>MicroSoft Store</code>内搜索<code>Windows Terminal</code>下载安装即可。</p>
<h2>Visual Studio Code</h2>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_selfpc_1.png" alt="" /></p>
<h2>字体</h2>
<h4>CodeNewRoman NF</h4>
<p>1 . 码字的第一精神生产力那必定是字体样式了。其实代码字体本质上没有什么客观上的效果，但却能让我对敲代码产生强烈的欲望，靠，我真是中邪了。
2 . 虽然我使用过很多字体，但最后都无法满足我的审美，到后来才发现了<code>CodeNewRoman Nerd Font</code>这款字体。
3 . CodeNewRoman NF这款字体是我在为NeoVim寻找合适的带多种文字图标字体时发现的，它来源于<a href="https://www.nerdfonts.com/">Nerd Fonts</a>，这提供大量免费开源的适合敲代码的字体，这里的字体的特点就是，字体内会附带很多文字图案。最后我们也不用担心侵权问题。
4 . <code>下载链接</code>：<a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v3.2.1/CodeNewRoman.zip">https://github.com/ryanoasis/nerd-fonts/releases/download/v3.2.1/CodeNewRoman.zip</a></p>
<h4>黑体</h4>
<p>1 . 英文字体有了，中文字体当然也得有，我选择的是<code>黑体</code>。</p>
<p>2 . 这款字体系统一般都会自带，所以可以直接使用。</p>
<pre><code>CodeNewRoman Nerd Font, '黑体'

</code></pre>
<p>3 . 代码用CodeNewRoman Nerd Font，注释用黑体，整体来讲还是非常协调的。</p>
<h3>插件</h3>
<pre><code>Visual Studio Code扩展
├─ Chinese (Simplified)
├─ Code Runner
├─ One Dark Pro
├─ Simple icons
└─ Markdown Preview Enhanced
</code></pre>
<p>Chinese就不用介绍了：汉化插件</p>
<h4>Code Runner</h4>
<p>1 . 当我们想在Visual Studio Code运行一些语言的程序时可能都需要用到code runner了，它可以通过匹配文件在相当于的编译环境内运行代码。也就是说你的是java程序它就会在java的编译环境内运行，是c就会在c语言的编译环境内运行……</p>
<p>2 . 在vscode扩展市场内可以直接安装该插件
3 . 你可以在扩展设置的<code>setting.json</code>内配置你需要的环境。
4 . 最后需要在扩展设置中<code>勾选</code>：<code>Run In Terminal</code>，代码运行后它便会在内置终端内输出。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_selfpc_3.png" alt="" /></p>
<h4>One Dark Pro</h4>
<p>1 . <code>One Dark Pro</code>,我只能说是<code>代码配色</code>的唯一<code>真神</code>了。
2 . One Dark Pro有着极高的颜值，受到许多开发者的喜爱，安装量直接是达到了9,740,267之多。估计看了代码就知道什么叫高颜值配色了。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_selfpc_4.png" alt="" /></p>
<p>3 . 不过呢，还有一款比较冷门的配色我也挺喜欢的：<code>Saturated Dark Modern</code>，感觉颜值也还在线，可以去试一下。</p>
<h4>Simple icons</h4>
<p>1 . <code>Simple icons</code>是一款内置多种支持文件类型的图标插件，它可以修改替换掉侧边栏文件树的图标，使得编辑器更加美观。
2 . 这个就不给图片演示了</p>
<h4>file-icons</h4>
<p>1 . <code>file-icons</code>同样也是一款内置多种支持文件类型的图标插件，相对于<code>Simple icons</code>内容会更多一些。</p>
<p><img src="https://raw.githubusercontent.com/file-icons/atom/6714706f268e257100e03c9eb52819cb97ad570b/preview.png" alt="" />
、</p>
<p>2 . 以上是file-icons所支持的文件类型的图标，也是相当多的。
3 . 不过话说回来，我还是<code>更喜欢Simple icons</code>，因为它更饱满和高亮，看着舒服。</p>
<h4>Markdown Preview Enhanced</h4>
<p>1 . 这是一个内置的Markdown预览窗口，它可以在vscode中实时预览md文章，实现了vscode编写markdown文章的自由与方便。</p>
<p>2 . 不过我几乎不怎么在vscode中编写md文章，感觉这个内置的预览窗口还是太简单了，毫无样式可言，不过对于某些人来说开始很便捷的，毕竟不用收费，而且也不需要互联网环境。
3 . 我后面会推荐一个在线的md编辑工具。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_selfpc_5.png" alt="" /></p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="推荐分享"></category>
  </entry>
  <entry>
    <title>绝区零开服至今体验闲谈</title>
    <link href="https://mizuki.mysqil.com/posts/%E7%BB%9D%E5%8C%BA%E9%9B%B6%E5%BC%80%E6%9C%8D%E8%87%B3%E4%BB%8A%E4%BD%93%E9%AA%8C%E9%97%B2%E8%B0%88/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E7%BB%9D%E5%8C%BA%E9%9B%B6%E5%BC%80%E6%9C%8D%E8%87%B3%E4%BB%8A%E4%BD%93%E9%AA%8C%E9%97%B2%E8%B0%88/</id>
    <published>2024-08-29T10:42:00.000Z</published>
    <updated>2024-08-29T10:42:00.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p>~ <strong>欢迎来到新艾利都</strong> ~</p>
</blockquote>
<p>1 . 说真的，这是我第一次成为米家游戏的开服玩家，虽然四年前也玩过了崩坏3，但那个时候不管怎么玩都已经落后其他玩家很大距离了，甚至还养了一堆没用的角色……。开服玩家的优势就是可以领先一些玩家一段距离，当然这也得看自身能力，或者氪金能力，所以……
2 . 自从听到绝区零会在7月4日公测，其实这个时候我就已经开始放弃崩坏三了，打算把精力全都投入到绝区零当中去。</p>
<p>3 . 官方说是7月4日上午10点开服，但实际上为了降低崩服的风险，开服时间比预定提前了几个小时，所以当我10点多登录游戏账号的时候，我的UID已经到达八位数了（UID：18450689），也能理解，毕竟是个万众瞩目的游戏。</p>
<p>4 . 这里要说的是，入坑绝区零的首要因素是：这款游戏的画面风格我很喜欢，<code>现代风</code>，<code>赛博风</code>，同时参入了<code>日美元素</code>。这相对于原神那种玄幻风格的简直不要太棒。</p>
<h2>游戏体验</h2>
<h4>剧情</h4>
<p>1 . 开服到现在差不多玩了一个月1了，就这么说吧，游戏不论是场景细节还是打斗特效以及人物刻画都是十分细节精湛，很可惜我的不是电脑，如果是高配电脑的话，画面会更加高清细节，手机的话勉勉强强。
2 . 主线剧情还是挺有代入感的，有些剧情甚至会让我有所感动，就比如珂蕾妲操作原型机的那一段剧情、还有新出的支线任务：卧底蓝调，绝了，只能说老米做游戏还有脑回路的。绝区零打主线是不需要体力的，不过打到一定阶段需要提升角色等级，不然打不过。奖励的话，中规中矩还行。
3 . 令很多玩家受不了的是主线的走格子，这玩意纯纯浪费时间，而且注意不集中还特别容易犯困，只能说走格子是劝退大部分玩家的重要因素吧。走格子不仅仅存在于主线和探索，连副本（零号空洞）也有，虽然零号空洞的奖品很丰富，但我是真的不想走格子。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_zzz_1.jpg" alt="" /></p>
<h4>角色</h4>
<p>1 . 爱上绝区零的另一大因素是角色风格，都挺符合我审美的，其实这主要取决于绝区零是款现代风格类游戏。当年入坑崩坏三的时候，里面角色还挺正常的，到了后面就变得花里胡哨了，那雷之律者直接开龙，理律直接开摩托，一大堆花里胡哨的皮肤装饰。我不知道zzz后期会不会也发展成这个碧样。</p>
<p>2 . 另外在养成上面，真的需要下不少功夫，特别是驱动盘，盘属性纯靠刷，刷不到满意的不会停手，技能等级提升也很难，到了后面特别耗材料，一天的体力都不够一个技能升两级……以至于我已经到了传奇绳匠还没升满1/2。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_zzz_3.jpg" alt="" /></p>
<p>3 . 角色的主要类别为：<code>强攻</code>、<code>击破</code>、<code>异常</code>、<code>支援</code>和<code>防护</code>，我目前只有一个S级强攻，只能说一个S强攻很难配第二队。第二队拉胯的话压根打不过式舆防卫战（深渊），前一个卡池已经歪了，我现在必须拿下几天后上场的<code>简·杜</code>。话说回来，能抽到艾连就已经很幸运了，我有个朋友没抽艾连，居然拿珂蕾妲配比打到49级，真是不知道他是怎么熬过来的。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_zzz_2.jpg" alt="" /></p>
<p>4 . 角色上面不想多说了，主要就是培养角色属性上的黄色字体的属性。这些属性需要靠升级角色来提升，或者升级专武来提升，说到专武（引擎），这玩意是真tm难搞，本来好不容易抽完了代理人，现在又要抽专武，哪来的那么多菲林啊！！！，新手玩家还算不错，福利也不差，到了后期，想搞个10抽，简直要人半条命。</p>
<p>5 . 不仅如此，游戏的NPC做的也是相当惊艳的。这奶茶店员我是经常去看几眼的。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_zzz_6.jpg" alt="" /></p>
<h4>打斗画面</h4>
<p>1 . 游戏玩的最过瘾的便是打架了，特效动作都很到位，可惜我文学水平差，不能用一种高超的语言文字来描述，反正打的那叫一个爽，这主要体现在克制，暴击和击破后的失衡上，拿我的鲨鱼妹切的是真的爽。</p>
<p>2 . 绝区零是这样的，将怪物打到击破状态，它就无法攻击和移动，这段时间可以疯狂输出。不仅如此想打出高爆伤害需要按照特定的一套攻击步骤才能触发，这个我一般不会在意，怎么爽怎么打。</p>
<h4>思虑</h4>
<p>1 . 一个月下来，只能说官方给的活动太少了，主线打完后，大部分事件都在长草期，每天上线除了做个日程，打个材料，或者每周打个副本，真的没啥干的了。</p>
<p>2 . 所以我特地开了两个号，主要是应为我刚好成年了，严格来讲，其实我开了三个号，开服期间我还没成年的，用的是我家人身份实名的账号（17级），后面换成了B区（也就是我现在最高等级的账号：50级），成年后我又开了一个号（27级），这是为了在B区长草期间找点事做。</p>
<p>3 . 我现在陷入了思虑，就是不知道该不该玩两个号，太浪费精力了，但想到新开的号是官服且是自己的身份实名的，其实说到账号这件事，我是比较严肃对待的，我希望把精力全都投入到自己的实名账号上去，但B区的账号又发展的这么好，又不舍得放弃……目前两个号都会玩一下，害，我这选择强迫症太难受了。（还有一个原因：我的B区账号选择的主角是哥哥哲，我当时真后悔选哥哥，哪有我小号的妹妹玲好看啊！！！不是我说，哲跟个人机一样）。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_zzz_4.jpg" alt="" /></p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_zzz_5.jpg" alt="" /></p>
<p>4 . 不管怎么样，毕竟都是自己的账号吧。玩的开心就行。
5 . 总结来说，一个月下来玩的还是比较过瘾的，只不过后期就变得无聊等级又难提升了，我现在攒的材料还没乱用，打算全放到简上去。
6 . 作为一个养生类游戏还是可以的……</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="闲谈"></category>
  </entry>
  <entry>
    <title>C++结构体的用法浅析【5】</title>
    <link href="https://mizuki.mysqil.com/posts/cpp%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%94%A8%E6%B3%95%E6%B5%85%E6%9E%90/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/cpp%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%94%A8%E6%B3%95%E6%B5%85%E6%9E%90/</id>
    <published>2024-08-21T11:27:20.000Z</published>
    <updated>2024-08-21T11:27:20.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p>C++中的结构体还是挺有必要记录一下，写个笔记的。它和类十分的相似，所以在这里需要做个具体的区分。
结构体和类最大的区别就是：结构体的成员默认是完全公开<code>public</code>的，而类则默认是私有`private的。</p>
</blockquote>
<h2>结构体</h2>
<p>1 . C++中的结构体（Struct）是一种数据结构，可以将创建好的结构体作为一个新的数据类型来使用。</p>
<p>2 . <code>结构体是一个单一名称下不同数据类型的变量的集合</code>。它与类相似，两者都保存着不同数据类型的数据集合。
3 . 通常情况下，当我们想多个同一属性的变量，在不使用类和结构体的情况下，我们需要声明多个变量来实现这些属性，而为解决这一不优雅的操作，结构体应运而生，它运允许在一个结构体内定义多个属性， 且将不同类型的数据项组合成一个单一的实体。结构体通常用于将数据分组，以便可以轻松地作为一个单元来处理它们。</p>
<h2>语法</h2>
<pre><code>struct [structName]
{
   member-list
} [declarators];
</code></pre>
<ul>
<li>struct：结构体关键字</li>
<li>structName：结构体名称</li>
<li>member-list：成员列表（在这里定义成员数据）</li>
<li>declarators：对象名（可填可不填）</li>
</ul>
<h2>基本使用</h2>
<p>1 . 结构体的实现相对简单，你只需要在结构体内提前声明好所需的变量类型和名称。当需要使用这些变量时，可以创建结构体的实例（对象），然后通过这个实例来访问和操作其成员变量。值得注意的是，<code>每个结构体实例的成员变量都是独立的</code>，不是共享的。结构体的成员变量可以在结构体定义的作用域内被访问和修改，你可以在程序的适当位置创建结构体实例，并在需要时重复创建多个实例来使用。</p>
<p>2 . 这里我写了一个示例：这里定义一个结构体用来描述不同水果的属性值。模拟通过结构体快速地描述苹果的属性。
3 . 首先，<code>结构体是被当做一个新的数据类型来使用的</code>，我们只需<code>在创建一个对象时，在前面加上结构体名称</code>即可，这个结构体名称实际上就是一个新的数据类型。
4 . 最终只需要通过一个<code>.</code>来达到传入属性值，<code>也可以通过最便捷的方式传值，如代码注释掉的部分</code>。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

struct Fruit
{
    string Name;   // 水果的名称
    string TypeName;   // 水果的品种名
    double Sugar_content;  // 水果的含糖量
};

int main()
{
    // 两种对象创建的方式
    struct Fruit Apple;
    Fruit Banana;

    Apple.Name = "苹果";
    Apple.TypeName = "阿克苏红富士";
    Apple.Sugar_content = 0.2;
    // Apple = {"苹果", "阿克苏红富士", 0.2};
    
    // 输出苹果的信息
    cout &lt;&lt; Apple.Name &lt;&lt; endl;
    cout &lt;&lt; Apple.TypeName &lt;&lt; endl;
    cout &lt;&lt; Apple.Sugar_content &lt;&lt; endl;
}
</code></pre>
<p>5 . 输出苹果在结构体内的属性值，没什么问题。</p>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_cpp5_1.png" alt="" /></p>
<p>6 .  <code>基于每个结构体实例的成员变量都是独立的</code>，所以我们可以使用同一个结构体来实现描述多个对象。</p>
<pre><code>int main()
{
    // 两种对象创建的方式
    struct Fruit Apple;
    struct Fruit Banana;
    
    Apple = {"苹果", "阿克苏红富士", 0.2};
    Banana = {"香蕉", "巴西蕉", 0.11};

    cout &lt;&lt; Apple.Name &lt;&lt; endl;
    cout &lt;&lt; Apple.TypeName &lt;&lt; endl;
    cout &lt;&lt; Apple.Sugar_content &lt;&lt; endl;

    cout &lt;&lt; "-------------------------------" &lt;&lt; endl;  // 分割线

    cout &lt;&lt; Banana.Name &lt;&lt; endl;
    cout &lt;&lt; Banana.TypeName &lt;&lt; endl;
    cout &lt;&lt; Banana.Sugar_content &lt;&lt; endl;
    
}
</code></pre>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_cpp5_2.png" alt="" /></p>
<h3>补充说明</h3>
<h4>declarators参数创建对象</h4>
<p>1 . 这里补充一点: 在结构体的语法中，<code>declarators参数</code>是<code>允许在定义结构体时提前创建对象</code>的。在<code>结构体分号前</code>填入对象名称，即可创建对象而必须要在使用时再次创建对象。</p>
<pre><code>struct Fruit
{
    string Name;   // 水果的名称
    string TypeName;   // 水果的品种名
    double Sugar_content;  // 水果的含糖量
}Watermelon;

int main()
{
    Watermelon = {"西瓜", "下野地西瓜", 0.08};
}
</code></pre>
<h4>结构体成员的多种用法</h4>
<p>1 . 前面也说过，结构体有着和类一定的相似性，以至于它们的区别仅体现在访问权限上。
2 . 所以，类能做的结构体也能做，而不仅仅只是定义一些变量。
3 . 在结构体中你甚至还能写函数：例如写一个加法运算的函数。</p>
<pre><code>struct Math
{
    int add(int value, int value2)
    {
        int a = value + value2;
        return a;
    }
}Mathmore;

int main()
{
    int result = Mathmore.add(8,9);
    cout &lt;&lt; result &lt;&lt; endl;
    
}
</code></pre>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_cpp5_3.png" alt="" /></p>
<h2>结构体的数组对象</h2>
<p>1 . 在 C++ 中使用结构体时，我们也可以创建一个数组对象。
2 . 结构体数组对象的声明和使用方式与普通数组类似，但<code>数值对象中的每一个元素都是一个结构体类型</code>。
3 . 在创建一个结构体的数组对象时，必须指定其大小，并且无法再次更改。
4 . 下面看一下示例：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

struct Fruit
{
    string TypeName;   // 水果的品种名
    double Sugar_content;  // 水果的含糖量
}Watermelon, Orange[3];


int main()
{
    
    Orange[0] = {"金桔", 0.112};
    Orange[1] = {"柑橘", 0.102};
    Orange[2] = {"箭叶橘", 0.09};

    for(int i = 0; i &lt; 3; i++)
    {
        cout &lt;&lt; "品种：" &lt;&lt; Orange[i].TypeName &lt;&lt; endl;
        cout &lt;&lt; "含糖量：" &lt;&lt; Orange[i].Sugar_content &lt;&lt; endl;
        cout &lt;&lt; "=====================" &lt;&lt; endl;
    }
    
}
</code></pre>
<p>5 . 分析上述代码，我们创建了一个长度为<code>[3]</code>的数组对象，因为每个元素都代表着一个结构体类型，所以我们可以直接通过元素传值，最后通过for循环遍历出每个元素的结构体类型数据。最终得到下图的效果。</p>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_cpp5_4.png" alt="" /></p>
<h2>结构体指针的花样操作</h2>
<p>1 . 一般来说我们是直接通过<code>对象.结构体成员</code>的方式给成员变量赋值，当然我们也可以直接使用指针的方式直接指向结构体成员变量给其赋值。
2 . 这种方有着很多好处，例如：<code>指针访问速度更快</code>，<code>灵活性高</code>，<code>性能优化强</code>，<code>减少复制</code>等等。</p>
<p>3 . 当我们想通过这种方式给结构体成员变量赋值，可以这样：</p>
<pre><code>struct StudentInfomation
{
    string name;
    string sex;
    int age;
};

int main()
{
    struct StudentInfomation Class1;  // 创建结构体对象

    StudentInfomation * Pointer = &amp;Class1;  // 创建指针变量并赋值
    
    Pointer -&gt; name = "Almango";  // 指向name并赋值
    Pointer -&gt; sex = "男";   // 指向sex并赋值
    Pointer -&gt; age = 18;  // 指向age并赋值
    
    // 输出结构体成员变量
    cout &lt;&lt; Pointer -&gt; name &lt;&lt; endl;
    cout &lt;&lt; Pointer -&gt; sex &lt;&lt; endl;
    cout &lt;&lt; Pointer -&gt; age &lt;&lt; endl;   
}
</code></pre>
<p>4 . 首先创建一个结构体对象，再创建一个指针（指针类型为结构体类型）。将对象的内存地址赋值给指针变量，这样的话，指针代表了对象，最后可以直接通过<code>指针变量.结构体成员</code>的方式指向结构体成员变量，即可操作该变量。</p>
<p>5 . 输出结果为：</p>
<pre><code>&gt;&gt;&gt;Active code page: 65001
Almango
男
18
</code></pre>
<p>6 . 另一种操作：
7 . 和前者不同的是：在结构体中定义一个指针变量成员，利用这个结构体中的指针变量获取到对象的地址来访问结构体成员。
8 . 创建了一个StudentInformation类型的变量Class1，再创建一个指向StudentInformation类型的指针变量AdderPointer，并将其初始化为指向Class1。通过指针AdderPointer，设置Class1的成员变量name为"Boom"，sex为"女"，age为18。将AdderPointer的地址赋值给Class1的成员变量MemberPointer，这样Class1.MemberPointer现在指向Class1本身。通过AdderPointer打印出name、sex和age的值。</p>
<pre><code>struct StudentInformation
{
    string name;
    string sex;
    int age;
    StudentInformation * MemberPointer;
};


int main()
{
    struct StudentInformation Class1;   // 创建对象
     
    StudentInfomation * AdderPointer = &amp;Class1;  // 创建指针变量

    AdderPointer -&gt; name = "Boom";   
    AdderPointer -&gt; sex = "女";
    AdderPointer -&gt; age = 18;

    Class1.MemberPointer = AdderPointer;   // 将结构体变量中的指针内存地址变量赋值给class1

    cout &lt;&lt; AdderPointer -&gt; name &lt;&lt; endl;
    cout &lt;&lt; AdderPointer -&gt; sex &lt;&lt; endl;
    cout &lt;&lt; AdderPointer -&gt; age &lt;&lt; endl;
 }
</code></pre>
<p>9 . 最终输出结果为：</p>
<pre><code>&gt;&gt;&gt;Active code page: 65001
Boom
女
18
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C++数组及其基本特征的浅层解读【4】</title>
    <link href="https://mizuki.mysqil.com/posts/cpp%E6%95%B0%E7%BB%84%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81%E7%9A%84%E6%B5%85%E5%B1%82%E8%A7%A3%E8%AF%BB/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/cpp%E6%95%B0%E7%BB%84%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81%E7%9A%84%E6%B5%85%E5%B1%82%E8%A7%A3%E8%AF%BB/</id>
    <published>2024-08-16T22:44:10.000Z</published>
    <updated>2024-08-16T22:44:10.000Z</updated>
    <summary>C++指针与结构体的出生操作</summary>
    <content type="html"><![CDATA[<blockquote>
<ol>
<li>在Python或者是C#接触数组的时候可没那么多要注意的点，到了C++，好家伙，全是知识点。</li>
<li>这里我也懒得写太多原理性的东西，直接记一下基本常识和怎么去用就行。</li>
</ol>
</blockquote>
<h2>声明数组</h2>
<p>1 . 声明一个数组其实就是<code>告诉编译器申请一个数组变量</code>。
2 . 和C#一样，它的声明格式为：<code>Type VarName[];</code>，不难理解，在变量名后面加个<code>[]</code>中括号，就表示它是个数组。
3 . 例如我要声明一个整数数值：</p>
<pre><code>int IntArray[];
</code></pre>
<p>4 . 当然，也可以声明各种数据类型的数组</p>
<pre><code>int VarName1[];   // 声明一个整数数组
double VarName2[]; // 声明一个高精度浮点数数组
float VarName3[];  // 声明一个浮点数数组
string VarName4[];  // 声明一个字符串数组
char VarName5[];  // 声明一个字符数组
</code></pre>
<p>4 . 但要注意的是 当数组的类型为<code>int</code>，那么它的元素只能是整数类型的数据，是什么类型的数值，就是什么类型的数据。</p>
<h2>初始化数组</h2>
<p>1 . 声明一个数组后，当我们需要使用它的时候就需要对其进行初始化，也就是你要对这个数组做什么，<code>编译器就会给该数组分配合适的内存</code>。
2 . 初始化数值就相当于是你给该数组第一次设定的最原始的值，或者仅指定最原始的大小。
3 . 下面是两种不同的初始化方法。</p>
<h4>方法一</h4>
<ol>
<li>该方法仅对数值的大小进行初始化，并未对其掺入元素。</li>
<li>在中括号内指定为5，意思就是将其初始化为含5个整数元素的数组。这个时候编译器会为数组分配足够的内存来存储5个整型元素。</li>
</ol>
<pre><code>int IntArray[5];
</code></pre>
<h4>方法二（常用）</h4>
<ol>
<li>该方法直接对其数值进行参入最原始的值</li>
<li>这个时候，编译器会根据数组元素的多少，对其进行内存分配，并确定数组的大小。</li>
<li>要注意的是，如果你事先指定了数组的大小，那么数值内的元素必须在该数值的大小范围内。</li>
</ol>
<pre><code>int IntArray[] = {1, 3, 6, 3, 2};
</code></pre>
<h2>修改数元素</h2>
<p>1 . 效果数组内的元素，只需要通过下标索引获取需要修改的元素位置即可修改。
2 . 下标索引指定是元素的顺序序号，从最左边开始，第一个元素的索引值就是0，第二个元素的索引值就是1,，以此类推。
3 . 所以当我们需要修改某个元素的时候，我们可以这样操作：</p>
<pre><code>int IntArray[] = {1, 3, 6, 3, 2};
IntArray[2] = 43;
</code></pre>
<p>4 . 这个时候，原来的6就会被修改为43，最终数组的内容就是<code>1, 3, 43, 3, 2</code>。</p>
<h2>数组在内存中的连续性解读</h2>
<blockquote>
<p>在C++中，数组的内存分配是连续的。这意味着数组的每个元素都存储在相邻的内存地址中，从数组的第一个元素开始，依次向后扩展。</p>
</blockquote>
<p>1 . 下面会绘制了一张图，从图中可以将竖着的长条理解为一个数组，数组的每个元素都彼此紧贴并被包含在长条内，这样可以更加生动的理解数组在内存中的连续性。
2 . 数组在内存中的连续性具有多方面的优点，由于内存的连续性，<code>数组元素的访问速度很快</code>，因为CPU可以预读取内存，并且缓存行可以被有效利用。由于数组内存的连续性，你可以使用 memcpy 等函数来高效地复制整个数组。此外，当数组离开作用域或被销毁时，所有元素的内存将被释放，因为它们是连续存储的，这<code>大大节省了内存的开销</code>。而在元素访问上它也将变得更加方便。
<img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_cpp4_1.png" alt="" /></p>
<p>3 . 但这并不代表它十全十美。</p>
<blockquote>
<p>由于数组元素是连续存储的，访问越界的元素可能会导致程序崩溃或不可预测的行为，因为可能会访问到不属于数组的内存区域。</p>
</blockquote>
<p>4 . C++和其他编程语言在数组的特点上，有一点不太一样，就是：当你通过一个不存在的或者超出数组长度的索引来访问一个元素时，编译器并不会因此而报错，它会当做什么都没发生，最终你访问的元素它可能是无法预料的内存中的一个值（你不知道这个值来着哪里）。下面代码就是错误的示范。</p>
<pre><code>int IntArray[] = {12, 56, 32, 13, 36, 74};
cout &lt;&lt; IntArray[-12] &lt;&lt; endl;  // 错误示范
IntArray[-12] = 12;             // 错误示范
cout &lt;&lt; IntArray[-12] &lt;&lt; endl;  // 错误示范
</code></pre>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_cpp4_4.png" alt="" /></p>
<p>5 . 可以看到通过使用一个超出数组范围的索引值，它输出了一个很奇怪的数字，它可能来源于内存的每个地方，当我们尝试修改这个值的时候，虽然它并没有报错，但如果大型项目犯这种错误，程序崩溃的可能性会更大。
6 . <code>基于这个不可预测的行为，若当你尝试修改了这个值，它可能会导致整个程序的崩溃</code>。</p>
<h2>基本数据类型在数值中的标准大小</h2>
<p>1 . 我们知道，数值可以可以声明为多种不同数据类型数值，如：整数数组，字符串数组，布尔数值等等。但当我们将其初始化之后，<code>不同数据类型数组内的元素的标准内存大小都不一样，所以编译也会根据数据类型来分配内存</code>。
2 . 这里是不同数据类型的标准内存大小：</p>
<ul>
<li><code>int</code>：4字节</li>
<li><code>char</code>：1字节</li>
<li><code>float</code>：4字节</li>
<li><code>double</code>：8字节</li>
<li><code>string</code>：32字节</li>
</ul>
<h4>应用1：获取数组最后一个元素</h4>
<blockquote>
<p>根据不同数据类型内存大小的分配，我们可以通过<code>sizeof()</code>方法来获取到元素的总个数，并求得最后一个元素。</p>
</blockquote>
<p>1 . <code>sizeof()</code>：该方法可以获取到数组的总大小，也就是编译器给它分配了多少内存。
2 . 结合下面代码，可以更直观的理解：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    // 初始化数值
    int IntArray[] = {12, 56, 32, 13, 36, 74};
    // 获取到最后一个元素的索引值
    int toteelement = sizeof(IntArray) / 4 - 1;
    // 输出
    cout &lt;&lt; IntArray[toteelement] &lt;&lt; endl;

   // cout &lt;&lt; IntArray[sizeof(IntArray) / 4 - 1] &lt;&lt; endl;
}
</code></pre>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_cpp4_2.png" alt="" />
3 . 首先，我们知道，int类型的元素，其标准内存大小为4个字节，如果有6个元素，那么数组的总大小为24字节。
4 . 通过sizeof()函数我们可以拿到数组的总大小，我们将其除以4，得到的就是元素的总个数，由于数组的索引是从0开始排的，所以我们再减去1，得到的就是最后一个元素的下标索引了，以此得到其元素内容。
5 . 当然了，如果要拿到倒数第二个元素，就减去2，以此类推。
6 . 这就是基本数据类型在数值中的标准大小的一个基本应用。</p>
<h4>应用2：遍历数组元素</h4>
<p>1 . 通过拿到数组的总个数，我们可以给数组写一个for循环来遍历出它的所有元素。
2 . 看代码可以理解，就不再解释。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    int IntArray[] = {12, 56, 32, 13, 36, 74};
    int toteelement = sizeof(IntArray) / 4;
    for (int i = 0; i &lt; toteelement; i++)
    {
        cout &lt;&lt; IntArray[i] &lt;&lt; endl;
    }
}
</code></pre>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_cpp4_3.png" alt="" /></p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C++利用mt19937算法自定义一个随机数生成方法【3】</title>
    <link href="https://mizuki.mysqil.com/posts/cpp%E5%88%A9%E7%94%A8mt19937%E7%AE%97%E6%B3%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%96%B9%E6%B3%95/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/cpp%E5%88%A9%E7%94%A8mt19937%E7%AE%97%E6%B3%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%96%B9%E6%B3%95/</id>
    <published>2024-08-16T00:16:10.000Z</published>
    <updated>2024-08-16T00:16:10.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p>怪不得说C++难学，这里连个随机数生成器都要折腾好久，要是换做C#，一个Random()方法就解决了。
话说虽然C++继承了C语言的Rand()函数，但我想说的是，用它生成的随机数的概率精度是真的低。
不过到了C++11后，标准库新增了一个新的随机数生产方法，<code>mt19937</code>，下面就来大略的分析和简练一下这个方法。</p>
</blockquote>
<h2>MT19937随机数生成器</h2>
<p>1 . <code>mt19937随机数生成器</code>采用的是<a href="https://zh.wikipedia.org/wiki/%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95">梅森旋转算法（Mersenne twister）</a>来达到生成随机数，这个算法可以快速产生高质量高精度的32位伪随机数，
2 . 使用该算法生成的随机数不仅质量高，速度也快出其他生成器，
3 . 看名字也知道，它的<code>取值范围</code>是：<code>2^19937-1</code>，也就是19937的2次方减去1，这个数值非常大，以至于它远远超出了常规计算机和编程语言能够表示的整数范围。实际上，这个数字的位数将非常惊人，远远超出了任何标准整数类型的范围，所以在编程时，已经没有弄清它的取值范围的必要了。</p>
<p>4 . 在C++中，可以通过<code>#include &lt;random&gt;</code>来引入该标准库。
5 . 为了保证每次运行时输出的随机数不一样，我们需要使用<code>time(0)</code>，它表示用当前时间来初始化随机数生成器的种子，说直白点就是：只要当前时间有变化，生成的随机数序列就会不同，这样可以尽量避免每次运行时的生成重复的随机数。这个方法来源于&lt;time.h&gt;标准库，所以需要先引入才能使用。
6 . 在C++中，默认情况下，mt19937随机数生成器会生成一个32位的无符号整数，最大值是 <code>2^32 - 1</code>，也就是：4294967295。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;time.h&gt;

using namespace std;
int main()
{
    mt19937 RandomInt(time(0));
    cout &lt;&lt; RandomInt() &lt;&lt; endl;

}
</code></pre>
<p>7 . 所以，如果将上述代码放到循环可以看到，它的取值范围为：<code>(0 ~ 4294967295)</code></p>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_cpp2_1.png" alt="" /></p>
<h2>指定分布随机数范围</h2>
<p>C++ 标准库&lt;random&gt; 提供了一个模块类，该模块类<code>用于生成在指定范围内均匀分布的随机整数</code>。</p>
<blockquote>
<p><code>std::uniform_int_distribution&lt;int&gt; Name(start, end);</code></p>
</blockquote>
<ul>
<li>Name：模块类名称</li>
<li>start：区间一</li>
<li>end：区间二</li>
</ul>
<p>1 . 将得到的随机数放到这个指定好整数范围模块内，即可得到一个新的范围内的随机数。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;time.h&gt;

using namespace std;
int main()
{
    // 初始化种子
    mt19937 mt19937_RandomInt(time(0));
    // 指定随机数分布范围
    uniform_int_distribution&lt;int&gt; Distribution_temp(1,10);
    // 从指定范围内生成新的随机数
    int RandomInt = Distribution_temp(mt19937_RandomInt);
    cout &lt;&lt; RandomInt &lt;&lt; endl;
}
    
</code></pre>
<h2>封装成自定义函数库</h2>
<p>1 . 为了以后开发方便调用随机数生成器，我们可以将写好的生成器封装成一个头文件，后续调用更方便。
2 . 只需要写一个可传两个参数的方法即可。</p>
<p><strong>头文件：<code>almadef.h</code></strong></p>
<pre><code>#include &lt;random&gt;
#include &lt;iostream&gt;
#include &lt;time.h&gt;

using namespace std;

namespace Basefunction

{
	int RandomIntNum(int value, int value2)
	{
		// 初始化种子
        mt19937 mt19937_RandomInt(time(0));
        // 指定随机数分布范围
        uniform_int_distribution&lt;int&gt; Distribution_temp(value, value2);
        // 从指定范围内生成新的随机数
        int RandomInt = Distribution_temp(mt19937_RandomInt);
		// 返回给源文件
		return RandomInt;
		
		// string Randintnum_temp_to_string = to_string(Randintnum_temp);
		// char splitintnum = Randintnum_temp_to_string.back();
		// // cout &lt;&lt; splitintnum &lt;&lt; endl;
		// int Randintnum_temp_to_int = splitintnum - '0';
		// // return Randintnum_temp_to_int;
		// return Randintnum_temp_to_int;

    }
};
</code></pre>
<p><strong>源文件：<code>index.cpp</code></strong></p>
<pre><code>#include &lt;iostream&gt;
#include "almadef.h"

using namespace std;
using namespace Basefunction;
int main()
{
    int a = RandomIntNum(5, 15);
    cout &lt;&lt; "生成的随机数为：" &lt;&lt; a &lt;&lt; endl;
}
</code></pre>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_cpp2_2.png" alt="" /></p>
<p>3 . 可以看到，在源文件中调用自定义好的随机数生成器，会方便不少，变得更加灵活好用了。
4 . 当然，后续我希望我能自定义更多函数方法库，在自定义中不断学习和使得开发更加高效。</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C++指针详略【2】</title>
    <link href="https://mizuki.mysqil.com/posts/cpp%E6%8C%87%E9%92%88%E8%AF%A6%E7%95%A5/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/cpp%E6%8C%87%E9%92%88%E8%AF%A6%E7%95%A5/</id>
    <published>2024-08-13T20:42:51.000Z</published>
    <updated>2024-08-13T20:42:51.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>指针</h2>
<blockquote>
<p><strong>指针</strong>，是C/C++语言中的一个重要概念及其特点。指针也就是内存地址，它允许你直接操作内存地址。指针可以用来访问和修改内存中的数据，实现动态内存分配，以及实现一些高级编程技术，比如函数指针、指针数组等。</p>
</blockquote>
<blockquote>
<p>在计算机中，所有的数据都是存放在存储器中的，不同的数据类型占有的内存空间的大小各不相同。内存是以字节为单位的连续编址空间，每一个字节单元对应着一个独一的编号，这个编号被称为内存单元的地址。比如：int 类型占 4 个字节，char 类型占 1 个字节等。系统在内存中，为变量分配存储空间的首个字节单元的地址，称之为该变量的地址。地址用来标识每一个存储单元，方便用户对存储单元中的数据进行正确的访问。在高级语言中地址形象地称为指针。</p>
</blockquote>
<p><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/pointers-cpp?view=msvc-170">Microsoft文档 C++指针</a></p>
<h2>声明指针变量</h2>
<p>1 . 我们可以声明一个指针变量用来专门存储一个值的内存地址。
2 . 指针变量是一个特殊的变量，<code>只能用来存储指针类型的值</code>。
3 . 我们只需要在正常声明变量的基础上，在变量名前面加一个<code>*</code>号即可，例如：</p>
<pre><code>// 创建指针变量
int * pointer;
</code></pre>
<p>4 . 这样，我们就声明了一个用于存放<code>整数类型的指针变量</code>。</p>
<h2>赋值</h2>
<blockquote>
<p>指针是一个变量，可以存储一个对象的内存地址。</p>
</blockquote>
<p>1 . 由于指针变量只能存储指针类型，也就是内存地址，所以我们要先获取到一个变量的内存地址。
2 . 我们只需要在赋值的时候，在前面加个<code>&amp;</code>符号。
3 . 例如：我们想将num的内存地址赋值给x，赋值的时候要在num前面加个<code>&amp;</code>符号。</p>
<pre><code>int num = 17;
int * x;
x = &amp;num;
</code></pre>
<p>4 . 要注意的是：<code>如果创建的整数型指针类型，那么只能存入整数型内存地址</code>。</p>
<h2>基本操作</h2>
<h4>输出地址</h4>
<p>1 . 输出地址：</p>
<pre><code>int num = 17;
int * x = &amp;num;
cout &lt;&lt; x &lt;&lt; endl;
</code></pre>
<p>2 . 因为<code>x</code>已经是一个指针类型了，所以可以直接放输出语句内
3 . 最终它会输出一个如<code>0x61fe14</code>这样的地址，这是一个十六进制的地址，也就是<code>num</code>的值所存储的内存地址。
3 . 当然了，如果我们再往<code>x</code>前面再加一个<code>*</code>号，那它输出的就是变量num的值，这就相当于负负得正的思维逻辑。</p>
<pre><code>cout &lt;&lt; *x &lt;&lt; endl;
</code></pre>
<h4>修改值</h4>
<p>1 . 根据上面<code>负负得正</code>的思维逻辑，我们在<code>x</code>前面再加一个<code>*</code>号，将它重新赋值为17，那么它将直接修改变量num值，结果输出为18。</p>
<pre><code>int num = 17;
int * x = &amp;num;
* x = 18;
cout &lt;&lt; *x &lt;&lt; endl;
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C++头文件与命名空间的深入浅出【1】</title>
    <link href="https://mizuki.mysqil.com/posts/cpp%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/cpp%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/</id>
    <published>2024-08-11T16:12:18.000Z</published>
    <updated>2024-08-11T16:12:18.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p>1 . 虽然我学过一段时间的C#，但当我第一次转入到C++的时候，说实话，开始就被头文件给整懵逼了，不过由于C#是在C/C++的基础上衍生的，除了个头文件和一些没见过的点外，后续学起来会相对轻松点。
2 . 所以我接下来要说的是头文件和命名空间……</p>
</blockquote>
<h2>头文件</h2>
<p>1 . 头文件（Header Files）是C或C++等编程语言中，用于声明函数、变量、宏和类型定义的文件，它们通常以.h或.hpp等扩展名结尾。头文件使得程序员能够在多个源文件中使用相同的函数和类型定义，而不必重复编写代码。
2 . C/C++提供了一套标准库，使用的时候需要用预处理指令<code>#include</code>将其引入，这就被称作头文件，当然，开发者也可以自定义一个函数库，同样使用预处理指令<code>#include</code>将其引入，它的功能和Python的模块导入代码<code>import</code>很相似。
3 . 说的直白点，为了高效，头文件可以将已经写好的外部函数库或者标准库引入，这样可以大幅度减少代码的重复编写，提高开发效率和代码的可维护性。头文件的使用允许开发者在程序的不同部分重用已经定义好的代码，例如函数、类、模板等。这种重用机制不仅减少了代码冗余，也使得代码更加模块化，易于管理和扩展。</p>
<p>4 . 头文件的组织结构通常遵循一定的命名规范，以便于开发者快速识别和查找所需的头文件。例如，<code>标准库的头文件通常以&lt;&gt;括起来</code>，而项目中的<code>自定义头文件则使用""括起来</code>。</p>
<p>5 . 在C++中，头文件还与命名空间（Namespace）紧密相关。命名空间用于组织代码，避免不同库之间的名称冲突。头文件中通常会包含相应的命名空间声明，以确保使用其中的实体时不会产生命名冲突。</p>
<p>6 . <strong>看下面的经典代码，如果我们想输出“Hello World”，那么我们就需要调用控制台来输出，而<code>count &lt;&lt; &lt;&lt; endl</code>方法提供了这样一个功能，但它属于C++一个标准库，所以需要使用<code>#include &lt;iostream&gt;</code>来引入这个库，最后还需要将该标准库下的命名空间引入，这样编译器才能识别这个输出代码。</strong></p>
<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
    cout &lt;&lt; "Hello World" &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>7 . 当然，如果不想引用命名空间，可以以<code>命名空间::方法名</code>在代码中直接调用（除被<code>类</code>或<code>结构体</code>封装外）例如：</p>
<pre><code>#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<h2>命名空间</h2>
<p>1 . 命名空间在C#已经学到过了，所以很好理解。如果是以C#的方式去理解的话，那它单纯就是将函数库引入到项目代码中。而如果是C/C++，那么就有区别了：
2 . C/C++是使用头文件的预处理指令<code>#include</code>将函数库引入到项目中，但有些它里函数库里可能也包含了命名空间，当存引入多个函数库时，可能会存在重名的函数，那么就需要使用命名空间将其归类，以免重名冲突。
3 . 这里就不演示了，上面头文件的演示可以再参考一下。</p>
<h2>自定义头文件</h2>
<blockquote>
<p>要想最深入的了解到头文件，可以实践操作一下，自定义一个头文件。</p>
</blockquote>
<p>1 . 头文件是允许开发者根据自己的需求自定义的。
2 . 它通常是一个后缀为<code>.h</code>的文件。
3 . 下面我们来创建一个头文件，在里面写一个加法运算的全局函数，我们将其命名为：<code>Basen</code></p>
<pre><code>namespace Basen
{
	void add(int a, int b)
    {
		int addafter = a + b;
		printf("计算结果为：%d", addafter);
    }
}
</code></pre>
<p>4 . 接下来，我们将这个自定义的头文件使用预处理指令将其引入到项目中：<code>#include "test.h"</code>
5 . 最后将命名空间引入：<code>using namespace Basen;</code>
6 . 这样我们就可以直接使用自定义的头文件了。</p>
<pre><code>#include &lt;iostream&gt;
#include "test.h"

using namespace std;
using namespace Basen;

int main()
{
	int a = 10;
	int b = 7;
	add(a, b);
}
</code></pre>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_cpp1_1.png" alt="" /></p>
<h2>补充</h2>
<blockquote>
<p>这里对上稍微做出一些补充</p>
</blockquote>
<p>1 . 首先，头文件的，它相当于直接将代码复制到项目中了。
2 . 头文件并没有被直接运行，而是被<code>#include</code>包含（复制）到源文件中，处于预处理阶段。</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>JavaScript event事件对象</title>
    <link href="https://mizuki.mysqil.com/posts/javascript-dom-event%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/javascript-dom-event%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/</id>
    <published>2024-08-09T22:35:50.000Z</published>
    <updated>2024-08-09T22:35:50.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>事件对象</h2>
<p>1 . JavaScript 中，事件对象是一个特殊的对象，它包含了与当前事件相关的所有信息和方法。每当一个事件被触发时，这个事件对象就会被创建并传递给事件处理函数。
2 . 通过事件对象，我们可以更加精确的获得到当前事件的详细信息，也可以通过对象的方法做出一些事件处理操作。
3 . 事件对象在事件发生时就会被创建，并传递给事件处理函数，JavaScript中用<code>event</code>来表示这个事件对象。</p>
<h2>常用属性</h2>
<blockquote>
<p><code>event.type</code>：返回当前 Event 对象表示的事件的名称
<code>event.target</code>：	返回触发此事件的元素（事件的目标节点）
<code>event.currentTarget</code>：返回其事件监听器触发该事件的元素
<code>event.bubbles</code>：返回布尔值，指示事件是否是起泡事件类型</p>
</blockquote>
<p>1 . 我们可以将它们输出一下，实例看看四个分别起到什么样的作用：</p>
<pre><code>&lt;body&gt;
    &lt;input name="main" type="button" value="按钮"&gt;
&lt;/body&gt;
&lt;script&gt;
    let a = document.getElementsByName("main")[0]
    a.addEventListener("click", Object, false)

function Object(event)
{
    console.log(event.type)
    console.log(event.target)
    console.log(event.currentTarget)
    console.log(event.bubbles)
}
&lt;/script&gt;
</code></pre>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_dom3_1.png" alt="" /></p>
<p>2 . 可以看到，四个属性的返回值最终被输出出来，type属性返回的是事件触发的类型。target返回的是触发该事件的元素。currentTarget返回的值似乎和target的一样，但前者返回的的是事件处理函数正在其上执行的那个元素，也有一定的区别。最后是bubbles，它返回的是一个布尔值，即是否起到冒泡事件类型。</p>
<p>4 .<strong>这里有个误区需要注意一下</strong>，就在这个DOM2级事件的方法中，<code>addEventListener("click", Object, false)</code>，监听器仅仅只是在引用函数并立即执行，而不是调用函数，所以它不能直接传参，也无法传入event对象。如果想直接往监听器中的函数传参，可以用到匿名函数，监听器会在内部直接执行，而无需引用。正确的写法是这样的：</p>
<pre><code>let a = document.getElementsByName("main")[0]
a.addEventListener("click", function(event){
    console.log(event.type)
    console.log(event.target)
    console.log(event.currentTarget)
    console.log(event.bubbles)
}, false)
</code></pre>
<h2>对象方法</h2>
<p>1.JavaScript的事件对象中也提供了几种常用的方法，用于处理事件。</p>
<blockquote>
<p><code>event.preventDefault()</code>：用于阻止浏览器对当前事件的默认行为
<code>event.composedPath()</code>：返回一个包含事件在其中传播的所有元素的数组
<code>event.stopImmediatePropagation()</code>：阻止在同一元素上注册的其他任何事件监听器被调用。</p>
</blockquote>
<p>2 . 这里我们演示看看三个方法的效果。</p>
<pre><code>&lt;a href="https://www.bilibili.com/"&gt;点击跳转&lt;/a&gt;
</code></pre>
<p>3 . 在下列代码中，我们设置了一个监听器，当触发<code>&lt;a&gt;</code>标签时，按照默认情况下页面是会跳转到哔哩哔哩的，但是我们在事件处理中使用对象方法<code>preventDefault()</code>将这默认行为给阻止了。
4 . 另外是<code>composedPath()</code>方法，当<code>&lt;a&gt;</code>标签事件触发时，事件冒泡会进行传播给每一个包含它的元素，这一方法可以将这些被波及到的元素返回成一个数组。
5 . 最后是<code>stopImmediatePropagation()</code>方法，这一方法用于解决：当存在两个或更多以同一个节点触为事件触发的监听器时，用于阻止其他的监听器引用函数。在代码中可以看到，存在着另一个监听器，且引用的函数为<code>AotherListener</code>，<code> function(event)</code>将会阻止这一监听器的函数行为，但前提是，指定的监听器一定要在另一个监听器的前面，否则会被覆盖。</p>
<pre><code>let a = document.getElementsByTagName("a")[0]
   
a.addEventListener("click", function(event){
    event.preventDefault()   // 阻止当前事件的默认行为
    console.log("已阻止页面跳转")
    let array = event.composedPath()  //返回事件传播的所有元素的数组。
    console.log(array)
    event.stopImmediatePropagation()  //阻止其他同一元素事件的监听器执行
}, false)

a.addEventListener("click", AotherListener,false)

function AotherListener()
{
    console.log("Hello World")
}
</code></pre>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_dom3_2.png" alt="" /></p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>JavaScript event事件</title>
    <link href="https://mizuki.mysqil.com/posts/javascript-dom-event%E4%BA%8B%E4%BB%B6/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/javascript-dom-event%E4%BA%8B%E4%BB%B6/</id>
    <published>2024-08-08T22:32:02.000Z</published>
    <updated>2024-08-08T22:32:02.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>事件</h2>
<p>在JavaScript中，事件指的是网页上的<code>用户行为</code>或<code>浏览器行为</code>，例如：点击按钮，提交表单，页面完成加载，鼠标点击，键盘输入等。事件处理是 JavaScript 中非常重要的一部分，我们可以通过监听这些事件以此来触发一些预订好的效果。</p>
<blockquote>
<p>当在 DOM 元素上发生事件时，浏览器会创建一个 Event 对象的实例，并触发绑定到该元素上相应的事件处理函数。这个 Event 对象作为参数传递给事件处理函数，使得开发者能够访问事件的相关信息并对事件做出响应。</p>
</blockquote>
<h2>事件处理</h2>
<p>1 . 事件处理指的是当事件被触发时，应该如何处理这些事件。
2 . 举个栗子：当我们进入一个网站时，并且页面完成加载，这就触发了一个事件，在事件处理上，网站可以给用户一个欢迎弹窗，或者当我们输入密码，密码输入错误时，提示密码输入错误。这些都是对事件的处理。</p>
<h2>DOM事件处理方法</h2>
<blockquote>
<p>JavaScript中常用的事件处理方法有三种，分别是DOM0，DOM2，DOM3。</p>
</blockquote>
<h3>DOM0级事件</h3>
<p>1 . DOM0级事件是在Web开发中逐渐形成的，而并非W3C规定的，但却在开发中获得了广泛的应用。
2 . DOM0级事件的原理是：通过直接在HTML元素的事件onclick属性上赋值JavaScript函数或在JavaScript中将函数赋值给DOM元素的事件属性来达到处理事件的效果。
3 . 这种方法较为直观易懂，也存在着一定的不足，当事件被触发时，它无法做到多种处理的效果。</p>
<pre><code>//方式1
&lt;input bottom type="button" value="点击一下"&gt;

&lt;script&gt;
// 方式2
let a = document.getElementsByTagName("input")[0].onclick = chufa
function chufa()
{
    console.log("点击事件")
}
&lt;/script&gt;
</code></pre>
<h3>DOM2级事件</h3>
<p>1 . DOM2是由W3C组织规定的一个标准，它加入了<code>addEventListener()</code>和<code>removeEventListener()</code>方法，前者是添加一个事件的监听器（我们直接称它为“监听器”，后者顾名思义就是删除事件了，但这里我们主要讲一下<code>addEventListener()</code>方法
2 . 它的工作原理是：将指定的监听器注册到 EventTarget 上，当该对象触发指定的事件时，指定的回调函数就会被执行
3 . 这个方法允许您指定在特定类型的事件触发时应该调用哪个函数，这样便提供了更丰富的事件处理能力。
4 . addEventListener(type, listener, useCapture)中含有三个参数位，解释如下：</p>
<ul>
<li><code>type</code>：事件的名称（click，mousemove，load等）</li>
<li><code>listener</code>：处理事件的函数</li>
<li><code>useCapture</code>：用于控制事件的捕获或冒泡阶段（布尔类型）</li>
</ul>
<pre><code> &lt;input type="button"  value="点击一下"&gt;

&lt;script&gt;

let a = document.getElementsByTagName("input")[0]
a.addEventListener("click" , chufa, false)

function chufa()
{
    console.log("点击事件")
}    
&lt;/script&gt;
</code></pre>
<h3>DOM3级事件</h3>
<p>1 . DOM3在DOM0和DOM2的基础上新增了一些事件类型，例如：鼠标事件，键盘事件，滚轮事件等等。
2 . 每一类事件类型的都比较多，这里只讲一下<code>鼠标事件</code>和<code>键盘事件</code>的一些常用事件类型</p>
<table>
<thead>
<tr>
<th>鼠标事件</th>
<th>作用</th>
<th>键盘事件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>dblclick</td>
<td>双击事件</td>
<td>keyCode</td>
<td>该属性包含键盘中对应键位的键值</td>
</tr>
<tr>
<td>mousedown</td>
<td>按下鼠标键时触发</td>
<td>target</td>
<td>发生事件的节点</td>
</tr>
<tr>
<td>mouseup</td>
<td>松开鼠标键时触发</td>
<td>srcElement</td>
<td>发生事件的元素</td>
</tr>
<tr>
<td>mousemove</td>
<td>鼠标移动</td>
<td>shiftKey</td>
<td>是否按下Shift键</td>
</tr>
<tr>
<td>mouseover</td>
<td>鼠标移入</td>
<td>ctrlKey</td>
<td>是否按下Ctrl键</td>
</tr>
<tr>
<td>mouseout</td>
<td>鼠标移出</td>
<td>altKey</td>
<td>是否按下Alt键</td>
</tr>
<tr>
<td>mouseenter</td>
<td>鼠标移入</td>
<td>metaKey</td>
<td>是否按下Meta键</td>
</tr>
<tr>
<td>mouseleave</td>
<td>鼠标移出</td>
<td>charCode</td>
<td>该属性包含键盘中对应键位的Unicode编码</td>
</tr>
</tbody>
</table>
<h2>事件</h2>
<p>在JavaScript中，事件指的是网页上的<code>用户行为</code>或<code>浏览器行为</code>，例如：点击按钮，提交表单，页面完成加载，鼠标点击，键盘输入等。事件处理是 JavaScript 中非常重要的一部分，我们可以通过监听这些事件以此来触发一些预订好的效果。</p>
<h2>事件处理</h2>
<p>1 . 事件处理指的是当事件被触发时，应该如何处理这些事件。
2 . 举个栗子：当我们进入一个网站时，并且页面完成加载，这就触发了一个事件，在事件处理上，网站可以给用户一个欢迎弹窗，或者当我们输入密码，密码输入错误时，提示密码输入错误。这些都是对事件的处理。</p>
<h2>DOM事件处理方法</h2>
<blockquote>
<p>JavaScript中常用的事件处理方法有三种，分别是DOM0，DOM2，DOM3。</p>
</blockquote>
<h3>DOM0级事件</h3>
<p>1 . DOM0级事件是在Web开发中逐渐形成的，而并非W3C规定的，但却在开发中获得了广泛的应用。
2 . DOM0级事件的原理是：通过直接在HTML元素的事件onclick属性上赋值JavaScript函数或在JavaScript中将函数赋值给DOM元素的事件属性来达到处理事件的效果。
3 . 这种方法较为直观易懂，也存在着一定的不足，当事件被触发时，它无法做到多种处理的效果。</p>
<pre><code>//方式1
&lt;input bottom type="button" value="点击一下"&gt;

&lt;script&gt;
// 方式2
let a = document.getElementsByTagName("input")[0].onclick = chufa
function chufa()
{
    console.log("点击事件")
}
&lt;/script&gt;
</code></pre>
<h3>DOM2级事件</h3>
<p>1 . DOM2是由W3C组织规定的一个标准，它加入了<code>addEventListener()</code>和<code>removeEventListener()</code>方法，前者是添加事件，后者顾名思义就是删除事件了，但这里我们主要讲一下<code>addEventListener()</code>方法
2 . 它的工作原理是：将指定的监听器注册到 EventTarget 上，当该对象触发指定的事件时，指定的回调函数就会被执行
3 . 这个方法允许您指定在特定类型的事件触发时应该调用哪个函数，这样便提供了更丰富的事件处理能力。
4 . addEventListener(type, listener, useCapture)中含有三个参数位，解释如下：</p>
<ul>
<li><code>type</code>：事件的名称（click，mousemove，load等）</li>
<li><code>listener</code>：处理事件的函数</li>
<li><code>useCapture</code>：用于控制事件的捕获或冒泡阶段（布尔类型）</li>
</ul>
<pre><code> &lt;input type="button"  value="点击一下"&gt;

&lt;script&gt;

let a = document.getElementsByTagName("input")[0]
a.addEventListener("click" , chufa, false)

function chufa()
{
    console.log("点击事件")
}    
&lt;/script&gt;
</code></pre>
<h3>DOM3级事件</h3>
<p>1 . DOM3在DOM0和DOM2的基础上新增了一些事件类型，例如：鼠标事件，键盘事件，滚轮事件等等。
2 . 每一类事件类型的都比较多，这里只讲一下<code>鼠标事件</code>和<code>键盘事件</code>的一些常用事件类型</p>
<table>
<thead>
<tr>
<th>鼠标事件</th>
<th>作用</th>
<th>键盘事件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>dblclick</td>
<td>双击事件</td>
<td>keyCode</td>
<td>该属性包含键盘中对应键位的键值</td>
</tr>
<tr>
<td>mousedown</td>
<td>按下鼠标键时触发</td>
<td>target</td>
<td>发生事件的节点</td>
</tr>
<tr>
<td>mouseup</td>
<td>松开鼠标键时触发</td>
<td>srcElement</td>
<td>发生事件的元素</td>
</tr>
<tr>
<td>mousemove</td>
<td>鼠标移动</td>
<td>shiftKey</td>
<td>是否按下Shift键</td>
</tr>
<tr>
<td>mouseover</td>
<td>鼠标移入</td>
<td>ctrlKey</td>
<td>是否按下Ctrl键</td>
</tr>
<tr>
<td>mouseout</td>
<td>鼠标移出</td>
<td>altKey</td>
<td>是否按下Alt键</td>
</tr>
<tr>
<td>mouseenter</td>
<td>鼠标移入</td>
<td>metaKey</td>
<td>是否按下Meta键</td>
</tr>
<tr>
<td>mouseleave</td>
<td>鼠标移出</td>
<td>charCode</td>
<td>该属性包含键盘中对应键位的Unicode编码</td>
</tr>
</tbody>
</table>
<p>更多事件类型可参考：<a href="https://www.runoob.com/jsref/dom-obj-event.html">菜鸟教程</a></p>
<p>3 . 我们写段代码做个示例：</p>
<pre><code>#box{
    width: 200px;
    height: 200px;
    background: hotpink;   
}
</code></pre>
<pre><code>&lt;div id="box"&gt;&lt;/div&gt;    
&lt;input name="input" value="输入框"&gt;
</code></pre>
<p>4 . 在这段代码中，我们使用了两个事件处理，并通过Switch开关来，判断正在进行哪种事件，最后在控制台返回事件处理的结果。</p>
<pre><code>
let a = document.querySelector("#box");
let b = document.getElementsByName("input")[0];

// 为鼠标移动添加一个事件监听
a.addEventListener("mousemove", function(event) {
    chufa(event.type);
});

// 为B键添加一个事件监听
b.addEventListener("keydown", function(event) {
    if (event.key === "b") {
        chufa(event.type);
    }
});

function chufa(eventType) {
    switch (eventType) {
        case "mousemove":
            console.log("鼠标正在移动");
            break;
        
        case "keydown":
            console.log("B键被敲击");
            break;
        
        default:
            console.log("Null");
    }
}  
</code></pre>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_dom2_2.png" alt="" /></p>
<p>3 . 我们写段代码做个示例：</p>
<pre><code>#box{
    width: 200px;
    height: 200px;
    background: hotpink;   
}
</code></pre>
<pre><code>&lt;div id="box"&gt;&lt;/div&gt;    
&lt;input name="input" value="输入框"&gt;
</code></pre>
<p>4 . 在这段代码中，我们使用了两个事件处理，并通过Switch开关来，判断正在进行哪种事件，最后在控制台返回事件处理的结果。
5 . <code>event.type</code>是事件对象的属性，当然了这次讲的是事件的处理方法，事件对象在下期会讲到。</p>
<pre><code>
let a = document.querySelector("#box");
let b = document.getElementsByName("input")[0];

// 为鼠标移动添加一个事件监听
a.addEventListener("mousemove", function(event) {
    chufa(event.type);
});

// 为B键添加一个事件监听
b.addEventListener("keydown", function(event) {
    if (event.key === "b") {
        chufa(event.type);
    }
});

function chufa(eventType) {
    switch (eventType) {
        case "mousemove":
            console.log("鼠标正在移动");
            break;
        
        case "keydown":
            console.log("B键被敲击");
            break;
        
        default:
            console.log("Null");
    }
}  
</code></pre>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_dom2_2.png" alt="" /></p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>JavaScript DOM 方法详解</title>
    <link href="https://mizuki.mysqil.com/posts/javascript-dom%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/javascript-dom%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2024-08-05T21:36:11.000Z</published>
    <updated>2024-08-05T21:36:11.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>DOM</h2>
<p>DOM全称（Document Object Model）文档对象模型，一个编程接口，它表示和操作HTML和XML文档。DOM将网页结构化为一个由节点和对象（如元素、属性和文本）组成的树状结构，使得Web文档可以被程序化地访问和修改。<code>当网页被加载时，浏览器会创建页面的文档对象模型</code></p>
<h2>获取元素</h2>
<p>JavaScript提供了一些用于通过DOM获取元素的方法</p>
<blockquote>
<p><code>document.getElementById()</code>: 通过元素的ID获取元素。
<code>document.getElementsByTagName()</code>: 通过标签的名称获取元素集合。
<code>document.getElementsByClassName()</code>: 通过类名获取元素集合。
<code>document.getElementsByName()</code>: 通过name值获取元素集合
<code>document.querySelector()</code>: 根据CSS选择器获取第一个匹配的元素。
<code>document.querySelectorAll()</code>: 根据CSS选择器获取所有匹配的元素集合。</p>
</blockquote>
<p><strong>使用方法</strong></p>
<p>我们以<code>&lt;p&gt;</code>标签为例，使用JS的DOM对象方法对元素进行<code>获取</code>和<code>修改</code></p>
<pre><code>&lt;p&gt;段落1&lt;/p&gt;
&lt;p id="a"&gt;段落2&lt;/p&gt;
&lt;p class="b"&gt;段落3&lt;/p&gt;
&lt;p id="c"&gt;段落4&lt;/p&gt;
&lt;p class="d"&gt;段落5&lt;/p&gt;

</code></pre>
<p>1 . 首先是<code>getElementsByTagName()</code>方法，该方法可以通过标签名获取对应的元素，当存在多个相同标签，则返回的<code>HTMLCollection</code>或<code>NodeList</code>，它是一个类似数组的对象，包含了所有匹配的元素，如果要精确选择，可以通过<code>[]</code>索引定位。</p>
<p>2 . <code>getElementById()</code>方法，用于通过标签的ID获取元素，因为ID是唯一的，所以使用该方法获取元素会更加准确。</p>
<p>3 . <code>getElementsByClassName()</code>方法，通过类名获取元素，不同ID的是，类名可以重复，返回的是HTMLCollection对象，所以必须再通过<code>[]</code>索引来精确到目标元素。</p>
<p>4 . <code>getElementsByName()</code>方法，通过name值获取元素集合，一般用于表单元素，返回的是<code>NodeList</code>，同样需要索引精确目标。</p>
<p>5 .<code>querySelector()</code>方法是在H5后新增的方法，它会比getelementby更加高效，通过该方法，可以获取到任何指定的标签元素，可以是id，class，也可以是类名。但要注意的是，当存在多个指定的标签，则默认选择第一个元素对象，例如指定<code>&lt;p&gt;</code>标签，若存在多个<code>&lt;p&gt;</code>标签，它会默认选择第一个。</p>
<p>6 . <code>querySelectorAll()</code>方法，和上面的一样，它会返回是HTMLCollection对象，可以通过<code>[]</code>所以精确目标</p>
<pre><code>document.getElementsByTagName("p")[0].innerHTML = '芝士雪豹'

document.getElementById("a").innerHTML = "雪豹闭嘴"

document.getElementsByClassName("b")[0].innerHTML = "妈妈省的"

document.getElementsByName("c")[0].innerHTML = "因为他善"

document.querySelector("#d").innerHTML = "演的什么玩意这是"

document.querySelectorAll("p")[5].innerHTML = "我沉沦几回只因你倾城的美"

</code></pre>
<p>7 . 最终运行的结果是，<code>&lt;p&gt;</code>标签中的内容都被更改了，这就是通过DOM对象方法获取标签，再修改内容实现。</p>
<p><img src="https://sh.jsdmirror.com/gh/Almango/Blog_imgbed@main/post/post_dom_1.png" alt="" /></p>
<h2>获取和修改元素内容</h2>
<blockquote>
<p><code>innerHTML</code>：用于获取或设置元素的HTML标记内容
<code>innerText</code>：用于获取或设置元素的可见文本内容（不包含HTML标记）
<code>textContent</code>：用于获取或设置元素内部的<code>纯文本内容</code></p>
</blockquote>
<p><strong>使用方法：</strong>
1 . 在这三个方法中，都有着各自的特征，接下来一一解答：
2 . <code>innerHTML</code>方法，用于获取或设置元素的HTML内容，当一个元素存在子节点或更多时，它可以获取和修改这些节点。
3 . <code>innerText</code>方法，用于获取或设置元素的可见文本内容，和innerHTML不同的是，它仅能获取和修改元素中可见的文本，如果文本是隐藏的，则不会返回该文本，最后它不包含HTML标记。
4 . <code>textContent</code>方法，用于获取或设置元素内部的纯文本内容，它只能单纯的获取和修改元素中的所有文本内容，不仅如此，它还能够获取到隐藏的文本内容，包括那些通过CSS隐藏的文本。</p>
<pre><code>&lt;div id="innerHTML"&gt;
    &lt;ul&gt;
        &lt;li&gt;0帧起手&lt;/li&gt;
        &lt;li&gt;神金&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;T0战士&lt;/p&gt;
&lt;/div&gt;

&lt;div id="innerText"&gt;
    &lt;ul&gt;
        &lt;li&gt;人机&lt;/li&gt;
        &lt;li&gt;入机&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;

&lt;div id="textContent"&gt;
    &lt;ul&gt;
        &lt;li&gt;逆马&lt;/li&gt;
        &lt;li&gt;逆蝶&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;

</code></pre>
<p>5 . 这里我们分开执行，区别更显而易见。
6 . 可见，我们可以使用<code>innerHTML </code>方法直接获取到元素内的所以HTML标签节点，修改时也可以通过直接输入标签代码来修改节点。在<code>innerText</code>方法示例中，它可以获取标签中的所有可见文本，也可以直接修改该可见文本，最后在<code>textContent</code>方法中，它仅单纯获取和修改所有纯文本（包括隐藏文本）</p>
<pre><code>//innerHTML
let a = document.querySelector("#innerHTML").innerHTML // 获取元素
console.log(a)    // 返回获取的元素内容
document.getElementsByTagName("p")[0].innerHTML = "我想要你UZI跳枪教程" //修改元素内容

//innerText
let b = document.querySelector("#innerText").innerText // 获取元素
console.log(b)    // 返回获取的元素内容
document.getElementsByTagName("li")[3].innerText = "不是你配吗？" //修改文本内容    

//textContent
let c = document.querySelector("#textContent").textContent // 获取元素    
console.log(c)    // 返回获取的元素内容
document.getElementsByTagName("li")[5].textContent = "我是嫩蝶" //修改文本内容    

</code></pre>
<p><img src="https://sh.jsdmirror.com/gh/Almango/Blog_imgbed@main/post/post_dom_3.png" alt="" /></p>
<h2>创建元素</h2>
<p><code>document.createElement()</code> - 用于创建一个新的元素。</p>
<p><strong>使用方法：</strong>
1 . 可以使用该方法创建一个指定的元素，<strong>注意</strong>：这仅仅只是创建一个元素，后续还需要使用插入方法将创建好的元素插入到HTML节点中。
2 . 例如我们可以创建一个<code>&lt;li&gt;</code>列表标签，示例如下：</p>
<pre><code>document.createElement("li")  // 创建一个li标签
document.createElement("div")  // 创建一个div标签
document.createElement("img")    // 创建一个p标签
</code></pre>
<h2>追加 &amp; 插入元素</h2>
<blockquote>
<p><code>document.appendChild()</code>：将元素<code>追加</code>到某个节点的子节点中。</p>
</blockquote>
<blockquote>
<p><code>document.insertBefore( , )</code>：将元素<code>插入</code>到某个节点的子节点前面。</p>
</blockquote>
<p><strong>使用方法：</strong></p>
<p>1 . <code>appendChild()</code>方法主要是将创建好的元素追加到某个节点的子节点后面，追加顾名思义就是按顺序排在后面，例如在节点<code>div</code>中已经存在3个子节点，那么新追加的元素索引值则为</p>
<p>2 . <code>insertBefore( , )</code>方法是将创建好的元素插入到某个节点的子节点前面，和追加不同的是，它可以指定插入的位置。它存在两个传参位，前者是将要插入的元素，后者是需要插入的子节点位置。</p>
<p>3 . 看个示例便一目了然：</p>
<p>4 . <strong>示例中</strong>，我们先创建一个项目列表<code>&lt;ul&gt;</code>，在里面创建一个<code>&lt;li&gt;</code>列表，接着我们将使用两个方法往项目列表中追加和插入新元素。</p>
<pre><code>&lt;ul id="bq"&gt;
    &lt;li&gt;真的是你呀~&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>5 . js我们需要先创建两个列表元素来分别实现<code>追加</code>和<code>插入</code>，因为创建一个元素，只能进行一个添加操作。随后我们使用<code>textContent</code>方法往列表中设置文本内容。</p>
<p>6 .  分别获取到要追加的节点和需要插入的子节点，这样即可直接使用两个方法追加和插入元素。</p>
<pre><code>let a = document.createElement("li")   // 创建li元素
let i = document.createElement("li")   // 创建li元素

a.textContent = "你干嘛，哎哟~"     // 设置li元素文本内容
i.textContent = "鸡你太美"       // 设置li元素文本内容

let divs = document.querySelector("#bq")  // 获取节点
let child = document.getElementsByTagName("li")[0]  // 获取子节点

divs.appendChild(a)
divs.insertBefore(i, child)

</code></pre>
<p>7 . 运行结果可以看到，<code>你干嘛，哎哟~</code>被追加到了最下方，<code>鸡你太美</code>被插入到了<code>真的是你呀~</code>前面，这就是<code>appendChild()</code>和<code>insertBefore()</code>两个方法使用方法。</p>
<p><img src="https://sh.jsdmirror.com/gh/Almango/Blog_imgbed@main/post/post_dom_2.png" alt="" /></p>
<h2>移除元素</h2>
<blockquote>
<p><code>document.removeChild()</code>：用于移除节点中的子节点</p>
</blockquote>
<p><strong>使用方法：</strong></p>
<p>1 . <code>removeChild()</code>方法，通过指定子节点来达到移除节点的效果。</p>
<pre><code>&lt;ul id="list"&gt;
    &lt;li&gt;刚满18岁&lt;/li&gt;
    &lt;li&gt;我让你永远18岁&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<pre><code>let a = document.querySelector("#list")  // 获取节点
a.removeChild(a.firstlementChild)   // 移除第一个子节点
</code></pre>
<h2>修改元素属性</h2>
<blockquote>
<p><code>document.getAttribute()</code>：获取元素的属性值
<code>document.setAttribute( , )</code>：用于修改元素的属性值</p>
</blockquote>
<p><strong>使用方法：</strong></p>
<p>1 . <code>document.getAttribute()</code>该方法用于获取元素的属性值，如（type，id，class，title）等，只需在传参位传入属性即可返回属性值。
2 . <code>document.setAttribute( , )</code>：使用该方法，可以修改元素的属性，方法内含两个传参位，前者为<code>属性</code>，后者为<code>属性值</code>。</p>
<pre><code>&lt;div id="box"&gt;
    &lt;form&gt;
        &lt;input name="inputtext"  value="输入框"&gt;
    &lt;/form&gt;
    &lt;p id="sy"&gt;UZI跳枪已经失传&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>3 . 代码不必过多解释了，这里演示了如何获取<code>&lt;input&gt;</code>标签的value值，以及修改<code>&lt;input&gt;</code>的type值和<code>&lt;p&gt;</code>标签的id值，最返回了整个修改后的HTML标记。一目了然。</p>
<pre><code>// 获取input的value属性值
let a = document.getElementsByName("inputtext")[0].getAttribute("value")
console.log(a)
// 修改input的Type属性值
let b = document.getElementsByName("inputtext")[0]
b.setAttribute("type","submit")

//修改p的id属性值
let c = document.getElementsByTagName("p")[0]
c.setAttribute("id", "uzi")

// 输出修改后的元素
let d = document.querySelector("#box").innerHTML 
console.log(d)
</code></pre>
<p><img src="https://sh.jsdmirror.com/gh/Almango/Blog_imgbed@main/post/post_dom_4.jpg" alt="" /></p>
<h2>修改元素样式</h2>
<blockquote>
<p><code>document.style</code>：修改元素样式</p>
</blockquote>
<p><strong>使用方法：</strong></p>
<p>1 . 使用其实很简单，看示例：
2 . 在style.后面加上样式属性，并为其设定值即可。
3 . 当然了，这个方法里的样式名可能和css中的不太一样。</p>
<pre><code>&lt;p id="error"&gt;错的不是我，是这个世界&lt;/p&gt;
</code></pre>
<pre><code>document.querySelector("#error").style.color = "blue"
document.querySelector("#error").style.fontSize = "25px"
document.querySelector("#error").style.background = "yellow"
</code></pre>
<p><img src="https://sh.jsdmirror.com/gh/Almango/Blog_imgbed@main/post/post_dom_5.png" alt="" /></p>
<p>&lt;hr&gt;</p>
<h2>补充</h2>
<blockquote>
<p>若存在问题或遗漏，后续会进行补充……</p>
</blockquote>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>经典算法题</title>
    <link href="https://mizuki.mysqil.com/posts/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98/</id>
    <published>2024-08-03T10:10:10.000Z</published>
    <updated>2024-08-03T10:10:10.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>排序</h2>
<h3>冒泡排序</h3>
<blockquote>
<p>1 . 冒泡排序（Bubble Sort）也是一种简单直观的排序算法。
2 . 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。
3 . 走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
4 . 这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。</p>
</blockquote>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_algo_bubbleSort.gif" alt="" /></p>
<p><strong>代码分析</strong></p>
<pre><code>using System;
namespace almango
{
	class Project
	{
		static void Main(string[] args)
		{
			int[] array = new int[]{2, 5, 3, 6, 1, 8, 4};
			int temp;

			for(int i = 0; i &lt; array.Length - 1; i ++)  // 0
			{
				for(int a = 0; a &lt; array.Length - 1; a ++) //   a &lt; 5
				{
					if(array[a] &gt; array[a + 1])
					{
						temp = array[a + 1];
						array[a + 1] = array[a];
						array[a] = temp;
					}
				}
			}
			Console.WriteLine("排序后结果：" + string.Join(", ", array));
		}
	}
}
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="算法"></category>
  </entry>
  <entry>
    <title>《你的名字》2024重映观后感：不留人生遗憾</title>
    <link href="https://mizuki.mysqil.com/posts/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%972024%E9%87%8D%E6%98%A0%E8%A7%82%E5%90%8E%E6%84%9F%E4%B8%8D%E7%BB%99%E4%BA%BA%E7%94%9F%E7%95%99%E4%B8%8B%E9%81%97%E6%86%BE/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%972024%E9%87%8D%E6%98%A0%E8%A7%82%E5%90%8E%E6%84%9F%E4%B8%8D%E7%BB%99%E4%BA%BA%E7%94%9F%E7%95%99%E4%B8%8B%E9%81%97%E6%86%BE/</id>
    <published>2024-08-02T11:00:30.000Z</published>
    <updated>2024-08-02T11:00:30.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h3>《你的名字》在中国大陆于2016年12月2日上映，2024年7月19日重映。</h3>
<blockquote>
<p>8月1日那天晚上，去电影院观看了重映的《你的名字》，弥补了从小学至今为止的遗憾。</p>
</blockquote>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_ndmz_1.jpg" alt="" /></p>
<blockquote>
<p>&lt;p style="color: #f819ff; "&gt;为什么要特地讲一部电影的观后感？那是因为我和它有过一个意味深长的故事，我也为此将它视为我的挚爱……&lt;/p&gt;</p>
</blockquote>
<p>&lt;/hr&gt;</p>
<h3>2016年的那天</h3>
<p>1 . 2016年《你的名字》正式上映的那天，我还是一个六年级的小学生。
2 . 虽然我最早是在2016年接触这部电影，也算是我接触到的第一部映画形式的电影了，但那年因为一个小小的事情……
3 . 我记得很清楚，我们的语文老师为了给我们活动结束放松一下，特地用一体机给我们放电影看。由于《你的名字》过于火爆，在很多平台都霸榜了，所以我们的语文老师也是毫无悬念的选择了这部电影。
4 . 看过这部电影的都知道，电影开头多少有点少儿不宜的画面，这也就导致电影刚放没多久就被老师及时换掉了，确实有点扫兴……</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_ndmz_2.png" alt="" /></p>
<p>5 . 虽然那个时候觉得换掉了也没什么，估计我那幼稚的心灵也看不懂。</p>
<h3>2019年的那天</h3>
<p>1 . 到了2019年，我正读初二，应该是放暑假还是春节期间。
2 . 我无意间看到了《你的名字》视频剪辑，最终迫于好奇我打开这部电影的原集，也算是为了弥补一下小学时的遗憾吧。
3 . 在看完这部电影后，我情绪波动很大，虽然不至于到哭的地步，但却是久久不能释怀……
4 . 《你的名字》不论是画风，背景音乐，特别是剧情：从三叶和泷交换身体开始的剧情就十分引人入胜，时空碰撞让两人再次以拯救小镇为主线，八年未见，让剧情结尾的相遇，使得我心潮澎湃，无法自拔。影片体现了命运的安排和特定的空间相遇所产生恋情的强大力量，体现了面对灾难迎难而上的集体精神和为他品质，体现了一个乡村少女对城市生活的渴望，拐角遇到爱……种种缩印和细节，这无非是现实生活的写照。剧情中有一句最令我忘不了的话：“<code>あなたの名前さえ覚えていれば、世界のどこにいても必ずあなたに会いに行きますか</code>”（不管你在世界的哪个地方，我一定会去见你）</p>
<h3>2024年的昨天</h3>
<p>1 . 尽管在此之前我也看过很多遍了，但却从来没有在电影院看过，我也从来没去过电影院。
2 . 很巧的是，今年的7月19日《你的名字》在大陆重映了，所以我不想错过这次机会，也不想给自己的人生留下遗憾……
3 . 8月1日，在我的三顾茅庐劝说下，终于把“王子”拉过来了，真的是比诸葛亮还难劝啊。也亏他多少是个二次元，班上没几个喜欢看日漫的了。</p>
<p>4 . 我们在平台上买好了票，18:00正式开播，第一次来电影院哈哈，之前单纯是认为能在线上看，就没必要来电影院，但这次不一样，这次是<code>为了致敬我最真挚的热爱</code>。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_ndmz_4.jpg" alt="" /></p>
<p>5 . 电影开播时，我总是禁不住拍照，想把这美好的时光记录下来，《你的名字》的每一帧都是一个完美的风景线啊。</p>
<p>6 . 和从前一样，在电站和陨石爆炸的一瞬间，我的心也跟着炸裂，用眼泪不受情绪的管控，准确来说是情绪不受我的管控。画面剧情给我的冲击力和情绪波动，让我一帧都舍不得错过。</p>
<p>7 . 每次看完这部电影，我都会有新的体会，但我依旧<code>我用自己的方式来诠释了这部电影对我意义</code>，这样挺好的，愿热爱永恒持续下去……</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_ndmz_5.jpg" alt="" /></p>
<p>&lt;hr&gt;</p>
<p>1 .<code>「大事な人。忘れちゃダメな人。忘れたくなかった人。誰、誰……きみの名前は……！」</code>
重要的人，不能忘记的人，不想忘记的人。你，是谁？你的名字是？！</p>
<p>2 .<code>「ワシらの作る組紐もせやから神さまの技、時間の流れのそのものを顕しとる。寄り集まって形を作り、捻れて絡まって、時には戻って、途切れ、またつながり。それが結び。それが時間。」</code></p>
<p>我们编织的结绳也是神的力量，显示了时间的流转。聚在一起，成型，扭曲，缠绕，有时又还原，断裂，再次连接，这就是结，这就是时间。</p>
<p>3 .<code>「言おうと思ったんだ。お前が世界のどこにいても、俺が必ず、もう一度逢いに行くって。」</code>
我要告诉你，不管你在世界的哪个地方，我们终将再次相逢。</p>
<p>4 .<code>「来世は东京のイケメン男子にしてください！」</code>
来世请让我做东京的帅哥吧！</p>
<p>5 .<code>「君の前前前世から仆は 君を探しはじめたよ」 </code>
从你的前前前世开始，我就在寻找你的踪迹。</p>
<p>6 .<code>「愛し方さえも、君の匂いがした、歩き方さえも」 </code>
就连表达爱的方式，也弥漫着你的气息，就连走路的方式，也萦绕着你的笑声</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="闲谈"></category>
  </entry>
  <entry>
    <title>TypeScript_环境部署【2】</title>
    <link href="https://mizuki.mysqil.com/posts/typescript_%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B22/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/typescript_%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B22/</id>
    <published>2024-07-30T12:00:11.000Z</published>
    <updated>2024-07-30T12:00:11.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h3>安装</h3>
<h4>安装Node.js</h4>
<blockquote>
<p>Node.js 是一个开源的、跨平台的 JavaScript 运行时环境。</p>
</blockquote>
<p>1 .TypeScript 代码本身不能直接在浏览器中运行，它需要被编译成 JavaScript 代码。Node.js 提供了一个运行时环境，可以执行 JavaScript 代码，因此可以用于运行编译后的 TypeScript 代码。同时它还提供了丰富的工具和库，使得 TypeScript 的开发更加方便和高效。</p>
<p>2 . 官网下载：https://nodejs.cn/</p>
<p>3 . 检查是否安装成功</p>
<pre><code>node --version
</code></pre>
<h4>安装编译器</h4>
<blockquote>
<p>TypeScript一种编译型语言，无法直接在浏览器中运行，需要先将其编译为JavaScript代码才可以，所以我们需要先安装ts编译器<code>tsc</code>。</p>
</blockquote>
<p>1 . 在终端输入以下命令：</p>
<pre><code>npm install -g typescript
</code></pre>
<p>2 . 检查是否成功</p>
<pre><code>tsc -v
</code></pre>
<h3>第一个程序</h3>
<blockquote>
<p>安装完成后，可以试着写一串ts代码</p>
</blockquote>
<p>1 . 代码写完后，保存，例如文件名称为：<code>index.ts</code>
2 . 接下来进行编译
3 . 在终端输入<code>tsc index.ts</code>即可将ts代码编译为js代码。
4 . 编译后的Javascript是可以直接在浏览器中运行的。</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>TypeScript_初始【1】</title>
    <link href="https://mizuki.mysqil.com/posts/typescript_%E5%88%9D%E8%AF%861/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/typescript_%E5%88%9D%E8%AF%861/</id>
    <published>2024-07-30T11:30:12.000Z</published>
    <updated>2024-07-30T11:30:12.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h3>介绍</h3>
<p>1 . <strong>TypeScript</strong>是由微软开发的一种开源编程语言，它是JavaScript的一个<code>严格超集</code>，这意味着任何有效的JavaScript代码也是有效的TypeScript代码。TypeScript的主要目标是开发大型应用程序，提供JavaScript所不具备的类型安全和易于维护的特性。</p>
<p>2 . 同时TypeScript是一种静态语言，TypeScript通过静态类型系统，允许开发者在编译时就确定变量的类型，从而减少运行时错误。</p>
<h3>TS与JS的关系</h3>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_ts_1.png" alt="" /></p>
<blockquote>
<p>TypeScript 是 JavaScript 的<code>超集</code>，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。</p>
</blockquote>
<p><code>何为超集？你可以理解为Ts是一个全新的JavaScript，它在保留了JavaScript语法的同时还扩展了更多功能，性能和安全性也有很大的升级。</code></p>
<p>1 . TypeScript 与 JavaScript 有着不同寻常的关系。TypeScript 提供了 JavaScript 的所有功能，并在这些功能之上添加了一层： TypeScript 的类型系统。</p>
<p>2 . 例如，JavaScript 提供了诸如 string 和 number 这样的原始类型，但它不检查你在赋值时与类型是否匹配。TypeScript 提供了这样的功能。</p>
<p>3 . 这意味着你现有的运行良好的 JavaScript 代码也是 TypeScript 代码。TypeScript 的主要好处是，它可以检查代码中的意外行为，从而降低出现错误的机会。</p>
<h3>为什么选择TypeScript？</h3>
<p><strong>类型安全</strong>
类型安全是TypeScript最大的卖点之一。在JavaScript中，变量的类型可以在任何时候改变，这可能导致难以追踪的错误。TypeScript通过静态类型系统，允许开发者在编译时就确定变量的类型，从而减少运行时错误。</p>
<p><strong>面向对象编程</strong>
TypeScript支持类、接口、继承等面向对象编程（OOP）特性，这使得代码更加模块化和可重用。开发者可以定义接口来确保对象符合预期的结构，使用类来封装数据和行为。</p>
<p><strong>工具支持</strong>
TypeScript拥有强大的工具链支持，包括Visual Studio Code、WebStorm等集成开发环境（IDE），它们提供了代码高亮、智能提示、自动补全和重构工具，极大地提高了开发效率。</p>
<p><strong>编译时检查</strong></p>
<p>TypeScript代码在运行前需要被编译成JavaScript，编译过程中会进行类型检查和语法检查，这意味着，当可以正常编译时，编译成的Javascript代码一定是合法的。若语法有错，则无法通过编译，这有助于提前发现潜在的错误。</p>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_ts_2.png" alt="" /></p>
<p><strong>兼容性</strong>
TypeScript与JavaScript完全兼容，这意味着开发者可以逐步将现有项目迁移到TypeScript，或者在新项目中混合使用JavaScript和TypeScript代码。</p>
<h3>TypeScript的应用</h3>
<p><strong>前端开发</strong>
在前端开发中，TypeScript常与React、Angular或Vue等现代JavaScript框架结合使用。这些框架提供了丰富的组件和工具，与TypeScript结合可以进一步增强应用程序的可维护性和可扩展性。</p>
<p><strong>Node.js后端开发</strong>**
TypeScript也适用于Node.js后端开发。通过使用TypeScript，开发者可以编写类型安全的服务器端代码，提高后端服务的稳定性和可维护性。</p>
<p><strong>跨平台开发</strong>
TypeScript支持跨平台开发，无论是Web、桌面还是移动应用程序，都可以使用TypeScript来编写代码，然后编译成适用于不同平台的JavaScript代码。</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>PicGo + Github图床搭建</title>
    <link href="https://mizuki.mysqil.com/posts/picgo%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/picgo%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/</id>
    <published>2024-07-28T22:05:02.000Z</published>
    <updated>2024-07-28T22:05:02.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p>图床是一个网络术语，指的是用于存放图片的服务器。用户可以将图片上传到图床服务器，图床服务器会为这些图片生成一个可以公开访问的链接（URL）。这样，用户就可以在网页、博客、论坛等地方通过这个链接引用图片，而不需要将图片文件直接存储在这些地方。</p>
</blockquote>
<p>1 . 我在使用图床之前，我一种是将图片保存在本地，这个方法有很大的不足，就当上传文章的时候，图片也跟着上传了，其次是处理起来很麻烦，每次都要打开本地目录寻找图片，写文章，添加插图的效率十分底下，为此不得不寻找新的方法来提高效率。</p>
<p>2 . 所以：<code>Github + PicGo + jsdelivr</code>，就是一个很不错的选择。
3 . 接下来的话，看看如何搭建这样的图床吧！</p>
<h3>安装PicGo</h3>
<blockquote>
<p>PicGo 是一个用于快速上传图片并获取图片 URL 的工具，它支持多种图床服务，如 GitHub、阿里云 OSS、腾讯云 COS 等。通过 PicGo，用户可以方便地将图片上传到指定的图床，并获取到图片的链接，用于在网页、博客或其他文档中展示图片。</p>
</blockquote>
<p>1 . 需要先下载并安装PicGo。</p>
<p><strong>官网地址</strong>：<a href="https://picgo.github.io/PicGo-Doc/zh/">https://picgo.github.io/PicGo-Doc/zh/</a></p>
<h3>创建Github仓库</h3>
<blockquote>
<p>创建一个仓库用作图床的储存库</p>
</blockquote>
<p>1 . 创建完成成后，打开gihub的设置选项：<code>Settings</code>.
2 . 在侧边栏点击：<code>Developer settings</code>。
3 . 将<code>Personal access tokens</code> 展开，并点击<code>Tokens (Classic)</code>，新建一个tokens，自定义一个秘钥并确认。
4 . 最后将<code>Select scopes</code>勾选框的repo全部勾选上即可。</p>
<p><img src="https://jsd.cdn.zzko.cn/gh/Almango/Blog_imgbed@main/post/post_picgo_1.png" alt="" /></p>
<p>4 . 新建秘钥后，将秘钥复制下来。</p>
<h3>配置PicGo</h3>
<p>1 . 启动PicGo。
2 . 在侧边栏，将<code>图床设置</code>展开，点击Github项。
3 . 在设置选项中：</p>
<ul>
<li>设置仓库名：用户名/仓库名</li>
<li>设定分支名：分支名（main / master）</li>
<li>设定Token：Github创建的秘钥</li>
<li>设定存储路径：仓库里的子目录名称（可选）</li>
<li>设定自定义域名：https://cdn.jsdelivr.net/gh/[用户名]/[仓库名]@main</li>
</ul>
<p><img src="https://jsd.cdn.zzko.cn/gh/Almango/Blog_imgbed%40main/post/post_picgo_2.png" alt="" /></p>
<p>4 . 到这里，PicGo已经配置完成。
5 . 可以正常上传图片。</p>
<h3>说明</h3>
<p>1 . Github被当做图床的储存仓库，通过Token将仓库和PicGo连接起来，可以在PicGo中快速的向仓库中上传图片。
2 . 为了防止Github被DNS污染，这里使用JSDliver来解决此问题。</p>
<blockquote>
<p>jsDelivr是一个免费开源的CDN解决方案，用于帮助开发者和站长。 包含 JavaScript 库、jQuery 插件、CSS 框架、字体等等 Web 上常用的静态资源。</p>
</blockquote>
<p>3 . 虽然起到CDN加速作用，但效果并不显著，若有效果更好的CDN，我会在后面补充到。</p>
<p>4 . 以上就是对整个图床的搭建及其大概说明。</p>
<h3>补充</h3>
<p><strong>若jsdelivr效果差，可以切换成国内的<code>Chinajsdelivr</code></strong></p>
<blockquote>
<p>一个免费面向中国境内外的高速jsdelivr镜像站</p>
</blockquote>
<p>Gitee：<a href="https://github.com/momo54181/Chinajsdelivr">https://github.com/momo54181/Chinajsdelivr</a></p>
<p>Github：<a href="https://github.com/momo54181/Chinajsdelivr">https://github.com/momo54181/Chinajsdelivr</a></p>
<p><strong>使用</strong></p>
<p>只需要把</p>
<p><a href="https://gitee.com/link?target=https%3A%2F%2Fcdn.jsDelivr.net">https://cdn.jsDelivr.net</a></p>
<p>全局替换成</p>
<p><a href="https://gitee.com/link?target=https%3A%2F%2Fjsd.cdn.zzko.cn">https://jsd.cdn.zzko.cn</a> 或者是 <a href="https://gitee.com/link?target=https%3A%2F%2Fcdn.jsdelivr.us">https://cdn.jsdelivr.us</a></p>
<p>可以再加一个判断，如果上方不可达的话</p>
<p><a href="https://gitee.com/link?target=https%3A%2F%2Fcdn.jsdelivr.us">https://cdn.jsdelivr.us</a></p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="图床"></category>
  </entry>
  <entry>
    <title>C语言学习笔记_占位符与输出【4】</title>
    <link href="https://mizuki.mysqil.com/posts/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8D%A0%E4%BD%8D%E7%AC%A64/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8D%A0%E4%BD%8D%E7%AC%A64/</id>
    <published>2024-07-26T11:53:02.000Z</published>
    <updated>2024-07-26T11:53:02.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h3>占位符</h3>
<blockquote>
<p>占位符，也被称作格式化字符串，主要起到格式化输入输出函数，在使用printf()函数时也经常会用到。</p>
</blockquote>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>%i</td>
<td>整数</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%c</td>
<td>字符</td>
</tr>
<tr>
<td>%d</td>
<td>十进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>八进制整数</td>
</tr>
<tr>
<td>%e</td>
<td>科学计数</td>
</tr>
<tr>
<td>%d</td>
<td>格式化整数</td>
</tr>
<tr>
<td>%p</td>
<td>指针</td>
</tr>
</tbody>
</table>
<h3>使用</h3>
<h4>格式化输出</h4>
<blockquote>
<p>通常情况下，占位符会被用在输出函数内，如printf，它不仅可以起到格式化字符的作用，还也可以起到占位的作用。</p>
</blockquote>
<p>1 . printf( ) 用于格式化输出，这也就意味着你不能直接使用，而是需要先先使用占位符来告诉该函数输出哪种类型的值。
2 . 我们可以这样理解：</p>
<pre><code>printf("%", Value)    // printf函数的格式
</code></pre>
<p>3 . 例如：我想输出任意一个数据类型的值，那么正确的方法是这样的：</p>
<pre><code>printf("%i\n", 26);    // 输出整数
printf("%f\n", 2.4);   // 输出浮点数
printf("%e\n", 21212); // 输出科学计数
</code></pre>
<p>输出结果：</p>
<pre><code>26
2.400000
2.400000e+000
</code></pre>
<h4>占位输出</h4>
<p>1 .  当然了，占位符的用法不仅仅是格式化输出，看名字也知道，它也起到<code>占位的作用</code>，其实<strong>它代表的就是Value</strong>。看下面代码便可以理解：</p>
<pre><code>printf("我的年龄是%d\n", 17);  // 占位输出
</code></pre>
<p>输出结果：</p>
<pre><code>我的年龄是17岁
</code></pre>
<p>2 . 从结果也可以看得出来，%d实际上就代替17给输出出来了，其实<code>双引号" "就是是输出的主体内容</code>。</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C语言学习笔记_执行与编译【3】</title>
    <link href="https://mizuki.mysqil.com/posts/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%89%A7%E8%A1%8C%E4%B8%8E%E7%BC%96%E8%AF%913/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%89%A7%E8%A1%8C%E4%B8%8E%E7%BC%96%E8%AF%913/</id>
    <published>2024-07-25T21:11:30.000Z</published>
    <updated>2024-07-25T21:11:30.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h3>第一个程序</h3>
<blockquote>
<p>学习任何一门编程语言，对于我们来说首先要做的事就是输出“Hello World”了。
对于许多程序员来说，成功运行第一个"Hello, World!"程序是一个激励，标志着他们编程旅程的开始。</p>
</blockquote>
<pre><code>#include &lt;stdio.h&gt;
int main()
{
    printf("Hello World\n");
    return 0;
}
</code></pre>
<h3>代码分析</h3>
<p>🍓 <code>#include &lt;stdio.h&gt;</code>：预处理指令，它告诉编译器在编译程序之前包含标准输入输出库stdio.h。这个库提供了输入输出函数的声明，比如printf函数。它也为我们提供了输入和输出的控制台，相当于在运行代码前它能为其做好预处理准备。</p>
<p>🍓 <code>int main()</code>：int为整数类型的返回值类型，main()为<code>程序的入口点</code>，并且main()函数的返回值类型必须是int类型。</p>
<p>🍓 <code>printf()</code>：标准库中的一个函数，用于输出多种类型的值，输出变量时需要使用<code>格式化字符串</code>声明输出类型。</p>
<p>🍓 <code>return</code>：一般情况下用于返回程序的返回值或者状态码，若为0，则表示正常结束。</p>
<h3>执行流程</h3>
<blockquote>
<p>估计很多人会疑惑，在运行程序这一系列操作是如何完成的呢？这就得说到<strong>编译</strong>这个词了。</p>
</blockquote>
<p>1 . C语言是一门编程语言，和其他编程语言一样，编程语言的设计目的是什么？<code>其实很大程度上是为了能够让人类更好的理解</code>。而<code>计算机是无法直接理解和识别的</code>。
2 . 我们都知道，计算机唯一能够理解的是<code>机器语言</code>，也就是由<code>二进制代码0和1</code>组成的数据体系。
3 . 这样一来，<code>编译器</code>和<code>汇编器</code>应运而生，它的作用分别是将编写好的程序代码编译成汇编语言和机器语言，进而让计算机识别和执行。（gcc编译器套件中也提供了汇编器GNU Assembler（gas）用于进行汇编编译处理。）
4 . 这就是代码执行的整体流程。</p>
<p>5 . 如果具体点，我这里画一张图可能就清楚了：</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_c3_1.png" alt="Alt text" /></p>
<p>6 . 总而言之，Gcc为程序的执行提供了充分的工具，要保证程序的执行。</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C/C++搭建开发环境【2】</title>
    <link href="https://mizuki.mysqil.com/posts/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%832/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%832/</id>
    <published>2024-07-24T21:54:31.000Z</published>
    <updated>2024-07-24T21:54:31.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h3>前言</h3>
<p><strong>在学习和使用C语言之前，我们对开发环境有一定的了解，了解的目的是为了能够让初学者从表层认识到C程序的执行条件和原理</strong>。</p>
<blockquote>
<p><strong>GCC</strong>：GNU编译器集合，全称（GNU Compiler Collection）。gcc原本是专为C语言设计的，但后来发展为支持多种编程语言的编译器，比如C++，Go，Ada都能够被gcc编译。</p>
</blockquote>
<blockquote>
<p><strong>GNU</strong>：GNU（GNU's Not Unix），由理查德·斯托曼（Richard Stallman）于1983年发起的自由软件项目。GNU项目内包含了许多重要的组件，如gcc，gdb，bash等。</p>
</blockquote>
<blockquote>
<p><strong>MinGW</strong>：MinGW（Minimalist GNU for Windows），它是一个提供GNU工具集以在Windows操作系统上使用的项目，相当于一个专为Windows系统打造的小型GNU项目。MinGW允许开发者在Windows环境中编译和运行UNIX/Linux应用程序，而无需完全依赖于Cygwin这样的POSIX兼容层。</p>
</blockquote>
<h3>安装编译器</h3>
<blockquote>
<p>了解上述内容后，我们就可以来安装C语言的编译器（MinGW）了。</p>
</blockquote>
<p>1 . 编译器下载链接：https://sourceforge.net/projects/mingw-w64/files/</p>
<p>2 . 下拉找到名为<code>x86_64-win32-sjli</code>的文件下载即可。（最好安装最新版本的）。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_c2_1.png" alt="QQ_1721828332212" /></p>
<p>3 . 下载好后，得到的是一个压缩包文件，我们用解压工具压缩到预定好的位置。</p>
<h3>添加环境变量</h3>
<p>1 . 我们打开解压后的文件夹，在里面可以看到一个名为<code>bin</code>的子目录，复制该目录的路径。</p>
<p>2 . 打开“<strong>高级系统设置</strong>”，点击<strong>环境变量</strong>，我们将<code>bin</code>目录的路径输入到<strong>变量值</strong>内，变量名随便取。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_c2_2.png" alt="QQ_1721827316701" /></p>
<p>3 . 最后，我们打开使用命令提示符，输入：<code>gcc --version</code>，来查看是否能查看gcc版本，如果能查看，则上面环境变量配置完成。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_c2_3.png" alt="QQ_1721827534045" /></p>
<p>4 . 这个时候，我们就可以正常编写和运行C语言程序了。</p>
<h3>编辑器环境(Sublime Text4)</h3>
<blockquote>
<p>工欲善其事，必先利其器：编写C程序我们少不了一款好的编辑器，这里我们将演示使用Sublime Text4。</p>
</blockquote>
<p>1 . 我们打开Sublime Text，需要新建一个C语言的编译系统：点击菜单栏的<code>tools</code> &gt; <code>Build System</code> &gt; <code>New Build System</code>
2 . 在弹出的文本框内输入一下配置命令：</p>
<pre><code>{
    "cmd": ["gcc","${file}","-o", "${file_path}/${file_base_name}"],
    "file_regex":"^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$",
    "working_dir":"${file_path}",
    "selector": "source.c",
    "encoding":"cp936",
    "variants":
    [
        {
            "name": "C_Run",
            "cmd": ["cmd","/c", "gcc", "${file}", "-o", "${file_path}/${file_base_name}","&amp;&amp;", "cmd", "/c","${file_path}/${file_base_name}"]
        },
        {
            "name":"C_RunInCommand",
            "cmd": ["cmd","/c", "gcc", "${file}","-o","${file_path}/${file_base_name}", "&amp;&amp;","start", "cmd", "/c","${file_path}/${file_base_name} &amp; pause"]
         }
    ]
}

</code></pre>
<p>3 . 保存，并重命名为：<code>gcc.sublime-build</code>。
4 . 回到编辑器，我们点击<code>tools</code> &gt; <code>Build System</code> &gt; <code>gcc</code>即可启用编译器系统。
5 . 要运行代码时，只需要使用快捷键&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;B&lt;/kbd&gt;即可（建议使用命令行运行方式），即可运行代码。</p>
<h3>编辑器环境(Visual Studio Code)</h3>
<p>1 . 安装扩展：<code>Code Runner</code>。</p>
<p>2 . 打开扩展设置：<code>setting.json</code>，将cpp那一行代码替换成下列代码并保存。</p>
<pre><code>"cpp": " chcp 65001 ; cd $dir &amp;&amp; g++ -std=c++17 $fileName -o a.exe &amp;&amp; ./a.exe",
</code></pre>
<p>3 . 最后点击右上角的三角形即可运行。</p>
<h3>补充</h3>
<blockquote>
<p>由于之前已经学过Python和C#，所以很多东西我不会再重新在文章中赘述。</p>
</blockquote>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C语言学习笔记_初识【1】</title>
    <link href="https://mizuki.mysqil.com/posts/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%88%9D%E8%AF%861/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%88%9D%E8%AF%861/</id>
    <published>2024-07-24T21:42:02.000Z</published>
    <updated>2024-07-24T21:42:02.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h3>什么是C语言</h3>
<p>1 . <strong>C语言</strong>是一种广泛使用的计算机编程语言，<strong>1972</strong>年诞生于美国AT&amp;T公司贝尔实验室，最初是由<strong>丹尼斯·里奇</strong>（<strong>Dennis Ritchie</strong>）开发，它继承了B语言的许多思想，并加入了数据类型的概念及其他特性。</p>
<p>2 . C语言是一门<code>面向过程</code>的计算机编程语言，与C++、C#、Java等面向对象编程语言有所不同。
3 . C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、仅产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。
4 . C语言描述问题比汇编语言迅速、工作量小、可读性好、易于调试、修改和移植，而代码质量与汇编语言相当。
5 .C语言一般只比汇编语言代码生成的目标程序效率低<code>10%-20%</code>。因此，C语言可以编写系统软件。 [2]</p>
<h3>语言特点</h3>
<ul>
<li><strong>简洁高效</strong>：C语言的语法结构简单，运行速度快，接近硬件操作。</li>
<li><strong>结构化</strong>：C语言支持结构化编程，使用函数、循环、条件判断等控制结构。</li>
<li><strong>可移植性</strong>：C语言编写的程序可以在不同的操作系统和硬件平台上编译运行，只需进行少量修改。</li>
<li><strong>内存管理</strong>：C语言提供了手动内存管理的能力，允许程序员直接控制内存的使用。</li>
<li><strong>广泛的应用</strong>：C语言被广泛应用于系统编程、嵌入式系统、操作系统、网络编程等领域。</li>
</ul>
<h3>地位</h3>
<blockquote>
<p>在计算机领域占据着举足轻重的地位，几乎没有什么能撼动它在各方向的基石作用。</p>
</blockquote>
<p>1 . C语言因其高效性、灵活性和接近硬件的特性，被广泛用于编写操作系统、文件系统、设备驱动程序等系统软件，例如Linux的内核，大部分编程语言的编译器，JVM等，都是由C开发。
2 .C语言被认为是<code>所有现代编程语言的母语</code>，在许多现代编程语言中，如C++、Java、C#等，都受到了C语言的影响，它们在语法结构和编程范式上都借鉴了C语言的特点。</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>使用Git将本地项目推送至Github仓库</title>
    <link href="https://mizuki.mysqil.com/posts/git%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E8%87%B3github%E4%BB%93%E5%BA%93/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/git%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E8%87%B3github%E4%BB%93%E5%BA%93/</id>
    <published>2024-07-21T15:36:23.000Z</published>
    <updated>2024-07-21T15:36:23.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p>由于我本人无法将本地项目推送到Github的<code>main</code>默认分支，所以这里使用的是<code>master</code>分支，当然这个可以在仓库的setting中修改默认分支。
我真搞不明白，为什么不能上传到<code>main</code>分支，<code>master</code>却可以……</p>
</blockquote>
<h2>创建仓库</h2>
<p>1 . 首先在github创建一个仓库
2 . 创建仓库后，我们用终端打开项目，随后我们将如下命令逐步输入到终端：（这些命令在刚创建好的仓库中看到）</p>
<h2>连接仓库</h2>
<pre><code>git init
git add README.md
git commit -m "README(项目说明)"
git branch -M main
git remote add origin [你的仓库地址]
git push -u origin master
</code></pre>
<p>3 . 在刷新一下仓库的页面，可以看到README.md被生成在仓库中了。</p>
<h2>上传项目</h2>
<p>1 . 随后我们开始上传项目。
2 . 再次逐步输入下列命令：</p>
<pre><code>git add .
git commit -m "[你的注释]"
git push -u origin
</code></pre>
<p><img src="https://s2.loli.net/2024/07/21/xVwlIKUTCNm2FGp.png" alt="f2c9015fae3020f95039164f915a778c.png" /></p>
<p>3 . 看到上图所示则说明没什么问题。
4 . 我们回到Github仓库刷新一下也页面，可以看到项目已经被推送到仓库了。</p>
<p><img src="https://s2.loli.net/2024/07/21/k1XdxwI658uFbQW.png" alt="eb2773650f59dda2b1a4a13ea66f5789.png" /></p>
<p>5 . 连接远程仓库
假设已有远程仓库（如 GitHub、GitLab 等），获取其 HTTPS 或 SSH 地址（例如 https://github.com/yourname/yourrepo.git），执行：</p>
<p>bash</p>
<blockquote>
<p>关联远程仓库（origin 是远程仓库的别名，可自定义）</p>
</blockquote>
<pre><code>git remote add origin 远程仓库地址
</code></pre>
<p>6 . 若已关联过错误的远程仓库，可先删除再重新关联：</p>
<pre><code>bash
git remote rm origin
git remote add origin 正确的远程仓库地址
</code></pre>
<p>7 . 推送本地代码到远程仓库
首次推送（需指定分支，通常为 main 或 master）：
bash</p>
<p>-u 表示将本地分支与远程分支关联，后续推送可简化命令</p>
<pre><code>git push -u origin main
</code></pre>
<p>非首次推送（已关联分支后）：</p>
<pre><code>bash
git push
</code></pre>
<h3>更新/合并项目</h3>
<p>1 . 这里合并项目的意思将Github中最新的项目合并到本地项目中，其实就是更新的意思。</p>
<p>2 . 在此之前我一直不知道怎么更新到新的项目，就比如我使用Butterfly主题，随着作者的不断更新，从4.4更新到了5.3.2。如果我们想更新到远程仓库中的版本时，就需要对项目进行合并（这个还是我最近才发现的，之前更新主题只会重构项目，只能说我对Github的认知程度还不到10%）</p>
<p>3 . 当然了，这里的合并并不会将本地项目覆盖掉，而是针对新增代码进行插入，下面开始讲解过程：</p>
<p>4 . 首先我们需要关<code>联原作者仓库作为上游</code>，我们拿Mizuki主题仓库举例。</p>
<pre><code>git remote add upstream https://github.com/matsuzaka-yuki/Mizuki.git
</code></pre>
<p>5 . 获取项目最新的一次更新。</p>
<pre><code>git fetch upstream
</code></pre>
<p>6 . 合并更新到本地分支，（如果远程仓库的分支是<code>master</code>，则需要将<code>main</code>改为<code>master</code>）。</p>
<pre><code>git merge upstream/main
</code></pre>
<p>7 . 这个时候，远程仓库中的新项目就会开始于本地项目进行合并，只需要在VSCode中对新的代码内容进行操作即可。</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="Git"></category>
  </entry>
  <entry>
    <title>Butterfly美化方案【进阶】</title>
    <link href="https://mizuki.mysqil.com/posts/butterfly%E7%BE%8E%E5%8C%96%E6%96%B9%E6%A1%88%E8%BF%9B%E9%98%B6/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/butterfly%E7%BE%8E%E5%8C%96%E6%96%B9%E6%A1%88%E8%BF%9B%E9%98%B6/</id>
    <published>2024-07-19T21:48:59.000Z</published>
    <updated>2024-07-19T21:48:59.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h1>页面</h1>
<h2>标签页面</h2>
<p>1 . 创建标签页面</p>
<pre><code>hexo new page tags
</code></pre>
<p>2 . 将index.md的内容修改下面内容：</p>
<pre><code>---
title: 标签
date: 2024-07-18 10:14:31
type: "tags"
top_img: false
---
</code></pre>
<h2>分类页面</h2>
<p>1 . 创建分类页面</p>
<pre><code>hexo new page categories
</code></pre>
<p>2 . 将index.md的内容修改下面内容：</p>
<pre><code>---
title: 分类
date: 2024-07-18 10:14:10
type: "categories"
top_img: false
---
</code></pre>
<h2>友链页面</h2>
<p>1 . 创建友链页面</p>
<pre><code>hexo new page link
</code></pre>
<p>2 . 将index.md的内容修改下面内容：</p>
<pre><code>---
date: 2024-07-17 14:59:33
type: 'link'
top_img: false
---


## ✨申请友链

&gt;欢迎交换友链，您可以按照以下格式在评论区打出申请信息

### 注意
☑️若后期您的站点无法访问，这里会自动将其列入失联名单中。
☑️针对部分存在资源加密的站点，尽可能在申请信息后面添加一个`siteshot: `截图链接，以便我们获取到站点的首页


</code></pre>
<p>3 . 修改文件：<code>source/layout/includes/page/flink.pug</code></p>
<pre><code>#article-container
  if top_img === false
    h1.page-title= page.title
  .flink
    if site.data.link
      each i in site.data.link
        if i.class_name
          h2!= i.class_name
        if i.class_desc
          .flink-desc!=i.class_desc
        if i.flink_style === 'butterfly'
          .butterfly-flink-list
            - let randomList = i.link_list.slice()
            if i.random
              - randomList.sort(() =&gt; Math.random() - 0.5)
            each item in randomList
              .flink-list-item
                a(href=url_for(item.link)  title=item.name target="_blank")
                  .flink-item-icon
                    if theme.lazyload.enable
                      img.nolazyload(data-lazy-src=url_for(item.avatar) onerror=`this.onerror=null;this.src='` + url_for(theme.error_img.flink) + `'` alt=item.name )
                    else
                      img.nolazyload(src=url_for(item.avatar) onerror=`this.onerror=null;this.src='` + url_for(theme.error_img.flink) + `'` alt=item.name )
                  .flink-item-info
                    .flink-item-name= item.name
                    .flink-item-desc(title=item.descr)= item.descr
        else if i.flink_style === 'flexcard'
          .flexcard-flink-list
            - let randomList = i.link_list.slice()
            if i.random
              - randomList.sort(() =&gt; Math.random() - 0.5)
            each item in randomList
              a.flink-list-card(href=url_for(item.link) target='_blank' data-title=item.descr)
                .wrapper.cover
                  - var siteshot = item.siteshot ? url_for(item.siteshot) : 'https://s0.wp.com/mshots/v1/' + item.link + '?w=400&amp;h=300'
                  if theme.lazyload.enable
                    img.cover.fadeIn.nolazyload(data-lazy-src=siteshot onerror=`this.onerror=null;this.src='` + url_for(theme.error_img.post_page) + `'` alt='' )
                    img.cover.fadeIn.nolazyload(data-lazy-src=avatar onerror=`this.onerror=null;this.src='` + url_for(theme.error_img.post_page) + `'` alt='' )
                  else
                    img.cover.fadeIn.nolazyload(src=siteshot onerror=`this.onerror=null;this.src='` + url_for(theme.error_img.post_page) + `'` alt='' )
                    img.cover.fadeIn.nolazyload(data-lazy-src=avatar onerror=`this.onerror=null;this.src='` + url_for(theme.error_img.post_page) + `'` alt='' )
                .info
                  if theme.lazyload.enable
                    img.flink-avatar.nolazyload(data-lazy-src=url_for(item.avatar) onerror=`this.onerror=null;this.src='` + url_for(theme.error_img.flink) + `'` alt='' )
                  else
                    img.nolazyload(src=url_for(item.avatar) onerror=`this.onerror=null;this.src='` + url_for(theme.error_img.flink) + `'` alt='' )
                  span.flink-sitename= item.name
        else if i.flink_style === 'volantis'
          .volantis-flink-list
            - let randomList = i.link_list.slice()
            if i.random
              - randomList.sort(() =&gt; Math.random() - 0.5)
            each item in randomList
              a.site-card(target='_blank' rel='noopener' href=url_for(item.link))
                .img
                  - var siteshot = item.siteshot ? url_for(item.siteshot) : 'https://s0.wp.com/mshots/v1/' + item.link + '?w=400&amp;h=300'
                  img.nolazyload.no-lightbox(src=siteshot onerror=`this.onerror=null;this.src='` + url_for(theme.error_img.post_page) + `'` alt='' )
                .info
                  img.nolazyload.no-lightbox(src=url_for(item.avatar) onerror=`this.onerror=null;this.src='` + url_for(theme.error_img.flink) + `'` alt='' )
                  span.title= item.name
                  span.desc(title=item.descr)= item.descr
        else if i.flink_style === 'byer'
          .byer-flink-list
            - let randomList = i.link_list.slice()
            if i.random
              - randomList.sort(() =&gt; Math.random() - 0.5)
            each item in randomList
              .flink-list-item
                a(href=url_for(item.link)  title=item.name target="_blank")
                  .flink-item-bar
                    sapn.flink-item-bar-yellow 
                    sapn.flink-item-bar-green 
                    sapn.flink-item-bar-red
                    sapn.flink-item-bar-x +
                  .flink-item-content
                    .flink-item-text
                      .flink-item-name= item.name 
                      .flink-item-desc(title=item.descr)= item.descr
                    .flink-item-icon
                      img.no-lightbox(src=url_for(item.avatar) onerror=`this.onerror=null;this.src='` + url_for(theme.error_img.flink) + `'` alt=item.name )
        else if i.flink_style === 'ark'
          .ark-flink-list
            - let randomList = i.link_list.slice()
            if i.random
              - randomList.sort(() =&gt; Math.random() - 0.5)
            each item in randomList
              a.ark-flink-list-card(href=url_for(item.link) target='_blank' title=item.descr)
                .ark-flink-progress-bar-A
                .ark-flink-progress-bar-B
                .ark-flink-progress-bar-C
                .ark-flink-content
                  .ark-flink-name
                    .flink-sitename= item.name
                    .flink-block
                  .ark-flink-avatar
                    img.no-lightbox(src=url_for(item.avatar) onerror=`this.onerror=null;this.src='` + url_for(theme.error_img.flink) + `'` alt='' )
                  .ark-flink-mask
                    .ark-flink-mask-left 
                    .ark-flink-mask-right
                  .ark-flink-descr
                    .ark-flink-descr-text=item.descr
                  .ark-flink-siteshot
                    - var siteshot = item.siteshot ? url_for(item.siteshot) : 'https://s0.wp.com/mshots/v1/' + item.link + '?w=400&amp;h=300'
                    img.no-lightbox(src=siteshot onerror=`this.onerror=null;this.src='` + url_for(theme.error_img.post_page) + `'` alt='' )

    != page.content
</code></pre>
<p>4 . 修改文件：<code>source/css/_page/flink.styl</code></p>
<pre><code>.flink-desc
  margin: .2rem 0 .5rem
//bf原生
.butterfly-flink-list
  overflow: auto
  padding: 10px 10px 0
  text-align: center
  border-radius: 12px

  border: 1px dashed black

  &amp; &gt; .flink-list-item
    position: relative
    float: left
    overflow: hidden
    line-height: 17px
    -webkit-transform: translateZ(0)
    height: 100px;
    padding: 10px;
    width: calc(100% / 3 - 0.5rem)
    margin: 0.5rem 0.25rem;
    border-radius: 12px;
    border: var(--style-border);
    -webkit-transition: all .3s ease-in-out;
    -moz-transition: all .3s ease-in-out;
    -o-transition: all .3s ease-in-out;
    -ms-transition: all .3s ease-in-out;
    transition: all .3s ease-in-out;

    +maxWidth1200()
      width: calc(50% - 15px) !important

    +maxWidth600()
      width: calc(100% - 15px) !important

    &amp;:hover
      border-color: #101010 !important;
      background-color: rgba(255, 255, 255, .4);
      box-shadow: 0px 7px 30px 0px rgba(100, 100, 111, 0.2);
      text-decoration: none;
      .flink-item-icon
        width: 0;
        height: 0;
        margin-left: -10px;
      

    &amp;:hover:before,
    &amp;:focus:before,
    &amp;:active:before
      transform: scale(1)

    a
      color: var(--font-color)
      text-decoration: none

      .flink-item-icon
        float: left
        overflow: hidden
        margin: 15px 10px
        width: 60px
        height: 60px
       
        transition: all .3s ease-out
        margin: 8px 0 8px 0;

        overflow: hidden;

        img
          width: 100%
          height: 100%
          transition: filter 375ms ease-in .2s, transform .3s
          object-fit: cover

      .img-alt
        display: none

.flink-item-info
  display: flex;
  flex-wrap: wrap;
  padding-left: 10px;
  text-align: left;
  flex-direction: column;

  .flink-item-name
    @extend .limit-one-line
    padding: 12px 0 16px 0;
    height: auto;
    font-weight: bold
    font-size: 1.2em

  .flink-item-desc
    @extend .limit-one-line
    padding: 0
    height: 35px
    font-size: .93em
    opacity: .7;
    word-break: break-all;
    white-space: break-spaces;
    display: -webkit-box;
    overflow: hidden;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;

.flink-name
  margin-bottom: 5px
  font-weight: bold
  font-size: 1.5em
//flexcard卡片
#article-container img
  margin-bottom: 0.5rem;
  object-fit: cover;
  max-height: 900px;
.flexcard-flink-list
  overflow hidden
  .flink-list-card
    .wrapper img
      transition: transform .5s ease-out !important;

  &amp; &gt; a
    width: calc(100% / 5 - 0.5rem);
    height 150px
    position relative
    display block
    margin: 0.5rem 0.25rem;
    float left
    overflow hidden
    padding: 0;
    border-radius: 8px;
    transition all .3s ease 0s, transform .6s cubic-bezier(.6, .2, .1, 1) 0s
    box-shadow none
    border: var(--style-border)!important;
    &amp;:hover
      .info
        transform translateY(-100%)
      .wrapper
        img
          transform scale(1.2)
      &amp;::before
        position: fixed
        width:inherit
        margin:auto
        left:0
        right:0
        top:10%
        border-radius: 10px
        text-align: center
        z-index: 100
        content: attr(data-title)
        font-size: 20px
        color: #fff
        padding: 10px
        background-color: rgba($theme-color,0.8)

    .cover
      width 100%
      transition transform .5s ease-out
    .wrapper
      position relative
      .fadeIn
        animation coverIn .8s ease-out forwards
      img
        height 150px
        pointer-events none
    .info
      display flex
      flex-direction column
      justify-content center
      align-items center
      width 100%
      height 100%
      overflow hidden
      border-radius 3px
      background-color hsla(0, 0%, 100%, .7)
      transition transform .5s cubic-bezier(.6, .2, .1, 1) 0s
      img
        position relative
        top 45px
        width 80px
        height 80px
        border-radius 50%
        box-shadow 0 0 10px rgba(0, 0, 0, .3)
        z-index 1
        text-align center
        pointer-events none
      span
        padding 20px 10% 60px 10%
        font-size 16px
        width 100%
        text-align center
        box-shadow 0 0 10px rgba(0, 0, 0, .3)
        background-color hsla(0, 0%, 100%, .7)
        color var(--font-color)
        white-space nowrap
        overflow hidden
        text-overflow ellipsis
.flexcard-flink-list&gt;a .info,
.flexcard-flink-list&gt;a .wrapper .cover
  position absolute
  top 0
  left 0

@media screen and (max-width:1024px)
  .flexcard-flink-list
    &amp; &gt; a
      width calc(33.33333% - 15px)

@media screen and (max-width:600px)
  .flexcard-flink-list
    &amp; &gt; a
      width calc(50% - 15px)

[data-theme=dark]
  .flexcard-flink-list a .info,
  .flexcard-flink-list a .info span
    background-color rgba(0, 0, 0, .6)
  .flexcard-flink-list
    &amp; &gt; a
      &amp;:hover
        &amp;:before
          background-color: rgba(#121212,0.8);
.justified-gallery &gt; div &gt; img,
.justified-gallery &gt; figure &gt; img,
.justified-gallery &gt; a &gt; a &gt; img,
.justified-gallery &gt; div &gt; a &gt; img,
.justified-gallery &gt; figure &gt; a &gt; img,
.justified-gallery &gt; a &gt; svg,
.justified-gallery &gt; div &gt; svg,
.justified-gallery &gt; figure &gt; svg,
.justified-gallery &gt; a &gt; a &gt; svg,
.justified-gallery &gt; div &gt; a &gt; svg,
.justified-gallery &gt; figure &gt; a &gt; svg
  position static!important




trans($time = 0.28s)
  transition: all $time ease
  -moz-transition: all $time ease
  -webkit-transition: all $time ease
  -o-transition: all $time ease

//volantis卡片，我的最爱
.volantis-flink-list
  display: flex
  flex-wrap: wrap
  justify-content: flex-start
  margin: -0.5 * 16px
  align-items: stretch
.site-card
  margin: 16px * 0.5
  width: "calc(100% / 4 - %s)" % 16px
  @media screen and (min-width: 2048px)
      width: "calc(100% / 5 - %s)" % 16px
  @media screen and (max-width: 768px)
      width: "calc(100% / 3 - %s)" % 16px
  @media screen and (max-width: 500px)
      width: "calc(100% / 2 - %s)" % 16px
  display: block
  line-height: 1.4
  height 100%
  .img
    width: 100%
    height 150px
    @media screen and (max-width: 500px)
      height 100px
    overflow: hidden
    border-radius: 12px * 0.5
    box-shadow: 0 1px 2px 0px rgba(0, 0, 0, 0.2)
    background: #f6f6f6
    img
      width: 100%
      height 100%
      pointer-events:none;
      // trans(.75s)
      transition: transform 2s ease
      object-fit: cover

  .info
    margin-top: 16px * 0.5
    img
      width: 32px
      height: 32px
      pointer-events:none;
      border-radius: 16px
      float: left
      margin-right: 8px
      margin-top: 2px
    span
      display: block
    .title
      font-weight: 600
      font-size: var(--global-font-size)
      color: #444
      display: -webkit-box
      -webkit-box-orient: vertical
      overflow: hidden
      -webkit-line-clamp: 1
      trans()
    .desc
      font-size: var(--global-font-size)
      word-wrap: break-word;
      line-height: 1.2
      color: #888
      display: -webkit-box
      -webkit-box-orient: vertical
      overflow: hidden
      -webkit-line-clamp: 2
  .img
    trans()
  &amp;:hover
    .img
      box-shadow: 0 4px 8px 0px rgba(0, 0, 0, 0.1), 0 2px 4px 0px rgba(0, 0, 0, 0.1), 0 4px 8px 0px rgba(0, 0, 0, 0.1), 0 8px 16px 0px rgba(0, 0, 0, 0.1)
    .info .title
      color: #ff5722
//byer卡片
#article-container
  .flink
    margin-bottom: 20px

    .byer-flink-list
      overflow: auto
      padding: 10px 10px 0
      text-align: center

      &amp; &gt; .flink-list-item
        position: relative
        background: #ffffff
        float: left
        overflow: hidden
        margin: 15px 7px
        width: calc(100% / 3 - 15px)
        height: 120px
        border-radius: 2px
        line-height: 17px
        -webkit-transform: translateZ(0)
        border: 1px solid
        box-shadow: 3px 3px 1px 1px #fee34c;

        +maxWidth1024()
          width: calc(50% - 15px) !important

        +maxWidth600()
          width: calc(100% - 15px) !important

        a
          color: var(--font-color)
          text-decoration: none
          .flink-item-bar
            height: 15px
            border-width: 0 0 1px 0
            border-style: none none solid none
            background: #fde135
            display: flex;
            align-items: center;
            flex-direction: row;
            flex-wrap: nowrap;
            padding: 0 3px 0 3px
            sapn
              width: 10px;
              height: 10px;
              margin: 0 1px 0 1px
              border-radius: 50%;
              display: block;
              border: 1px solid;
              display: flex;
              align-items: center;
              justify-content: flex-start;
              &amp;.flink-item-bar-yellow
                background: #fde135
              &amp;.flink-item-bar-green
                background: #249a33
              &amp;.flink-item-bar-red
                background: #f13b06
              &amp;.flink-item-bar-x
                background: transparent
                border: 0px
                margin-left: auto
                transform: rotate(45deg);
                font-size: 23px;
                padding: 0px 0px 6px 0px;
          .flink-item-content
            display: flex;
            height: 105px
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            padding: 0 5px 0 5px;
            .flink-item-text
              width: 60%;
              display: flex;
              flex-direction: column;
              align-items: center;
              .flink-item-name
                @extend .limit-one-line
                max-width: 100%;
                padding: 0px 5px 0px 5px;
                margin: 0px 0 6px 0;
                height: 50%;
                font-weight: bold;
                font-size: 1.43em;
                border-width: 0 0 7px 0;
                border-style: solid;
                border-color: #fbf19f;
              .flink-item-desc
                @extend .limit-one-line
                max-width: 100%;
                height: 50%;
                padding: 5px 5px 5px 5px;
                font-size: 0.93em;
                position: relative
                &amp;:before
                  content: "";
                  background: transparent;
                  display: block;
                  height: calc(100% - 4px);
                  width: calc(100% - 4px);
                  position: absolute;
                  left: 0;
                  top: 0;
                  border-radius: 2px;
                  border: 1px solid;
                  clip-path: polygon(0 0, 100% 0, 100% 100%, 95% 100%, 95% 50%, 90% 50%, 90% 100%, 0 100%);


            .flink-item-icon
              overflow: hidden;
              margin: 0px 5px;
              width: 70px;
              height: 70px;
              border: 1px solid;
              border-radius: 2px;
              transition: width .3s ease-out
              box-shadow: 2px 2px 1px 1px #fee34c;
              img
                width: 50px;
                height: 50px;
                margin: 9px 9px;
                transition: filter 375ms ease-in .2s, transform .3s
                object-fit: cover

              .img-alt
                display: none
//byer卡片暗夜模式改造
[data-theme=dark]
  #article-container
    .flink
      .byer-flink-list
        &amp; &gt; .flink-list-item
          background: rgb(40,40,40)
          box-shadow: 3px 3px 1px 1px #1B5A70;
          a
            .flink-item-bar
              background: #1B5A70;
            .flink-item-content
              .flink-item-text
                .flink-item-name
                  border-color: #5EBAD9;
              .flink-item-icon
                box-shadow: 2px 2px 1px 1px #1B5A70;
              
          

//下面是aki及其自定义配色:
:root
  --ark-flink-default-color: rgba(153, 54, 44,0.8) /*主色调*/
  --ark-flink-mask: #818181  /*遮罩层配色*/
  --ark-flink-progress-default: rgba(227, 236, 238, 0.8) /*能量条默认配色*/
  --ark-flink-progress-charge: #d97f17 /*能量条充能配色*/
  --flink-name-border-color: #d97f17 /*ID边框配色*/

[data-theme="dark"]
  --ark-flink-default-color: rgba(55, 112, 143,0.8)
  --ark-flink-mask: #37708f
  --ark-flink-progress-default: rgba(46, 160, 221, 0.8)
  --ark-flink-progress-charge: rgba(227, 236, 238, 0.8)
  --flink-name-border-color: rgba(227, 236, 238, 0.8)


//适配ark方舟友链卡片
#article-container
  .flink
    margin-bottom: 20px

    .ark-flink-list
      overflow: auto
      padding: 10px 10px 0
      text-align: center

      &amp; &gt; .ark-flink-list-card
        position: relative
        display: block
        color: var(--font-color)
        text-decoration: none
        float: left
        overflow: hidden
        margin: 15px 7px
        width: calc(100% / 3 - 15px)
        height: 220px
        border-radius: 2px
        line-height: 17px
        -webkit-transform: translateZ(0)

        +maxWidth1024()
          width: calc(50% - 15px) !important

        +maxWidth600()
          width: calc(100% - 15px) !important
        

      a.ark-flink-list-card
        *
          transition: all 0.3s cubic-bezier(.6, 0, .5, 1)
        &amp;:hover
          *
            transition: all 0.3s cubic-bezier(.6, 0, .5, 1)
          .ark-flink-progress-bar-A,
          .ark-flink-progress-bar-B,
          .ark-flink-progress-bar-C
            background: var(--ark-flink-progress-charge)
          .ark-flink-content
            .ark-flink-name
              bottom: 0px;
            .ark-flink-avatar
              transform: rotateX(90deg)
            .ark-flink-mask
              .ark-flink-mask-left
                transition-delay: 0.3s;
                left: -35%;
              .ark-flink-mask-right
                transition-delay: 0.3s;
                right: -55%;
            .ark-flink-descr
              .ark-flink-descr-text
                transition-delay: 0.3s;
                opacity: 1
                animation: ark-flink-type 1.5s steps(20, end) 0.3s,ark-flink-blink .75s step-end infinite; /* 定义光标的闪烁动画 */  
        .ark-flink-progress-bar-A,
        .ark-flink-progress-bar-B,
        .ark-flink-progress-bar-C
          display: block
          position: absolute;
          background: var(--ark-flink-progress-default)
          z-index 6
        .ark-flink-progress-bar-A
          height: 8px;
          width: 100px;
          top: 3px;
          left: 6px;
          clip-path: polygon(0% 100%, 8% 0%, 28% 0%, 20% 100%, 23% 100%, 31% 0%, 46% 0%, 38% 100%, 41% 100%, 49% 0%, 64% 0%, 56% 100%, 59% 100%, 67% 0%, 82% 0%, 74% 100%, 77% 100%, 85% 0%, 100% 0%, 90% 100%);
        .ark-flink-progress-bar-B
          height: 8px;
          width: 35px;
          bottom: 35px;
          left: 0;
          clip-path: polygon(0% 0%, 40% 0%, 15% 100%, 25% 100%, 50% 0%, 85% 0%, 60% 100%, 70% 100%, 90% 0%, 100% 100%, 15% 100%);
        .ark-flink-progress-bar-C
          height: 100px
          width: 8px
          bottom: 50px
          right: 0
          clip-path: polygon( 0% 0%, 100% 8%, 100% 28%, 0% 20%, 0% 23%, 100% 31%,100% 46% ,0% 38% ,0% 41% ,100% 49% ,100% 64% ,0% 56% ,0% 59% ,100% 67% ,100% 82% ,0% 74% , 0% 77%,100% 85% , 100% 100%,0% 90% );
        .ark-flink-content
          display: block
          position: absolute
          background: radial-gradient(var(--ark-flink-default-color),transparent)
          width: calc(100% - 10px)
          height: 100%
          top: 0
          left: 0
          clip-path: polygon(0 15px, 100px 15px, 115px 0, calc(100% - 45px) 0, calc(100% - 15px) 45px, 100% 45px, 100% calc(100% - 25px), calc(100% - 30px) calc(100% - 25px), calc(100% - 55px) calc(100% - 10px), calc(100% - 90px) calc(100% - 10px), calc(100% - 100px) 100%, 100px 100%, 90px calc(100% - 10px), 55px calc(100% - 10px), 35px calc(100% - 45px), 0% calc(100% - 45px));
          .ark-flink-avatar,
          .ark-flink-mask,
          .ark-flink-descr,
          .ark-flink-siteshot
            position: absolute
            width: 100%
            height: 100%
            top: 0
            left: 0
          .ark-flink-name
            display: block;
            position: absolute;
            z-index: 5;
            bottom: 10px;
            left: 20%;
            color: white;
            text-shadow: 1px 1px 5px black;
            background: transparent;
            height: 40px;
            width: 60%;
            border-style: double;
            border-width: 5px 5px 0 5px;
            border-color: var(--flink-name-border-color);
            transform: perspective(0.5em) rotateX(3deg);
            .flink-sitename
              transform: perspective(0.5em) rotateX(-3deg);
              font-size: 15px;
              margin: 5px 0 0 0;
            .flink-block
              transform: perspective(0.5em) rotateX(-10deg);
              display: block;
              width: 60%;
              height: 13px;
              background: var(--flink-name-border-color);
              position: absolute;
              bottom: 0px;
              left: 20%;
          .ark-flink-avatar
            z-index 4
            display: flex
            align-items: center;
            justify-content: center;
            transform: rotateX(0deg)
            img
              width: 100px;
              height: 100px;
              margin: 0 auto 20px;
              object-fit: cover
              clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
            .img-alt
              display: none
          .ark-flink-mask
            z-index 3
            .ark-flink-mask-left
              width: 100%;
              height: 100%;
              background: repeating-linear-gradient(0deg, var(--ark-flink-mask),transparent 1px);
              clip-path: polygon(50% 0, 50% calc(50% - 60px), calc(50% - 20px) calc(50% - 60px), calc(50% - 50px) calc(50% - 30px), calc(50% - 50px) calc(50% + 10px), calc(50% - 20px) calc(50% + 40px), 50% calc(50% + 40px), 50% 100%, 0% 100%, 0% 0%);
              left: 0%;
              position: absolute;
            .ark-flink-mask-right
              background: repeating-linear-gradient(0deg, var(--ark-flink-mask),transparent 1px);
              width: 100%;
              height: 100%;
              clip-path: polygon(100% 0%, 50% 0%, 50% calc(50% - 60px), calc(50% - 20px) calc(50% - 60px), calc(50% - 50px) calc(50% - 30px), calc(50% - 50px) calc(50% + 10px), calc(50% - 20px) calc(50% + 40px), 50% calc(50% + 40px), 50% 100%, 100% 100%);
              right: 0%;
              position: absolute;
          
          .ark-flink-descr
            z-index 2
            display: flex
            align-items: center;
            justify-content: center;
            .ark-flink-descr-text
              color: white;
              text-shadow: 1px 1px 5px black;
              font-size: 1.5em;
              height: 1.5em;
              line-height: 1.5em;
              overflow: hidden; /* 隐藏超出容器的文本 */
              border-right: .15em solid orange; /* 打字效果的光标动画 */
              white-space: nowrap; /* 确保文本在一行内显示，不换行 */
              margin: 20px;
              opacity: 0
          .ark-flink-siteshot
            z-index 1
            display: flex
            align-items: center;
            justify-content: center;
            img
              height: 75%;
              width: 100%;
              margin: 0 auto 20px;
              object-fit: cover;

/* 定义打字机动画 */
@keyframes ark-flink-type
  from
    width: 0;
  to
    width: 100%;


/* 定义光标闪烁动画 */
@keyframes ark-flink-blink
  from,
  to
    border-color: transparent;
  50%
    border-color: orange

</code></pre>
<blockquote>
<p><strong>温馨提示</strong>：一般而言，归档（archives）页面是不用创建的，它会自动生成。
<strong>另外</strong>： <code>top_img:</code>是用于开关页面顶部的封面，可按需求使用。</p>
</blockquote>
<h2>我的装备页面</h2>
<blockquote>
<p>该模板的好处是：不需要在外部嵌入css和修改yml，而是直接在md中嵌入了css，完全一步操作。
预览：<a href="http://localhost:4000/equipment/">我的装备</a></p>
</blockquote>
<p>1 . 创建我的装备页面</p>
<pre><code>hexo new page equipment
</code></pre>
<p>2 . 将index.md的内容修改下面内容：</p>
<pre><code>---
title: 🎒我的装备
date: 2024-11-16 10:20:54
aside: false
type: equipment
---
&lt;style&gt;
  .container {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-around;
    padding: 10px;
  }
  .box {
    flex: 1;
    min-width: 180px; /* 最小宽度，可以根据实际情况调整 */
    margin: 10px;
    height: auto;
    overflow: hidden;
    border-radius:12px;
    -webkit-transition: all 0.28s ease;
  }
  
  .box:hover{
    box-shadow: 0px 7px 30px 0px rgba(100, 100, 111, 0.2) ;
  }
  .only-img {
    width: auto;
    height: 200px;
    display: block;
    border-radius: 0;
  }
  #beizhu{
    font-size: 12px;
    margin-top: -17px;
    font-weight: normal;
    color: #7e7e7e;
  }
  .description {
    padding: 0px 0px 15px 15px
  }
  @media (max-width: 768px) {
    .box {
      flex-basis: 100%; /* 在小屏幕上，每个盒子占满整个宽度 */
    }
  }
&lt;/style&gt;
&lt;div class="container"&gt;
  &lt;div class="box"&gt;
    &lt;img src="https://shopstatic.vivo.com.cn/vivoshop/commodity/43/10009543_1713769003117_750x750.png.webp" alt="图片项目1"&gt;
    &lt;div class="description"&gt;
      &lt;h3&gt;IQOO Z9&lt;/h3&gt;
      &lt;h4 id="beizhu"&gt;12G / 256GB&lt;/h4&gt;
      &lt;p&gt;6000mAh电池|第三代骁龙 7|144Hz 防频闪护眼屏&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="box"&gt;
    &lt;img src="/img/other/p15.png" alt="图片2"&gt;
    &lt;div class="description"&gt;
      &lt;h3&gt;Colorful P15&lt;/h3&gt;
      &lt;h4 id="beizhu"&gt;i5-12450H / RTX-4050&lt;/h4&gt;
      &lt;p&gt;搭载4050和十二代处理器，具有较高的性能。&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="box"&gt;
    &lt;img src="/img/other/k87pro.png" alt="图片3"&gt;
    &lt;div class="description"&gt;
      &lt;h3&gt;凌豹 K87 Pro&lt;/h3&gt;
      &lt;h4 id="beizhu"&gt;三模 / 热插拔&lt;/h4&gt;
      &lt;p&gt;三模Gasket热插拔机械键盘，二次元主题配色...&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="box"&gt;
    &lt;img src="https://rpw.rapoo.cn/goods/gallery/1718789069269.jpg" alt="图片3"&gt;
    &lt;div class="description"&gt;
      &lt;h3&gt;Repoo VH300S&lt;/h3&gt;
      &lt;h4 id="beizhu"&gt;Unreal7.1 / 40mm&lt;/h4&gt;
      &lt;p&gt;虚拟7.1声道音效，40mm发声单元...
&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h2>页面FPS监测</h2>
<p>任意页面显示当前页面的FPS帧数，对于不同的fps大小会有不同的显示效果。</p>
<p>效果：
<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_fps.png" alt="" /></p>
<blockquote>
<p>本教程参考了<strong>青稚</strong>的：<a href="https://blog.linux-qitong.top/posts/305bae84/">Butterfly主题美化
</a></p>
</blockquote>
<p>1 . 在<code>source/css/</code>目录新建一个样式文件<code>fps.css</code>输入以下代码：</p>
<pre><code>/* 帧率检测 */
#fps {
    position: fixed;
    right: 10px;
    bottom: 10px;
    z-index: 1919810
}
/*Light*/ 
[data-theme=light] #fps {   
    background-color: rgba(255,255,255,.85);
    backdrop-filter: blur(5px) saturate(150%);
    padding: 0 6px;
    border-radius: 20px
}
/*Dark*/ 
[data-theme=dark] #fps {
    background-color: rgba(0,0,0,.72);
    backdrop-filter: blur(5px) saturate(150%);
    padding: 0 6px;
    border-radius: 20px
}
</code></pre>
<p>2 . 在<code>source/js/</code>目录新建一个样式文件<code>fps.js</code>输入以下代码：</p>
<pre><code>document.addEventListener('pjax:complete', fps);
document.addEventListener('DOMContentLoaded', fps);
function fps(){
// if(window.localStorage.getItem("fpson")=="1"){ 
//如果要使博客设置上面的设置项能生效，就把上面一行取消注释
var rAF = function () {
    return (
        window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        function (callback) {
            window.setTimeout(callback, 1000 / 60);
        }
    );
}();
var frame = 0;
var allFrameCount = 0;
var lastTime = Date.now();
var lastFameTime = Date.now();
var loop = function () {
    var now = Date.now();
    var fs = (now - lastFameTime);
    var fps = Math.round(1000 / fs);
 
    lastFameTime = now;
    // 不置 0，在动画的开头及结尾记录此值的差值算出 FPS
    allFrameCount++;
    frame++;
 
    if (now &gt; 1000 + lastTime) {
        var fps = Math.round((frame * 1000) / (now - lastTime));
        if(fps&lt;=5){
            var kd=`&lt;span style="color:#ff1b1b"&gt;卡成ppt🤢&lt;/span&gt;`
        }
        else if(fps&lt;=15){
            var kd=`&lt;span style="color:red"&gt;电竞级帧率😖&lt;/span&gt;`
        }
        else if(fps&lt;=25){
            var kd=`&lt;span style="color:yellow"&gt;有点难受😨&lt;/span&gt;`
        }
        else if(fps&lt;35){
            var kd=`&lt;span style="color:orange"&gt;不太流畅🙄&lt;/span&gt;`
        }
        else if(fps&lt;=45){
            var kd=`&lt;span style="color:#59d8ef"&gt;还不错哦😁&lt;/span&gt;`
        }
        else{
            var kd=`&lt;span style="color:#0ace00"&gt;十分流畅😍&lt;/span&gt;`
        }
        document.getElementById("fps").innerHTML=`FPS:${fps} ${kd}`;
        frame = 0;
        lastTime = now;
    };
 
    rAF(loop);
}
 
loop();
// }
// else{$("#fps").hide()}
//如果要使博客设置上面的设置项能生效，就把上面两行取消注释
}
</code></pre>
<p>3 . 最后在<code>主题配置文件.config.yml</code>中将其引入即可。</p>
<h2>Live2d看板娘</h2>
<blockquote>
<p>看板娘不仅可以使页面充满活力，闲着没事与她互动也能够消除烦恼哦！赶快将其领回家吧！</p>
</blockquote>
<p>1 . 安装插件：<a href="https://github.com/stevenjoezhang/live2d-widget">live2d-widget</a></p>
<p>2 . 将解压到<code>theme/butterfly/source</code>目录。</p>
<p>3 . 打开该插件目录中的<code>autoload.js</code>文件（这里开始修改配置代码）。</p>
<p>4 . 根据作者的推荐将代码：<code>const live2d_path</code>的路径改为绝对路径。也就是本地路径。</p>
<pre><code>const live2d_path = "/live2d-widget/";
</code></pre>
<p>5 . 再将修改初始化配置项<code>initWidget</code>中的<code>cdnPath</code>代码路径，原路径是作者的api，但是正常情况下是需要挂VPN的，而且提供的皮肤模型很少，这里可以改成<code>Akilarの糖果屋</code>提供的api接口，里面提供了大量的皮肤模型......</p>
<pre><code>cdnPath: "https://npm.elemecdn.com/akilar-live2dapi@latest/",
</code></pre>
<p>6 . 最后在主题配置文件<code>_config.yml</code>将js引入即可。</p>
<pre><code>- &lt;script src="/live2d-widget/autoload.js"&gt;&lt;/script&gt;
</code></pre>
<h1>主页</h1>
<p><strong>打开文件</strong>：<code>source\css\_page\homepage.styl</code></p>
<h2>文章列表样式</h2>
<p>1 .你可以在这里修改主页文章列表区块的样式
2 . 修改文章列表的<code>边框样式</code>，例如：</p>
<pre><code>  &amp; &gt; .recent-post-item
    @extend .cardHover
    display: flex
    flex-direction: row
    align-items: center
    overflow: hidden
    height: 15em          ## 修改高度
    border-radius:12px    ## 修改圆角曲度
</code></pre>
<p>3 . 修改文章列表中的<code>内容字体大小</code>，例如：</p>
<pre><code>      &amp; &gt; .content
        @extend .limit-more-line
        -webkit-line-clamp: 2
        font-size: 15px        ## 自定义内容字体大小
</code></pre>
<h1>导航栏</h1>
<h2>选项居中化</h2>
<p>1 . 魔改参考文章：<a href="https://b.leonus.cn/2022/hexoCenter.html">buterfly博客导航栏居中</a>
2 . 实现原理是将选项卡向左边移动50%居中，并将子选项卡反方向旋转50%，这样子选项卡的排列方式就成了横向的，在此期间，我们还要将子选项卡与父选项卡保持对其，需要单独调整各个选项卡的位置。由于宽度限制，我们还需要设置white-space: nowrap;样式，这样即使宽度不够，选项卡也不会强制换行。最后我还在原基础上添加了过渡动画</p>
<pre><code>#nav .menus_items {
    position: absolute;
    width: fit-content;
    white-space: nowrap;  /*强制不换行*/
    left: 50%;
    transform: translateX(-50%);
}

#nav .menus_items .menus_item:hover .menus_item_child {
    display: flex;
    border-radius: 15px;
}

#nav .menus_items .menus_item .menus_item_child li {
    border-radius: 15px;
}

#nav .menus_items .menus_item .menus_item_child li:first-child {
    border-radius: 15px;
}

#nav .menus_items .menus_item .menus_item_child li:last-child {
    border-radius: 15px;
}

#nav .menus_items .menus_item .menus_item_child li {
    transition: all 0.5s ease 0s;
}

#nav .menus_items .menus_item .menus_item_child li:hover {
    background-color: #ffcfe4;
}

/* 这里的2是代表导航栏的第二个元素，即有子菜单的元素，可以按自己需求修改 */
.menus_items .menus_item:nth-child(1) .menus_item_child {
    left: -65px;
}

.menus_items .menus_item:nth-child(2) .menus_item_child {
    left: -110px;
}

.menus_items .menus_item:nth-child(3) .menus_item_child {
    left: -110px;
}

.menus_items .menus_item:nth-child(4) .menus_item_child {
    left: -40px;
}

.menus_items .menus_item:nth-child(5) .menus_item_child {
    left: -75px;
}

#nav .site-page:not(.child):after {
    border: 15px;
}
</code></pre>
<h2>使用阿里云图标</h2>
<p>1 . 前往阿里云图标官网<strong>Iconfont</strong>：<a href="https://iconfont.cn/">https://iconfont.cn/</a>
2 . 将你喜欢的图标加入购物车，随后添加到自己的项目（前提是需要登录）</p>
<blockquote>
<p>图标<code>默认是灰色</code>的，如果要保持图标是<code>彩色</code>的，需要在<code>项目设置</code>中勾选<code>彩色</code>选项</p>
</blockquote>
<p>3 . 随后，点击<code>Font Class</code>，生成链接，并打开链接，把页面中的代码复制出来。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_ali_1.png" alt="" /></p>
<p>4 . 新建一个样式文件<code>font.css</code>，把代码粘贴进去。
5 . 在主题位置文件中，将其引入。</p>
<pre><code># Inject
# Insert the code to head (before '&lt;/head&gt;' tag) and the bottom (before '&lt;/body&gt;' tag)
inject:
  head:
    - &lt;link rel="stylesheet" href="/css/font.css"&gt;
</code></pre>
<p>6 . 最后，我们就可以根据代码来将图标更改为阿里图标了。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_ali_22.png" alt="" />
7 . 可以看到，阿里的彩色图标成功换上啦！</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_ali_3.png" alt="" /></p>
<h2>网站名称及字体大小</h2>
<p><strong>新建文件</strong>：<code>source/css/custom.css</code>（可在该文件中自定义主页中任何元素）</p>
<pre><code>.menus_item { font-size: 20px;}     // 自定义导航栏字体大小
.site-name { font-size: 23px;}      // 自定义左上角名称大小
</code></pre>
<h2>导航栏圆角框及缩短居中效果</h2>
<p><strong>新建文件</strong>：<code>source/css/custom.css</code>（可在该文件中自定义主页中任何元素）</p>
<pre><code>#nav
{
    width: 95%;     // 宽度缩短5%
    left: 2.5%;     // 导航栏居中
    border-radius: 20px;  //边框圆角化
}

</code></pre>
<p><strong>打开文件</strong>：<code>ource\css\_layout\head.styl</code></p>
<p>1 . 添加下列带➕号的代码，带➖号的代码可以直接删掉。</p>
<pre><code>
#nav
  position: absolute
  top: 0
  z-index: 90
  display: flex
  align-items: center
  padding: 0 36px
-  width: 100%
  height: 60px
  font-size: 1.3em
  opacity: 0
  transition: all .5s

+  width: 70%      // 宽度缩短30%
+  left: 15%       // 导航栏居中
+  border-radius: 20px   // 边框圆角化

</code></pre>
<blockquote>
<p>解释一下：<code>custom.css</code>文件中的代码主要是将主页的导航栏圆角化并缩短居中，仅在主页有效。而<code>head.styl</code>中的代码则对文章中的导航栏产生效果。两种效果可以同时添加。</p>
</blockquote>
<h1>侧边栏</h1>
<h2>资料卡渐变背景</h2>
<p>新建样式文件<code>custom.css</code>，并粘贴以下代码：</p>
<blockquote>
<p>参考博主<code>Yan Zhang's blog</code>的<a href="https://blog.codejerry.cn/posts/hexomogai/index.html">hexo-butterfly魔改美化</a></p>
</blockquote>
<pre><code>@-webkit-keyframes shine{/*创建动画*/
    0%,100%{ color:#fff;text-shadow:0 0 10px #6ce9ff,0 0 10px #ff73ec; }
    50%{ text-shadow:0 0 10px #ffac68,0 0 40px #a0ff74; }
}
/* 侧边栏个人信息卡片动态渐变色 */
#aside-content &gt; .card-widget.card-info {
    background: linear-gradient(
      -45deg,
      #fff5e0,
      #ffe5dd,
      #ccfdff,
      #f7dbff,
      #ffdcfc
    );
    box-shadow: 0 0 5px rgb(66, 68, 68);
    position: relative;
    background-size: 400% 400%;
    -webkit-animation: Gradient 10s ease infinite;
    -moz-animation: Gradient 10s ease infinite;
    animation: Gradient 10s ease infinite !important;
  }
  @-webkit-keyframes Gradient {
    0% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
    100% {
      background-position: 0% 50%;
    }
  }
  @-moz-keyframes Gradient {
    0% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
    100% {
      background-position: 0% 50%;
    }
  }
  @keyframes Gradient {
    0% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
    100% {
      background-position: 0% 50%;
    }
  }
  
  /* 黑夜模式适配 */
  [data-theme="dark"] #aside-content &gt; .card-widget.card-info {
    background: #191919ee;
  }
  
  /* 个人信息Follow me按钮 */
  #aside-content &gt; .card-widget.card-info &gt; #card-info-btn {
    background-color: #3eb8be;
    border-radius: 8px;
  }
</code></pre>
<h2>社交图标</h2>
<h2>最近文章 &amp; 评论头像圆角</h2>
<p><strong>打开文件</strong>：<code>themes\butterfly\source\css\_layout\aside.styl</code></p>
<p>1 . 侧边栏最近文章封面圆角</p>
<pre><code>.card-recent-post
  img
   + border-radius: 20%
    overflow: hidden;
</code></pre>
<p>2 . 侧边栏评论者头像圆角</p>
<pre><code>:first-child
          @extend .imgHover
         + border-radius: 20%

</code></pre>
<p><strong>打开主题文件</strong>：<code>themes\butterfly\_config.yml</code></p>
<p>1 . 在social下添加如图所示代码即可</p>
<p>2 . 若想自定义图标，可在<a href="https://fontawesome.com/icons?from=io">Fontawesome</a>中选择并添加到代码中。</p>
<pre><code>social:
+   fa-brands fa-qq: mailto:xxxxxx@gmail.com || QQ || '#4a7dbe'
+   fab fa-github: https://github.com/xxxxx || Github || '#24292e'
+   fa-brands fa-bilibili: https://github.com/xxxxx || Bilibili || '#74C0FC'
+   fa-regular fa-envelope: mailto:xxxxxx@gmail.com || Email || '#FFD43B'
</code></pre>
<h2>目录悬停效果</h2>
<p><strong>打开文件</strong>：<code>themes\butterfly\source\css\_layout\aside.styl</code></p>
<p>1 . 我们直接把&amp;.active中的代码替换成下面代码即可。</p>
<pre><code>+  background-color: white
+  color: #626262
+  border-radius: 8px
+  box-shadow:1px 2px 3px #CFCFCF,2px 2px 3px #E4E4E4,3px 3px 3px 
+  padding: 5px
</code></pre>
<h2>仅显示文章目录</h2>
<p>1 . 这里是将侧边栏所有卡片全部隐藏，除目录卡片外，并且post卡呈现居中状态。
2 . 实现方法：先将主题配置文件中的aside参数设置为true,再aside内的所有卡片全部设置为false(除toc外)。
3 . 接下来创建一个css文件：custom.css：
4 . 将#aside-content宽度拉满，这样post卡就居中了，随后设置媒体查询，当宽度小于1600px时，不显示目录，反则显示，这样是为了防止溢出而出现滚动条。</p>
<pre><code>/* 侧边栏：目录单独存在  */
#aside-content {
    width: 0;
}
.layout&gt;div:first-child {
    width: 100%;
}
@media screen and (max-width: 1600px) {
    #aside-content #card-toc {
        display: none
    }
}
@media screen and (min-width: 1600px) {
    #aside-content #card-toc {
        width: 200px;
        box-shadow: none;
        background: transparent;
    }
}
</code></pre>
<h2>归档&amp;分类凸起样式</h2>
<p><strong>打开文件</strong>：<code>themes\butterfly\source\css\_layout\aside.styl</code></p>
<p>1 . 我们只需要添加这两行代码即可（把+号去掉即可使用）</p>
<pre><code>  .card-archives ul.card-archive-list &gt; .card-archive-list-item,
  .card-categories ul.card-category-list &gt; .card-category-list-item
    a
      display: flex
      flex-direction: row
      padding: 3px 10px
      color: var(--font-color)
      transition: all .4s
+      border-radius: 5px
      

      &amp;:hover
        padding: 3px 17px
        background-color: white
        border-radius: 6px
+        box-shadow:1px 2px 3px #CFCFCF,2px 2px 3px #E4E4E4,3px 3px 3px #D6D6D6
</code></pre>
<h2>标签悬停样式</h2>
<p><strong>打开文件</strong>：<code>themes\butterfly\source\css\_layout\aside.styl</code></p>
<p>1 . 通过鼠标悬停触发该效果。</p>
<p>2 . 可以按自己的需求添加样式代码，如下代码所示。</p>
<pre><code>  .card-tag-cloud
    a
      display: inline-block
      padding: 0 4px

      &amp;:hover
        color: hotpink !important
+        padding: 8px
</code></pre>
<h1>文章</h1>
<h2>插图圆角</h2>
<p><strong>打开文件</strong>：<code>source\css\_highlight\highlight.styl</code>
1 . 在img插入border-radius圆角代码即可，如下代码所示。</p>
<pre><code>  img
    display: block
    margin: 0 auto 20px
    max-width: 100%
    transition: filter 375ms ease-in .2s
+    border-radius: 12px
</code></pre>
<h2>代码块圆角</h2>
<p><strong>打开文件</strong>：<code>source\css\_highlight\highlight.styl</code></p>
<p>1 . 只需要在$code-block中添加个圆角样式代码即可。</p>
<pre><code>$code-block
  overflow: auto
  margin: 0 0 20px
  padding: 0
  background: var(--hl-bg)
  color: var(--hl-color)
  line-height: $line-height-code-block
+  border-radius: 12px
</code></pre>
<h2>代码块边框阴影</h2>
<p><strong>打开文件</strong>：<code>source\css\_highlight\highlight.styl</code></p>
<p>1 .  在  figure.highlight中添加边框阴影代码即可。</p>
<pre><code>  figure.highlight
    @extend $code-block
    position: relative
+    box-shadow:1px 2px 3px #292929,2px 2px 3px #E4E4E4,3px 3px 3px #D6D6D6
</code></pre>
<h2>上一篇下一篇图形圆角</h2>
<p><strong>打开文件</strong>：<code>source\css\_layout\pagination.styl</code></p>
<p>1 . 只需要在<code>&amp;.pagination-post</code>中添加个圆角样式代码即可。</p>
<pre><code>  &amp;.pagination-post
    overflow: hidden
    margin-top: 40px
    width: 100%
    background: $dark-black
+    border-radius: 12px

</code></pre>
<h2>标题小图标</h2>
<p><strong>主题配置文件</strong>：<code>themes\butterfly\_config.yml</code></p>
<blockquote>
<p>可在主题配置文件中将图标开启使用。</p>
</blockquote>
<pre><code># Beautify (美化頁面顯示)
beautify:
  enable: true
  field: post # site/post
  title-prefix-icon: '\f863'
  title-prefix-icon-color:  '#eca100'
</code></pre>
<p>1 . 我们也可以适当调整一下图标大小和位置
2 . 可以在<code>custom.css</code>自定义一以下代码，再通过<code>head</code>引入即可</p>
<pre><code>/*文章标题图标大小*/
#content-inner.layout h1::before {
    color: #ef50a8 ;
    margin-left: -1.55rem;
    font-size: 1.3rem;
    margin-top: -0.33rem;
}
#content-inner.layout h2::before {
    color: #fb7061 ;
    margin-left: -1.35rem;
    font-size: 1.1rem;
    margin-top: -0.21rem;
}
#content-inner.layout h3::before {
    color: #ffbf00 ;
    margin-left: -1.22rem;
    font-size: 0.95rem;
    margin-top: -0.15rem;
}
#content-inner.layout h4::before {
    color: #a9e000 ;
    margin-left: -1.05rem;
    font-size: 0.8rem;
    margin-top: 0rem;
}
#content-inner.layout h5::before {
    color: #57c850 ;
    margin-left: -0.9rem;
    font-size: 0.7rem;
    margin-top: 0.0rem;
}
#content-inner.layout h6::before {
    color: #5ec1e0 ;
    margin-left: -0.9rem;
    font-size: 0.66rem;
    margin-top: 0.0rem;
}
</code></pre>
<p>3 . 不仅如此，如果不喜欢图标，可以换一个图标（<a href="https://fontawesome.com/">Fontawesome</a>）
4 . 更多样式可参考：<a href="https://blog.guole.fun/posts/butterfly-custom/">我的Blog美化日记——Hexo+Butterfly</a></p>
<h2>代码高度限制</h2>
<p><strong>主题配置文件</strong>：<code>themes\butterfly\_config.yml</code></p>
<pre><code>highlight_height_limit: false # unit: px
</code></pre>
<h1>字体</h1>
<h2>全局字体</h2>
<p>1 . 我们可以在<code>主题配置文件</code>中的inject:处引用<a href="https://fonts.google.com/">Google Font</a>的字体。</p>
<p>2 . 我们打开Google Fonts，找到自己喜欢的字体，然后点击"Get Fonts"，再点击"Get embed code"，将图中所示的css链接复制到主题配置文件中的Inject：头部即可。</p>
<pre><code>inject:
  head:
+    - &lt;link rel="stylesheet" href="css/custom.css"&gt;         # Varela Round 字体
+    - &lt;link rel="preconnect" href="https://fonts.googleapis.com"&gt;   # Varela Round 字体
+    - &lt;link rel="preconnect" href="https://fonts.gstatic.com" crossorigin&gt;  # Varela Round 字体
+    - &lt;link href="https://fonts.googleapis.com/css2?family=Comic+Neue:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;family=Varela+Round&amp;display=swap" rel="stylesheet"&gt;
</code></pre>
<p>3 . 最后font：中启用该字体就可以了</p>
<pre><code>font:
  global-font-size: 17px
  code-font-size: 15px
  font-family: Varela Round, sans-serif       # 启用全局字体
  code-font-family: JetBrains Mono Medium     # 启用代码块字体
</code></pre>
<h2>站点名称字体和主页居中字体</h2>
<p>1 . 打开<code>主题配置文件</code>，在blog_title_font:处有两个空：<code>font_link</code>和<code>font-family</code>。</p>
<p>2 . 我们可在Google Fonts中选择喜欢的字体。我们选中字体，将图中两处代码分别复制到<code>font_link</code>和<code>font-family</code>中即可。</p>
<pre><code>blog_title_font:
  font_link: https://fonts.font.im/css?family=Didact+Gothic|Fredoka+One  # 引入链接
  font-family: Didact Gothic, sans-serif      # 启用字体
</code></pre>
<h1>CDN加速</h1>
<h2>jsDelivr提升访问速度</h2>
<p><strong>参考</strong>：<a href="https://macin.top/posts/67b0bef5/index.html">hexo butterfly主题自定义cdn代替jsDelivr提升访问速度</a></p>
<p>1 . 打开主题文件：<code>themes/butterfly/_config.yml</code>
2 . 找到<code>option</code>，将要加速的区域添加jsDelivr加速链接即可。</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="魔改"></category>
  </entry>
  <entry>
    <title>Butterfly美化方案【基础】</title>
    <link href="https://mizuki.mysqil.com/posts/butterfly%E7%BE%8E%E5%8C%96%E6%96%B9%E6%A1%88%E5%9F%BA%E7%A1%80/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/butterfly%E7%BE%8E%E5%8C%96%E6%96%B9%E6%A1%88%E5%9F%BA%E7%A1%80/</id>
    <published>2024-07-19T20:20:03.000Z</published>
    <updated>2024-07-19T20:20:03.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>页脚徽标</h2>
<h4>Footer_Beautify徽标插件</h4>
<p>1 . 安装插件<a href="https://github.com/Akilarlxh/hexo-butterfly-footer-beautify">Hexo-butterfly-footer-beautify</a></p>
<blockquote>
<p><code>npm install hexo-butterfly-footer-beautify --save</code></p>
</blockquote>
<p>2 . 将下列代码插入到<code>主题配置文件_config.yml</code>中即可使用</p>
<pre><code># footer_beautify
# 页脚计时器：[Native JS Timer](https://akilar.top/posts/b941af/)
# 页脚徽标：[Add Github Badge](https://akilar.top/posts/e87ad7f8/)
footer_beautify:
  enable:
    timer: true # 计时器开关
    bdage: true # 徽标开关
  priority: 5 #过滤器优先权
  enable_page: all # 应用页面
  exclude: #屏蔽页面
    # - /posts/
    # - /about/
  layout: # 挂载容器类型
    type: id
    name: footer-wrap
    index: 0
  # 计时器部分配置项
  runtime_js: https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js
  runtime_css: https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css
  # 徽标部分配置项
  swiperpara: 3 #若非0，则开启轮播功能，每行徽标个数
  bdageitem:
    - link: https://hexo.io/ #徽标指向网站链接
      shields: https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo #徽标API
      message: 博客框架为Hexo_v5.4.0 #徽标提示语
    - link: https://butterfly.js.org/
      shields: https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender
      message: 主题版本Butterfly_v3.8.2
    - link: https://www.jsdelivr.com/
      shields: https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr
      message: 本站使用JsDelivr为静态资源提供CDN加速
    - link: https://vercel.com/
      shields: https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel
      message: 本站采用双线部署，默认线路托管于Vercel
    - link: https://vercel.com/
      shields: https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&amp;logo=Codio
      message: 本站采用双线部署，联通线路托管于Coding
    - link: https://github.com/
      shields: https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub
      message: 本站项目由Github托管
    - link: http://creativecommons.org/licenses/by-nc-sa/4.0/
      shields: https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris
      message: 本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可
  swiper_css: https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiper.min.css
  swiper_js: https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiper.min.js
  swiperbdage_init_js: https://unpkg.zhimg.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js
</code></pre>
<h4>效果图</h4>
<p><img src="https://s2.loli.net/2024/07/21/qobM2U7yitdEkvO.png" alt="cd2ad8d3051db874556f30914adf7a11.png" /></p>
<h2>侧边栏插件</h2>
<h4>那年今日</h4>
<p>1 . 这个插件，可以在侧边栏中显示过去的今天所发生过的事情，还是挺有意思的。
2 . 教程也很简单，我们直接安装这个插件。</p>
<blockquote>
<p><code>npm i hexo-history-calendar --save</code></p>
</blockquote>
<p>3 . 最后在配置文件Config.yml插入下列代码，启用即可。</p>
<pre><code>## history_calendar那年今日
history_calendar:
  priority: 4
  enable: true
  enable_page: all
  layout:
    type: class
    name: sticky_layout
    index: 0
  temple_html: '&lt;div class="card-widget card-history"&gt;&lt;div class="card-content"&gt;&lt;div class="item-headline"&gt;&lt;i class="fas fa-clock fa-spin"&gt;&lt;/i&gt;&lt;span&gt;往年今日&lt;/span&gt;&lt;/div&gt;&lt;div id="history-baidu" style="height: 100px;overflow: hidden"&gt;&lt;div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"&gt;&lt;div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;'

</code></pre>
<h4>效果图</h4>
<p><img src="https://s2.loli.net/2024/07/21/oYSUyqQXg4hFCR5.png" alt="9c4e1ccea17d35109035eedc1de9a5e4.png" /></p>
<h2>关于页面</h2>
<h4>技能展示</h4>
<p>1 . Skill Icons官网：<a href="https://skillicons.dev/">https://skillicons.dev/</a>
2 . Github：<a href="https://github.com/tandpfun/skill-icons/tree/main?tab=readme-ov-file#centering-icons">https://github.com/tandpfun/skill-icons/tree/main?tab=readme-ov-file#centering-icons</a></p>
<p>3 . 可以按照Github中的<code>README.md</code>教程来设置图标。
4 . 教程提供了4种方法分别是：</p>
<blockquote>
<p>只需要将下列链接或代码粘贴到文档中即可使用。
按照自己的需求，可以自定义链接中的图标名称：<code>icons?i=[技能名称],[...],[...],[...]</code>
对于的技能名称可以在<code>README.md</code>中找到。</p>
</blockquote>
<ul>
<li>Specifying Icons</li>
</ul>
<pre><code>[![My Skills](https://skillicons.dev/icons?i=js,html,css,wasm)](https://skillicons.dev)
</code></pre>
<ul>
<li>Themed Icons</li>
</ul>
<pre><code>[![My Skills](https://skillicons.dev/icons?i=java,kotlin,nodejs,figma&amp;theme=light)](https://skillicons.dev)

</code></pre>
<ul>
<li>Icons Per Line</li>
</ul>
<pre><code>[![My Skills](https://skillicons.dev/icons?i=aws,gcp,azure,react,vue,flutter&amp;perline=3)](https://skillicons.dev)

</code></pre>
<ul>
<li>Centering Icons</li>
</ul>
<pre><code>&lt;p align="center"&gt;
  &lt;a href="https://skillicons.dev"&gt;
    &lt;img src="https://skillicons.dev/icons?i=git,kubernetes,docker,c,vim" /&gt;
  &lt;/a&gt;
&lt;/p&gt;
</code></pre>
<p>5 . 如果觉得上面链接图片加载很慢，可以将将其以svg的格式保存在本地使用。例如：</p>
<p>6 . 打开链接：<a>https://skillicons.dev/icons?i=html,css,python,cs,dotnet,markdown&amp;theme=dark</a></p>
<p>7 . 右键查看页面源代码，将源代码复制到新建文件，并重命名格式为.svg即可。</p>
<h2>页面加载</h2>
<p><strong>参考</strong>：<a href="https://happylee.cn/post/butterfly-loading/">一款基于Butterfly主题的loading动画</a></p>
<h2>主页顶部视频背景</h2>
<blockquote>
<p><strong>参考文章：</strong><a href="https://sarakale.top/blog/posts/3ecfae3a">butterfly 主题首页图背景替换为视频</a>
主题版本：4.x</p>
</blockquote>
<p>1 . 我们首先在<code>主题文件</code>设置好一个图片背景</p>
<pre><code>index_img: img/background/2.png
</code></pre>
<p>2 . 随后只需要在<code>themes\butterfly\layout\includes\header\index.pug</code>修改些代码即可</p>
<p>3 . 我们在文件的第3行插入这段代码：<code>- var top_img = false</code>，把图片背景禁用掉。</p>
<pre><code>if !theme.disable_top_img &amp;&amp; page.top_img !== false
  if is_post()
+    - var top_img = false
    - var top_img = page.top_img || page.cover || theme.default_top_img
  else if is_page()
.......
</code></pre>
<p>4 . 在第38行和第41行分别插入这两段代码：<code>- var isHomeClass = 'not-top-img'</code>和<code>video(src=...</code></p>
<pre><code>  if top_img !== false
    if is_post()
+      - var isHomeClass = 'not-top-img'
      include ./post-info.pug
    else if is_home() 
+      video(src='视频文件地址.mp4' autoplay="" loop="" muted="" style='min-height:100%;height:100%;width:100%;object-fit:cover')
      #site-info
</code></pre>
<p>5 . 到这里就大功告成了，教程参考<a href="https://sarakale.top/blog/posts/3ecfae3a">butterfly 主题首页图背景替换为视频</a>为准</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="魔改"></category>
  </entry>
  <entry>
    <title>Butterfly主题魔改日志</title>
    <link href="https://mizuki.mysqil.com/posts/butterfly%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9%E6%97%A5%E5%BF%97/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/butterfly%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9%E6%97%A5%E5%BF%97/</id>
    <published>2024-07-18T15:55:41.000Z</published>
    <updated>2024-07-18T15:55:41.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>插件包</h2>
<pre><code>.
├── hexo-wordcount
└── hexo-history-calendar
└── hexo-butterfly-footer-beautify
└── hexo-generator-search
└── hexo-butterfly-swiper
└── live2d-widget
......
</code></pre>
<blockquote>
<p>hexo-wordcount（字数统计）:  <a href="https://github.com/willin/hexo-wordcount">Github</a>
hexo-history-calendar（往年今事）: <a href="https://www.jsdelivr.com/package/npm/hexo-history-calendar">jsdelivr</a>
hexo-butterfly-footer-beautify（页脚美化）:  <a href="https://github.com/Akilarlxh/hexo-butterfly-footer-beautify">Github</a>
hexo-generator-search（本地搜索）:  <a href="https://github.com/wzpan/hexo-generator-search">Github</a>
hexo-butterfly-swiper(置顶文章轮播卡片) : <a href="https://github.com/Akilarlxh/hexo-butterfly-swiper">Github</a>
live2d-widget(Lived2d看板娘) : <a href="https://github.com/stevenjoezhang/live2d-widget">Github</a></p>
</blockquote>
<h2>2024 Butterfly更新日志</h2>
<p>{% timeline 7月 %}</p>
<p>&lt;!-- timeline 7月17日 --&gt;</p>
<p>1 . 添加 侧边栏的那年今日插件</p>
<p>2 . 添加 搜索功能插件</p>
<p>3 . 添加 友人帐</p>
<p>4 . 添加 页脚徽标插件</p>
<p>5 . 添加 页面加载动画Pace</p>
<p>6 . 修改 侧边栏最近文章图片边框样式为：圆角</p>
<p>7 . 修改 侧边栏头像样式为：禁用动画</p>
<p>8 . 修改 侧边栏名称字体样式为：Comic Sanc MS</p>
<p>9 .  修改 文章中图片样式边框为：圆角</p>
<p>10 . 修改 友人帐鼠标悬停动画样式为：立体效果</p>
<p>11 . 修改 友人帐极速导航边框样式：青色虚线</p>
<p>&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 7月18日 --&gt;</p>
<p>1.添加 标签页面</p>
<p>2.添加 分类页面</p>
<p>3.添加 社交小图标</p>
<p>4.添加 页面背景</p>
<p>5.启动文章超时提醒</p>
<p>6.启动 繁体简体转换功能</p>
<p>7.添加 左上角LOGO及顶部标题字体样式</p>
<p>8.修改 侧边栏分类&amp;归档的悬停动画样式为：立体效果</p>
<p>6.修改 侧边栏戳一下按钮悬停动画样式为：立体效果</p>
<p>7.修改 侧边栏标签悬停动画样式为：扩张效果</p>
<p>8.修改 侧边栏社交小图标样式为：禁过渡动画</p>
<p>9.修改 滚动条颜色样式为：热粉</p>
<p>10.修改 侧边栏&amp;导航栏小图标</p>
<p>11.修改 标签&amp;归档%分类页面为：不显示顶部封面</p>
<p>12.修改 侧边栏目录悬停动画样式为：立体效果</p>
<p>13.修改 文章代码块边框样式为：圆角</p>
<p>14.修改 页脚背景样式为：透明渐变</p>
<p>15.关闭 顶部封面（默认为若没有封面，则不留白）</p>
<p>16.修改 文章代码块边框样式为：圆角</p>
<p>17.修改 文章上下篇图形边框样式为：圆角</p>
<p>&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 7月18日 --&gt;</p>
<p>1.添加 关于我页面</p>
<p>1.修改 导航栏边框样式为：圆角 <code>source/css/custom.css</code></p>
<p>2.修改 导航栏位置：居中</p>
<p>3.修改 背景为：svg格式</p>
<p>4.启用 代码高度限制</p>
<p>5 . 更换 全局字体为：Varela Round</p>
<p>&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 7月20日 --&gt;</p>
<p>1 . 修复 友人帐圆角不匹配问题</p>
<p>2 . 更换 主页顶部壁纸</p>
<p>&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 7月21日 --&gt;</p>
<p>1 . 调整 主页文章列表边框高度及内容大小
2 . 修复 导航栏字体大小不对等问题</p>
<p>&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 7月22日 --&gt;</p>
<p>1 . 新增 萌ICP备案徽标</p>
<p>&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 7月24日 --&gt;
1 . 引入 Jetbrains Mono字体作为代码字体
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 7月25日 --&gt;
1 . 移除 页脚渐变效果
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 7月28日 --&gt;
1 . 移除 导航栏工具栏
2 . 添加 导航栏算法
3 . 优化 图片和插图采用chinajsdelivrCDN通道加速。
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 7月31日 --&gt;
1 . 开启 不显示顶部图<code>disable_top_img</code>，<code>index_img</code>
2 . 关闭 主页封面
3 . 关闭 侧边栏分类卡片
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 7月31日 --&gt;
1 . 开启 文章标题图标并调整样式
&lt;!-- endtimeline --&gt;</p>
<p>{% endtimeline %}</p>
<p>{% timeline 8月,green %}</p>
<p>&lt;!-- timeline 8月4日 --&gt;
1 . 添加 相册页面
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 8月6日 --&gt;
1 . 添加 Waline评论系统
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 8月7日 --&gt;
1 . 添加 文章字数统计插件
2 . 新增 友链极速导航站点
3 . 修改 侧边栏评论者头像边框样式：圆角
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 8月11日 --&gt;
1 . 修改 导航栏边框圆角为100px
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 8月12日 --&gt;
1  .添加 CDN(jsDelivr)提升页面加载速度
2 . 添加 页面加载动画
&lt;!-- endtimeline --&gt;
{% endtimeline %}</p>
<p>{% timeline 10月, pink%}
&lt;!-- timeline 10月2日 --&gt;
1 . 添加 live2d看板娘
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 10月3日 --&gt;
1 . 更新 文章顶部封面为 一图流背景
2 . 更新 页脚美化
3 . 调整 主页文章卡片长度
4 . 调整 所有卡片及其文章背板背景为 半透明色
5 . 添加 置顶文章轮播卡片
6 . 调整 主页顶部轮播标题大小及位置
7 . 关闭 顶部视频
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 10月3日 --&gt;
1 . 新增 FPS帧率检测显示功能
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 10月25日 --&gt;
1 . &lt;b style="color:red"&gt;Butterfly主题已更新至5.1.0&lt;/b&gt;
2 . 修复引用块圆角边框
&lt;!-- endtimeline --&gt;
{% endtimeline %}</p>
<p>{% timeline 11月, orange%}
&lt;!-- timeline 11月2日 --&gt;
1 . 更新友联失联名单，友联边框及其申请信息注意点
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 11月6日 --&gt;
1 . 更新 主页标题及轮播文字 为荧光文字效果
2 . 更新 导航栏图标 为阿里云矢图标
3 . 更新 侧边栏个人资料卡背景 为渐变色
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 11月7日 --&gt;
1 . 更新 全局字体为 筑紫A丸子
2 . 更改 全局字体为 造字工房悦圆演示版常规体
3 . 关闭 主页轮播文章插件
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 11月7日 --&gt;</p>
<blockquote>
<p>由于使用了过渡动画，导致页面变得异常卡顿，所以我选择使用静态渐变色</p>
</blockquote>
<p>1 . 关闭 主页标题及轮播文字的荧光文字效果
2 . 关闭 侧边栏个人资料卡及版权卡背景的 动态（动画）渐变色
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 11月7日 --&gt;
1 . 使用<strong>中文网字计划</strong>CDN引入字体
2 . 更改 全局字体为 霞鹜文楷
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 11月12日 --&gt;
1 . 更新 博客背景图使用 随机壁纸API接口 (<a href="https://api.miaomc.cn/image/">API来源</a>)
2 . 更换 live2d看板娘 图源cdnPath API接口 (<a href="https://akilar.top/posts/5b8f515f/">API来源</a>)
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 11月16日 --&gt;
1 . 新增 页面 我的设备
2 . 重构 页面 我的装备
3 . 更新 导航栏顺序
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 11月22日 --&gt;
1 . 新增 日志时间轴
2 . 调整 魔改日志 为时间轴结构
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 11月23日 --&gt;
1 . 调整 文章背景卡与主页卡片圆角度为:12px
&lt;!-- endtimeline --&gt;
{% endtimeline %}</p>
<h2>2025 Butterfly更新日志</h2>
<p>{% timeline 2月 %}</p>
<p>&lt;!-- timeline 2月7日 --&gt;</p>
<blockquote>
<p>好久没更新过blog了，看了一下，打算重新魔改一个样式，顺便升级一下BF的版本。其实，我也不知道改成什么样，只是觉得越简约越好，后来，在萌ICP看到了博主：<a href="https://noionion.top/">贰猹の小窝</a>,由此产生了灵感，所以后面的样式走向，也基本和该博主的差不多......
1 . &lt;b style="color:red"&gt;Butterfly主题已更新至5.3.2&lt;/b&gt;
2 . 关闭侧边栏
3 . 全局背景改为：渐变色
4 . 导航栏居中化
5 . 替换大部分矢量图标
6 . 导航栏背景关闭半透明状
&lt;!-- endtimeline --&gt;</p>
</blockquote>
<p>&lt;!-- timeline 2月8日 --&gt;
1 . 单独设置文章右侧的目录卡
&lt;!-- endtimeline --&gt;</p>
<p>{% endtimeline %}</p>
<p>&lt;!-- timeline 7月24日 --&gt;
1 . 关闭外链字体源，全局使用'Consolas'
&lt;!-- endtimeline --&gt;</p>
<p>{% timeline 7月 %}</p>
<p>&lt;!-- timeline 7月24日 --&gt;
1 . 关闭外链字体源，全局使用'Consolas'
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 7月26日 --&gt;
1 . 更换友人帐各友链的卡片边框样式
2 . 更换所有页面主卡片边框样式
3 . 更换导航栏子选项卡边框样式
4 . 更换文章版权卡片边框样式
&lt;!-- endtimeline --&gt;</p>
<p>&lt;!-- timeline 7月27日 --&gt;
1 . 重新启动评论区
&lt;!-- endtimeline --&gt;</p>
<p>{% endtimeline %}</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="魔改"></category>
  </entry>
  <entry>
    <title>Linux学习笔记：Fedora操作系统的介绍与部署【2】</title>
    <link href="https://mizuki.mysqil.com/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0fedora%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E9%83%A8%E7%BD%B22/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0fedora%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E9%83%A8%E7%BD%B22/</id>
    <published>2024-07-15T23:22:32.000Z</published>
    <updated>2024-07-15T23:22:32.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_fedora_1.png" alt="img" /></p>
<h2>什么是Fedora？</h2>
<ol>
<li>
<p><strong>Fedora</strong>是一种<strong>基于Linux的操作系统</strong>，由社区支持和开发。<strong>Fedora是一个免费开源的操作系统</strong>，提供了最新的软件和技术，适用于开发人员、系统管理员和普通用户。Fedora采用RPM软件包管理系统，并<strong>使用GNOME桌面环境作为默认桌面</strong>。Fedora还提供了许多工具和应用程序，如编程语言、开发工具、办公软件等，使用户能够轻松地完成各种任务。</p>
</li>
<li>
<p>Fedora是由Fedora项目社区开发、红帽公司赞助，目标是创建一套新颖、多功能并且自由（开放源代码）的操作系统。Fedora是商业化的Red Hat Enterprise Linux发行版的上游源码。</p>
</li>
<li>
<p>Fedora是一个以社区为基础的Linux操作系统，由Fedora Project社区维护，并由红帽（Red Hat）公司提供赞助。它以其快速的创新和对开源软件的承诺而闻名。Fedora是许多其他Linux发行版的基础，包括红帽企业Linux（RHEL）。</p>
</li>
<li>
<p><strong>特点</strong>：</p>
</li>
</ol>
<ul>
<li><strong>更新速度快</strong>：Fedora每六个月发布一个新的版本，确保用户能够快速获得最新的软件和功能。</li>
<li><strong>稳定性</strong>：尽管更新速度快，但Fedora的每个版本都会在正式发布前经过严格的测试，以确保稳定性。</li>
<li><strong>社区驱动</strong>：Fedora由一群志愿者和开发者社区管理，他们贡献代码、文档、设计和翻译。</li>
</ul>
<h2>部署Fedora Workstation</h2>
<h5>版本选择</h5>
<ol>
<li>
<p>Fedora官方提供了多种不同的Fedora Linux 变种版本，适用于不同用途，如Workstation，Server，CoreOS，Iot，Cloud。不仅如此，还提供了定制版，如KDE桌面版，Xfce，LXDE，Budgie等等。</p>
</li>
<li>
<p>但为了方便，本次我们安装<strong>Fedora Workstation</strong>作为Linux发行版的学习对象。</p>
</li>
</ol>
<h4>下载镜像</h4>
<ol>
<li>首先我们需要下载Fedora Workstation的镜像。可在官网下载。</li>
</ol>
<ul>
<li>Fedora官网：<a href="https://fedoraproject.org/zh-Hans/workstation/download">https://fedoraproject.org/zh-Hans/workstation/download</a></li>
</ul>
<ol>
<li>下载完成后会得到一个.iso镜像。</li>
<li>下面打开VMware虚拟机。</li>
</ol>
<h4>配置虚拟机</h4>
<ol>
<li>这里我仅在虚拟机中进行演示，如果有时间，我会重新写一篇在主机中安装Fedora的文章。那这里废话不多说……</li>
<li>启动VMware，点击创建新的虚拟机。</li>
<li>在“安装程序光盘映像文件”中选择好下载好的Fedora镜像文件.iso。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_fedora_2.png" alt="img" /></p>
<ol>
<li>
<p>在下一步我们需要为安装系统选择一个本地的虚拟硬盘空间，预计分配<strong>40-50GB</strong>的空间即可（宁可多分配点，也不要分少）。</p>
</li>
<li>
<p>点击下一步。</p>
</li>
<li>
<p>这里是即将准备创建的虚拟机配置信息，当然，如果对配置有意见，可以自定义硬件，比如修改内存分配，CPU核心之类的。</p>
</li>
<li>
<p>内存：建议内存分配至少4GB以上，以保证系统稳定运行。</p>
</li>
<li>
<p>处理器：至少分配<strong>2</strong>个核心（帮不能超过本地主机运行所需的核心数）</p>
</li>
<li>
<p>最后点击完成，即可完成创建虚拟机。</p>
</li>
</ol>
<h4>部署Fedora Workstation系统</h4>
<ol>
<li>
<p>开机后我们会进入到Fedora Workstation的安装向导（该系统和Ubuntu一样人性化，安装门槛较低）</p>
</li>
<li>
<p>所以接下来的事就更简单啦。</p>
</li>
<li>
<p>我们为安装选择一个磁盘位置。</p>
</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_fedora_3.png" alt="img" /></p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_fedora_4.png" alt="img" /></p>
<ol>
<li>在储存配置中，勾选自动配置，和通过删除或压缩已有分区释放空间。</li>
<li>按照如下，逐步点击全部删除和回收空间</li>
<li>最后点击完成即可开始安装。</li>
<li>当安装完成后，右上角重启即可。</li>
</ol>
<h4>使用前配置</h4>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_fedora_5.png" alt="img" /></p>
<ol>
<li>启动后，我们需要开始配置一下使用项。</li>
<li>其实很简单：</li>
<li>首先是<strong>启动第三方软件安装权限</strong>，设置用户名，和密码即可</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_fedora_6.png" alt="img" /></p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_fedora_7.png" alt="img" /></p>
<h2>结束</h2>
<ol>
<li>Fedora操作系统的安装就到此为止吧。</li>
<li>总体来说，相对于其他Linux发行版（Arch，Debian，Manjaro）Fedora的部署会更简单些，和Windows一样有安装向导，可以说无脑安装。</li>
<li>当我看到Fedora的桌面的那一刻，两个字：“简约”。太简约了，给人一种清爽便捷的视觉体验，当然了，UI，动画之类的也做得相当不错，很舒服。</li>
<li>本次安装的是Fedora Workstation，是一款<strong>适用于笔记本电脑和台式电脑的精美、易于使用的操作系统</strong>，所以桌面看上去会十分的简约，代价是我们无法使用更多的linux功能，如果希望使用更多的功能可以体验KDE版本……。</li>
<li>当然了，安装Fedora也只是我们临时作为Linux的学习对象。我们不会用它做过多的事。</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="Linux"></category>
  </entry>
  <entry>
    <title>Adobe Photoshop CC20xx版本资源下载</title>
    <link href="https://mizuki.mysqil.com/posts/adobe-photoshop-cc20xx%E7%89%88%E6%9C%AC%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/adobe-photoshop-cc20xx%E7%89%88%E6%9C%AC%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD/</id>
    <published>2024-07-13T13:30:20.000Z</published>
    <updated>2024-07-13T13:30:20.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p>Adobe Photoshop，简称“PS”和“Ps”，是由Adobe Systems开发和发行的图像处理软件。Photoshop主要处理以像素所构成的数字图像。使用其众多的编修与绘图工具，可以有效地进行图片编辑和创造工作。
PS有很多功能，在图像、图形、文字、视频、出版等各方面都有涉及。</p>
</blockquote>
<p><strong>免责声明</strong>：本站所发布的一切破解补丁、注册机和注册信息及软件的解密分析文章仅限用于学习和研究目的；不得将上述内容用于商业或者非法用途，否则，一切后果请用户自负。本站信息来自网络，版权争议与本站无关。您必须在下载后的24个小时之内，从您的电脑中彻底删除上述内容。如果您喜欢该程序，请支持正版软件，购买注册，得到更好的正版服务。</p>
<h3>20xx版本总览</h3>
<ol>
<li>本期包含了Adobe Photoshop图像处理软件从CC2020版本到CC2024版本的下载资源，在下载前请注意免责声明。‘</li>
<li>提取码：<em>PSxx</em></li>
</ol>
<table>
<thead>
<tr>
<th>版本</th>
<th>大小</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adobe Photoshop CC2024</td>
<td>xxGB</td>
<td></td>
</tr>
<tr>
<td>Adobe Photoshop CC2023</td>
<td>3.20GB</td>
<td><a href="https://www.123pan.com/s/SrvWjv-035gh.html">https://www.123pan.com/s/SrvWjv-035gh.html</a></td>
</tr>
<tr>
<td>Adobe Photoshop CC2021</td>
<td>xxGB</td>
<td></td>
</tr>
<tr>
<td>Adobe Photoshop CC2020</td>
<td>1.77GB</td>
<td><a href="https://www.123pan.com/s/SrvWjv-r35gh.html">https://www.123pan.com/s/SrvWjv-r35gh.html</a></td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="白嫖"></category>
  </entry>
  <entry>
    <title>Linux学习笔记：前言与操作系统的初识【1】</title>
    <link href="https://mizuki.mysqil.com/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%89%8D%E8%A8%80%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%9D%E8%AF%861/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%89%8D%E8%A8%80%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%9D%E8%AF%861/</id>
    <published>2024-06-22T13:26:20.000Z</published>
    <updated>2024-06-22T13:26:20.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>前言</h2>
<h3>为什么学习Linux</h3>
<ol>
<li>作为当下最流行的操作系统之一，学会如何使用和操作Linux操作系统也就是每位计算机学者的看家必备技能了。</li>
<li>其次呢，本人受Linux的创始人林纳斯的影响太深了，觉得这个人太了不起了，而且人家大学里就自研开发出了Linux，所以我也想尝试一下学习Linux。</li>
<li>我对每个操作系统的UI和功能都非常痴迷，甚至会花很多时间来美化系统桌面，如果哪天我能按照自己的想法开发出一款定制的操作系统那可太棒了，所以呢，开发一款操作系统也是我毕生的梦想（<strong>虽然这个梦想实则遥远，可以说是根本不可能</strong>）</li>
<li>对于Linux，我猜想到了大学也还是要学的，所以趁高考毕业后可以好好学一下，提前巩固，到了大学会更加轻松一点。</li>
</ol>
<h3>准备</h3>
<ol>
<li>虽然说，对于普通人来讲，Linux学起来会特别难，但这个世界上没有什么东西天生是人能学会的，我还是相信林纳斯所说过的一句话：“创造操作系统，就是去创造一个所有应用程序赖以运行的基础环境。从根本上来说，就是在制定规则：什么可以接受，什么可以做，什么不可以做。事实上，所有的程序都是在制定规则，只不过操作系统是在制定最根本的规则。”，是的，我只会认为我是在学习和遵循这么一种规则，但事成之后，我们可以打破这个规则。</li>
<li>我想，这个世界应该没有什么事情让我比学习计算机技术知识更专注的了吧？（除了游戏）</li>
<li>时间会证明一切的，当我的博客中的Linux学习笔记达到了20篇以上，我相信，那就是成功的象征。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_linux1_1.png" alt="在这里插入图片描述" /></p>
<h2>操作系统</h2>
<h3>什么是操作系统？</h3>
<ol>
<li><strong>操作系统</strong>（英文：Operating System；简称：OS）是一种内置的程序，用来协作计算机的各种硬件，以与用户进行交互。常见的操作系统有Windows，macOS 和 Linux。</li>
<li>根据运行的环境，操作系统可以分为桌面操作系统，手机操作系统，服务器操作系统，嵌入式操作系统等。 [12]</li>
<li>操作系统是人与计算机之间的接口。 [14]</li>
<li>操作系统属于特殊类的计算机软件，它负责管理计算机硬件资源，为计算机上运行的其他软件提供运行环境和控制机制，同时也为用户提供了与计算机交互的界面。操作系统的主要功能包括进程管理、内存管理、文件系统管理、输入/输出设备管理等。</li>
<li>操作系统能够管理和控制（调度）计算机硬件，如内存，处理器，显卡，网卡……</li>
<li>在了解操作系统之前，我们还需要熟知计算机系统中的软件和硬件。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_linux1_6.png" alt="在这里插入图片描述" /></p>
<h4>软件</h4>
<p>首先，软件是一组指令和数据，它告诉计算机如何执行特定的任务和操作。软件可以分为两大类：<strong>系统软件</strong>和<strong>应用软件</strong>。</p>
<ul>
<li>
<p>系统软件：它提供了硬件运行的基本功能和计算机操作的基础环境。包括操作系统（如Windows、macOS、Linux）、设备驱动程序、诊断工具、服务器软件、窗口系统和实用程序等。</p>
</li>
<li>
<p>应用软件：它是为了帮助用户执行特定的任务而设计的程序。例如，文字处理软件（如Microsoft Word）、网页浏览器（如Google Chrome）、电子邮件客户端、图形和视频编辑软件、数据库管理系统等。</p>
</li>
</ul>
<h4>硬件</h4>
<ol>
<li>
<p>硬件（英文名Hardware）是计算机硬件的简称，是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。这些物理装置按系统结构的要求构成一个有机整体为计算机软件运行提供物质基础。</p>
</li>
<li>
<p>简而言之，硬件的功能是输入并存储程序和数据，以及执行程序把数据加工成可以利用的形式。从外观上来看，微机由主机箱和外部设备组成。主机箱内主要包括CPU、内存、主板、硬盘驱动器、光盘驱动器、各种扩展卡、连接线、电源等；外部设备包括鼠标、键盘等。</p>
</li>
<li>
<p>举个简单例子：我们模拟一个用户A发送信息给用户B</p>
</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_linux1_2.png" alt="在这里插入图片描述" /></p>
<blockquote>
<p>在计算机中，操作系统是其最基本也是最为重要的基础性系统软件。从计算机用户的角度来说，计算机操作系统体现为其提供的各项服务；从程序员的角度来说，其主要是指用户登录的界面或者接口；如果从设计人员的角度来说，就是指各式各样模块和单元之间的联系。事实上，全新操作系统的设计和改良的关键工作就是对体系结构的设计，经过几十年以来的发展，计算机操作系统已经由一开始的简单控制循环体发展成为较为复杂的分布式操作系统，再加上计算机用户需求的愈发多样化，计算机操作系统已经成为既复杂而又庞大的计算机软件系统之一。</p>
</blockquote>
<h3>常见的操作系统</h3>
<h4>Windows</h4>
<ol>
<li>我们对Windows操作系统再熟悉不过了 ，它是有美国微软公司开发的以<strong>图形用户界面</strong>为基础研发的操作系统。</li>
<li>Windows操作系统主要运用于计算机、智能手机等设备。共有普通版本、服务器版本（Windows Server）、手机版本（Windows Phone等）、嵌入式版本（Windows CE等）等子系列，是全球应用最广泛的操作系统之一。</li>
<li>Windows操作系统在经过几十年的发展，如今已更新到更先进智能的Windows11系统。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_linux1_3.png" alt="在这里插入图片描述" /></p>
<h4>MacOS</h4>
<ol>
<li>MacOS是一套由美国苹果公司开发的运行于Macintosh系列电脑上的操作系统。它是首个在商用领域成功的<strong>图形用户界面</strong>操作系统。</li>
<li>MacOS基于UNIX开发，是Macintosh操作系统的前身。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_linux1_4.png" alt="在这里插入图片描述" /></p>
<h4>Linux</h4>
<ol>
<li>Linux一般指GNU/Linux（单独的Linux内核并不可直接使用，一般搭配GNU套件，故得此称呼），是一种免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹（Linus Benedict Torvalds）于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。它支持32位和64位硬件，能运行主要的Unix工具软件、应用程序和网络协议。</li>
<li>Linux是完全开放源代码的，这些对于Windows和Mac更加经济。常用于服务器领域。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_linux1_5.png" alt="在这里插入图片描述" /></p>
<h2>结语</h2>
<ol>
<li>本期主要简单的讲解一下我对学习Linux的看法，和操作系统的基本认识。</li>
<li>所以就不过多的赘述了。</li>
</ol>
<p>​</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="Linux"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_多态【十九】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%A4%9A%E6%80%81%E5%8D%81%E4%B9%9D/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%A4%9A%E6%80%81%E5%8D%81%E4%B9%9D/</id>
    <published>2024-06-17T21:10:18.000Z</published>
    <updated>2024-06-17T21:10:18.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>前言</h2>
<ol>
<li>个人觉得多态在面向对象编程中还比较重要的，而且不容易理解。</li>
<li>也是学了一个下午，才把笔记写得相对比较完善，但仍欠缺一些内容。</li>
<li>慢慢来吧……</li>
</ol>
<h1>什么是多态？</h1>
<h2>基本概念</h2>
<ol>
<li>在编程语言和类型论中，多态（<strong>Polymorphism</strong>）指为不同数据类型的实体提供统一的接口。 多态类型（<strong>Polymorphic Type</strong>）可以将自身所支持的操作套用到其它类型的值上。</li>
<li><strong>多态是面向对象编程（OOP）的一个基本概念，是面向对象的三大特征之一</strong>。它允许不同的对象对同一消息做出响应，但具体的行为会根据对象的实际类型而有所不同。在C#中，多态主要通过继承和接口实现。本文将探讨多态的基本概念、实现方式以及在C#中的一些实际应用。</li>
<li>多态性可以定义为允许不同类的对象对同一消息做出响应的能力，但具体响应取决于消息接收者的实际类型。简单来说，多态性允许我们编写更通用的代码，可以处理不同类型的对象。</li>
</ol>
<h2>多态的作用</h2>
<p><strong>1. 接口实现</strong>：多态使得一个接口可以有多种不同的实现方式。子类可以重写父类的方法，以提供特定的实现。</p>
<p><strong>2. 代码复用</strong>：通过继承和多态，可以减少代码的重复编写，提高代码的复用性。</p>
<p><strong>3. 灵活性和扩展性</strong>：多态允许程序在不修改现有代码的情况下，通过增加新的子类来扩展功能。</p>
<p><strong>4. 解耦</strong>：多态减少了代码之间的耦合度。高层模块可以操作抽象类型，而具体的实现可以由子类提供，这使得高层模块不依赖于具体实现。</p>
<p><strong>5. 动态绑定</strong>：在运行时，多态允许调用正确的方法版本，这是通过动态绑定或晚期绑定实现的。</p>
<p><strong>6. 简化复杂性</strong>：多态简化了处理复杂系统的方式，因为可以使用统一的接口来处理不同类型的对象。</p>
<p><strong>7. 支持开放/封闭原则</strong>：多态支持开放/封闭原则，即软件实体应该对扩展开放，对修改封闭。这意味着可以在不改变现有代码的基础上增加新功能。</p>
<p><strong>8. 提高代码的可维护性</strong>：由于多态减少了代码间的依赖，因此当需要修改或更新时，可以更容易地进行维护。</p>
<p><strong>9. 支持设计模式</strong>：多态是许多设计模式的基础，如工厂模式、策略模式等，这些模式可以进一步增强代码的灵活性和可维护性。</p>
<p><strong>10. 促进面向对象设计</strong>：多态是面向对象设计的核心概念之一，它鼓励开发者采用面向对象的方法来思考和解决问题。</p>
<p>在C#中实现多态，通常涉及到接口、抽象类和虚方法的使用。通过这些机制，开发者可以创建灵活且可扩展的应用程序。</p>
<h1>多态的实现方法</h1>
<h2>虚方法重写</h2>
<ol>
<li>虚方法（Virtual Methods）和方法重写（Override）是实现多态的两种机制，它们允许子类改变继承自父类的行为。</li>
<li><strong>虚方法（Virtual Methods）</strong></li>
</ol>
<blockquote>
<ul>
<li><em>定义</em>：虚方法是在基类中使用virtual关键字声明的方法，它允许在派生类中被重写。</li>
<li><em>目的</em>：虚方法的目的是为了在派生类中提供特定于派生类的行为。</li>
<li><em>调用</em>：虚方法可以在基类中被调用，也可以在派生类中被调用，调用哪个方法取决于对象的运行时类型。</li>
<li>使用场景：当你希望提供一个默认的行为，并且允许派生类根据需要修改这个行为时，使用虚方法。</li>
</ul>
</blockquote>
<ol>
<li><strong>方法重写（Override）</strong></li>
</ol>
<blockquote>
<ul>
<li>定义：方法重写是在派生类中使用override关键字来重写基类中的虚方法。</li>
<li>目的：方法重写的目的是为了提供与基类不同的实现，以适应派生类的具体需求。</li>
<li>调用：方法重写只能在派生类中调用，用于改变或扩展基类的行为。</li>
<li>使用场景：当你需要根据派生类的特性来改变基类方法的行为时，使用方法重写。</li>
</ul>
</blockquote>
<p><img src="https://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_duotai_1.png" alt="在这里插入图片描述" /></p>
<p><strong>注意：<em>虚方法重写不能出现在同一个类中，重写方法必须在派生类中</em></strong>
5. 看实例：C#中的virtual关键字允许我们定义一个可以在派生类中被重写的方法。我们先定义一个Fruit类，在里面用virtual关键字写一个Apple( )方法，看的出来，被virtual修饰符修饰的方法我们称它为虚方法。</p>
<pre><code>public class Fruit
{
    public virtual void Apple()
    {
        Console.Write("我是一个苹果");
    }
}
</code></pre>
<ol>
<li>在写完虚方法后，我们再定义一个继承Fruit类的派生类RedFuJiApple。在里面写一个重写方法Apple( )，什么叫重写呢？说明白点，就是把上面的虚方法重写，重写方法要用override关键字修饰。</li>
</ol>
<pre><code>public class RedFuJiApple():Fruit
{
    public override void Apple()
    {
        Console.Write("我是一个红富士苹果");
    }
}
</code></pre>
<ol>
<li>最后执行代码，会发现：原本调用RedFuJiApple对象时，输出的应该是父类被继承的Apple方法，但因为我们在派生类中重写了Apple方法，所以最终输出的是：“我是一个红富士苹果"。父类中被重写的虚方法相当于被覆盖掉了。</li>
</ol>
<pre><code>Fruit Eat = new RedFuJiApple();
Eat.Apple();
</code></pre>
<h2>函数重载</h2>
<ol>
<li>函数重载（Function Overload）是实现多态的方式之一。方法重载发生在同一个类中，它允许一个类中存在多个同名的方法，但它们的实际参数不能相同(包括实参的类型、数量或顺序不同，其中之一不同即可)。
<strong>温馨提示</strong>：<em>方法和函数本质上是没什么区别的，在面向对象中，它们俩经常被交替称呼，所以方法重载和函数重载其实指的是同一件事情。</em></li>
</ol>
<pre><code>public class Overload()
{
    public void calculation(int addition, int addition_2)
    {
        Console.WriteLine(addition + addition_2);
    }

    public void calculation(int multiplication)
    {
        Console.WriteLine(multiplication * multiplication);
    }
}
</code></pre>
<ol>
<li>我们可以在一个类中写多个同名方法，前提是实参内容不能相同。</li>
</ol>
<pre><code>Overload Math = new Overload();
Math.calculation(1, 2);
Math.calculation(2);
</code></pre>
<ol>
<li>C#编译器在编译时会根据传递给函数的参数类型和数量来确定调用哪个重载的方法。如果存在多个重载的函数，并且编译器无法确定调用哪一个，编译器将会报错。</li>
<li>在调用方法时，我们只需要区分开来即可，这就是重载函数的使用，也是实现多态的方式之一。</li>
</ol>
<h2>抽象类与抽象方法</h2>
<blockquote>
<ol>
<li>抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。</li>
<li>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</li>
</ol>
</blockquote>
<ol>
<li><strong>抽象类(Abstract)是一种不能被实例化的类</strong>，它通常用作其他类的<strong>基类</strong>。</li>
<li>抽象类允许你定义一些通用的行为和属性，这些可以被派生类继承和扩展。</li>
<li>抽象类也可以定义抽象方法。 方法是将关键字 <strong>abstract</strong> 添加到方法的返回类型的前面。</li>
</ol>
<p><img src="https://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_duotai_2.png" alt="在这里插入图片描述" /></p>
<ol>
<li>实例操作一下：我们定义一个抽象类Drink，并在类里面定义一个抽象方法Coffee，这个抽象方法不允许包含任何内容，其次我们在写一个普通的方法。</li>
</ol>
<pre><code>public abstract class Drink()    // 抽象类
{
    public abstract void Coffee();   // 抽象方法

    public void MilkTea()
    {
        Console.WriteLine("我是一杯奶茶");
    }
}
</code></pre>
<ol>
<li>再另外定义一个派生类，重写一个Coffee方法。</li>
</ol>
<pre><code>public class Juice() : Drink
{
    public override void Coffee()
    {
        Console.WriteLine("我是一杯咖啡");
    }
}
</code></pre>
<ol>
<li>在运行时我们会发现，我们无法直接实例化抽象类，也无法直接调用抽象方法，仅能够实例化派生类和调用重写方法。</li>
</ol>
<pre><code> Drink Eat = new Juice();
//Drink Eat = new Drink();  不允许实例化抽象类和调用抽象方法
Eat.Coffee();
Eat.MilkTea();
</code></pre>
<p>8.抽象类和抽象方法的主要用途是实现代码的复用和多态性，同时为派生类提供一个必须遵循的契约。</p>
<h2>整体代码参考</h2>
<pre><code>using System;
namespace Almango
{
    public class Fruit
    {
        public virtual void Apple()
        {
            Console.Write("我是一个苹果");
        }

    }
    public class RedFuJiApple():Fruit
    {
        public override void Apple()
        {
            Console.Write("我是一个红富士苹果");
        }
    }

public class Overload()
{
    public void calculation(int addition, int addition_2)
    {
        Console.WriteLine(addition + addition_2);
    }

    public void calculation(int multiplication)
    {
        Console.WriteLine(multiplication * multiplication);
    }
}

public abstract class Drink()    // 抽象类
{
    public abstract void Coffee();   // 抽象方法

    public void MilkTea()
    {
        Console.WriteLine("我是一杯奶茶");
    }
}

public class Juice() : Drink
{
    public override void Coffee()
    {
        Console.WriteLine("我是一杯咖啡");
    }
}


    class Run()
    {
        static void Main(string[] args)   // Main方法
        {
         
        }
    }

}
</code></pre>
<ol>
<li>到这里，面向对象编程的基本原理我们心里已经一知半解了，我们也离入门更进一步了。继续努力！！！</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_封装【十八】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%B0%81%E8%A3%85%E5%8D%81%E5%85%AB/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%B0%81%E8%A3%85%E5%8D%81%E5%85%AB/</id>
    <published>2024-06-16T15:55:00.000Z</published>
    <updated>2024-06-16T15:55:00.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>什么是封装？</h2>
<ol>
<li>封装是面向对象思维的三大特性之一。</li>
<li>封装是将数据和对数据进行操作的函数绑定到一起的机制。它隐藏了对象的内部状态和实现细节，只对外提供必要的接口，从而确保对象内部状态的完整性和安全性。封装的主要目的是增强安全性和简化编程，用户只需要知道对象提供哪些方法，而不需要了解内部细节。</li>
<li>就好比是一部手机，我们知道手机的具体硬件，他给我们提供了很多功能，但同时呢也隐藏了一部分不让我们用户知晓的信息，以确保手机的安全和完整。</li>
</ol>
<h2>访问修饰符</h2>
<ol>
<li>访问修饰符是关键字，用于指定成员或类型已声明的可访问性。</li>
<li>我们在进行封装时，可以给予封装体不同级别的访问权限。</li>
</ol>
<p><img src="https://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_package.png" alt="在这里插入图片描述" />
4. 可使用访问修饰符指定以下 7 个可访问性级别：</p>
<ul>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/public"><code>public</code></a>：访问不受限制。</li>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/protected"><code>protected</code></a>：访问限于包含类或派生自包含类的类型。</li>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/internal"><code>internal</code></a>：访问限于当前程序集。</li>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/protected-internal"><code>protected internal</code></a>：访问限于当前程序集或派生自包含类的类型。</li>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/private"><code>private</code></a>：访问限于包含类。</li>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/private-protected"><code>private protected</code></a>：访问限于包含类或当前程序集中派生自包含类的类型。</li>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/file"><code>file</code></a>：已声明的类型仅在当前源文件中可见。 文件范围的类型通常用于源生成器。</li>
</ul>
<ol>
<li>例如：当我们创建一个类，并在其中定义一个Simple( )私有方法，那么在另一个类的Main( )方法中将无法调用该类中的私有方法，若我们在Main( )所处的类中定义一个Ease( )私有方法，我们会发现，我们可以直接调用该方法。这是因为<em>Private修饰符访问限于包含类</em>，也就是说只能访问本类中的私有方法。</li>
</ol>
<pre><code>
using System;
namespace Project
{
    public class Boom
    {
        private static void Simple()    // 定义私有方法
        {
            Console.Write("Hello World");
        }
    }
    public class Almango
    {
        private static void Ease()    // 定义私有方法
        {
            Console.Write("你好世界");
        }
        static void Main(string[] args)
        {
            Boom.Simple();    
            // 无法调用“Boom.Simple()”不可访问，因为它具有一定的保护级别 CS0122
            Almango.Ease()
            //  可调用
            
        }
    }
}
</code></pre>
<ol>
<li>本次以Private作为例子，更多修饰符的具体用法，可参考<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/access-modifiers">官方文档</a></li>
</ol>
<h2>实例演示</h2>
<pre><code>using System;
namespace Almango
{
    public class Fight()
    {
        public int attack;   // 声明攻击力
        public int blood;    // 声明血量

        public void FunctionFight( int attack, int blood)   // 定义构造函数
        {
            this.attack = attack;   
            this.blood = blood;
        }
        public void Fightting()
        {

            Fight A = new Fight();   // 实例化 A玩家
            Fight B = new Fight();   // 实例化 B玩家
            A.FunctionFight(20, 100);
            B.FunctionFight(40, 100);

            A.blood -= B.attack;    // 模拟A玩家被B玩家攻击扣血场景

            Console.WriteLine("A玩家受到B玩家的攻击：" + "-" + B.attack);
            Console.Write("A玩家剩余血量：" + A.blood + "\n");
            Console.Write("B玩家剩余血量：" + B.blood + "\n");
        }
        public static void Main(string[] args)
        {
            Fight Play = new Fight();

            Play.Fightting();   

        }
    }
}
</code></pre>
<pre><code>&gt;&gt;&gt; A玩家受到B玩家的攻击：-40
&gt;&gt;&gt; A玩家剩余血量：60
&gt;&gt;&gt; B玩家剩余血量：100
</code></pre>
<ol>
<li>示例代码通过封装游戏在战斗模式中的不同过程：从攻击，到攻击计算，到输出受击后的血量，它使得我们大大减少了代码量和提高了代码的运行效率，不仅如此，这样看上去更简约和优雅。</li>
<li>对于每一位面向对象语言的初学者来说，多学多练，掌握好面向对象的三大特征，这对于往后开发效率的提高和可扩展性至关重要。</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_继承【十七】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%BB%A7%E6%89%BF%E5%8D%81%E4%B8%83/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%BB%A7%E6%89%BF%E5%8D%81%E4%B8%83/</id>
    <published>2024-06-11T13:30:40.000Z</published>
    <updated>2024-06-11T13:30:40.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>什么是继承？</h2>
<ol>
<li>
<p>面向对象编程（OOP）中的继承是一种机制，它允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。继承是<strong>OOP的三大基本特性之一</strong>，另外两个是封装和多态。</p>
</li>
<li>
<p>继承是面向对象的编程的一种基本特性。 借助继承，能够定义可重用（继承）、扩展或修改父类行为的子类。 成员被继承的类称为基类。 继承基类成员的类称为派生类。</p>
</li>
</ol>
<blockquote>
<p>C#继承是指对C#语言中现有类（基类、父类）上建立新类（派生类、子类）的处理过程。</p>
</blockquote>
<ol>
<li>
<p>在现有类（基类、父类）上建立新类（派生类、子类）的处理过程称为继承。派生类能自动获得基类的除了构造函数和析构函数以外的所有成员，可以在派生类中添加新的属性和方法扩展其功能。</p>
</li>
<li>
<p>继承是软件复用的一种形式。使用继承可以复用现有类的数据和行为，为其赋予新功能而创建出新类。</p>
</li>
</ol>
<blockquote>
<p>C# 和 .NET 只支持单一继承。 也就是说，类只能继承自一个类。 不过，继承是可传递的。这样一来，就可以为一组类型定义继承层次结构。
换言之，类型 D 可继承自类型 C，其中类型 C 继承自类型 B，类型 B 又继承自基类类型 A。 由于继承是可传递的，因此类型 D
继承了类型 A 的成员。</p>
<p>并非所有基类成员都可供派生类继承。 以下成员无法继承：</p>
<ul>
<li>
<p>静态构造函数：用于初始化类的静态数据。</p>
</li>
<li>
<p>实例构造函数：在创建类的新实例时调用。 每个类都必须定义自己的构造函数。</p>
</li>
<li>
<p>终结器：由运行时的垃圾回收器调用，用于销毁类实例。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>虽然基类的其他所有成员都可供派生类继承，但这些成员是否可见取决于它们的可访问性。 成员的可访问性决定了其是否在派生类中可见，如下所述：</p>
<p>只有在基类中嵌套的派生类中，私有成员才可见。 否则，此类成员在派生类中不可见。 在以下示例中，A.B 是派生自 A 的嵌套类，而 C
则派生自 A。 私有 A._value 字段在 A.B 中可见。不过，如果从 C.GetValue
方法中删除注释并尝试编译示例，则会生成编译器错误 CS0122：“"A._value" 不可访问，因为它具有一定的保护级别。”<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/tutorials/inheritance">[微软官方文档]</a></p>
</blockquote>
<h3>特征与作用</h3>
<ul>
<li>
<p><strong>代码复用</strong>：继承可以减少代码重复，提高开发效率。子类可以继承父类的代码，而无需重新编写相同的功能。</p>
</li>
<li>
<p><strong>层次结构</strong>：继承允许创建类之间的层次结构。一个父类可以有多个子类，这些子类可以共享父类的特性。</p>
</li>
<li>
<p><strong>扩展性</strong>：子类可以扩展或修改父类的行为。它们可以添加新的属性和方法，或者重写（Override）父类的方法以改变其行为。</p>
</li>
<li>
<p><strong>多态性</strong>：继承支持多态性，即同一个接口可以有多个实现。这意味着一个父类类型的引用可以指向子类的对象，并且可以调用子类特有的方法。</p>
</li>
</ul>
<h2>基类和派生类</h2>
<blockquote>
<p>一个类可以继承自另一个类，其中被继承的类被称作<strong>基类(父类)</strong>，继承类被称作<strong>派生类(子类)</strong>。</p>
</blockquote>
<ol>
<li>
<p>C# 不支持类的多重继承，但支持接口的多重继承，一个类可以实现多个接口。</p>
</li>
<li>
<p>从概念上讲，派生类是基类的专门化。 例如，如果有一个基类 Animal，则可以有一个名为 Mammal 的派生类，以及另一个名为 Reptile 的派生类。 Mammal 是 Animal，Reptile 也是 Animal，但每个派生类表示基类的不同专门化。</p>
</li>
</ol>
<p><strong>概括来说：一个类可以继承多个接口，但只能继承自一个类。</strong></p>
<pre><code>&lt;访问修饰符&gt; class &lt;基类&gt;
{
 ...
}
class &lt;派生类&gt; : &lt;基类&gt;
{
 ...
}
</code></pre>
<h2>代码实例</h2>
<ol>
<li>我们尝试写一个动物类的代码来实现一下继承的过程。</li>
<li>我们定义一个动物类(Animal)，再定义一个个体类(Individual)来继承动物类的属性，创建一个猫(Cat)方法，在Cat中可以直接使用被被继承的Animal属性。(在使用使用被继承的属性事，我们需要先实例化Cat方法)
3.运行代码，可以看到，在没有调用的Animal的前提下，继承可以让我们直接使用Animal内的属性，我们可以理解为Animal中的属性，被复制到了派生类中了。</li>
</ol>
<pre><code>using System;
namespace Almango
{
    public class Animal   // 动物类
    {
        public string category;    // 定义种类
        public int Aggressiveness;   // 定义攻击性
        public int life;       // 定义寿命
    }
    public class Individual() : Animal    // 继承动物类
    { 
        public void Cat()    // 定义猫属性
        {
            Individual Cat = new Individual();   // 实例化猫

            ///
            ///将继承的属性调用
            ///
            string a = Cat.category = "猫科动物";
            int b =  Cat.Aggressiveness = 10;
            int c =  Cat.life = 10;
            Console.WriteLine(a);
            Console.WriteLine(b);
            Console.WriteLine(c);
        }
        static void Main(string[] args)
        {
            Individual Cats = new Individual();
            Cats.Cat();
        }
    }
}
</code></pre>
<h3>运行结果</h3>
<pre><code>&gt;猫科动物
&gt;10
&gt;10
</code></pre>
<h2>继承的优点</h2>
<p>C#中的继承提供了多种好处，这些好处有助于提高代码的可维护性、可扩展性和复用性。以下是C#继承的一些主要优点：</p>
<ol>
<li>
<p>代码复用：继承允许子类继承父类的属性和方法，这意味着开发者可以避免重复编写相同的代码。这不仅减少了开发时间，还减少了出错的可能性。</p>
</li>
<li>
<p>减少代码冗余：通过继承，公共的功能可以放在父类中，而子类只需要实现或重写特定的功能。这有助于减少代码的冗余，使代码库更加简洁。</p>
</li>
<li>
<p>层次结构的建立：继承支持创建清晰的类层次结构，这有助于组织和管理大型软件项目。层次结构使得代码更加模块化，易于理解和维护。</p>
</li>
<li>
<p>扩展现有功能：子类可以扩展父类的功能，添加新的属性和方法，或者通过重写现有方法来改变行为。这为现有代码提供了灵活性，使其能够适应新的需求。</p>
</li>
<li>
<p>多态性的支持：继承是多态性的基础。多态性允许将子类的对象视为父类的对象，使得同一个接口可以有多种实现。这使得代码更加灵活，能够以统一的方式处理不同类型的对象。</p>
</li>
<li>
<p>设计模式的应用：继承是许多设计模式的关键组成部分，如工厂模式、建造者模式和策略模式等。这些模式可以解决特定的设计问题，提高代码的可重用性和灵活性。</p>
</li>
<li>
<p>简化单元测试：由于子类继承了父类的行为，因此在进行单元测试时，可以专注于测试子类特有的行为，而不必重新测试父类已经验证过的行为。</p>
</li>
<li>
<p>提高代码的可读性：当代码遵循良好的继承结构时，其他开发者可以更容易地理解代码的工作原理，因为类之间的关系清晰明确。</p>
</li>
<li>
<p>有助于实现封装：继承可以促进封装的实现，因为子类可以继承父类的私有成员，同时提供公共的接口来访问这些成员。</p>
</li>
</ol>
<p>促进面向接口编程：虽然继承本身并不是接口，但它鼓励开发者考虑类之间的共同点，从而促进面向接口编程，这是一种更加灵活和可维护的编程风格。</p>
<p>尽管继承提供了许多好处，但开发者也应该意识到继承可能带来的问题，如过度继承、脆弱的基类问题和菱形继承问题等。合理使用继承，并结合其他OOP原则和设计模式，可以最大化继承的好处，同时避免潜在的问题。</p>
<p><strong>声明 | 文章由AI(KIMI)创作</strong></p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Linux操作系统：探索开源世界的大门(AI创作)</title>
    <link href="https://mizuki.mysqil.com/posts/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A2%E7%B4%A2%E5%BC%80%E6%BA%90%E4%B8%96%E7%95%8C%E7%9A%84%E5%A4%A7%E9%97%A8/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A2%E7%B4%A2%E5%BC%80%E6%BA%90%E4%B8%96%E7%95%8C%E7%9A%84%E5%A4%A7%E9%97%A8/</id>
    <published>2024-06-11T10:59:49.000Z</published>
    <updated>2024-06-11T10:59:49.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h1>Linux操作系统：探索开源世界的大门</h1>
<h2>引言</h2>
<p>Linux，一个由Linus Torvalds于1991年创建的开源操作系统内核，已经成为全球最流行的操作系统之一。它以其稳定性、安全性、灵活性和开源特性而闻名。本文将深入探讨Linux操作系统的基本概念、优势和使用场景，并提供一些入门指南，帮助新手用户快速掌握Linux。</p>
<h2>Linux的起源</h2>
<p>Linux的诞生是计算机历史上的一个里程碑。Linus Torvalds在赫尔辛基大学学习时，出于对操作系统的兴趣，开始编写一个自由的操作系统内核。他最初将其命名为“Freax”，但很快更名为“Linux”。Linux内核的发布，标志着一个全新的开源运动的开始。</p>
<h2>Linux的特点</h2>
<h3>开源</h3>
<p>Linux最大的特点之一是其开源性。源代码对所有人开放，这意味着任何人都可以查看、修改和分发代码。这种开放性促进了社区的快速成长，吸引了全球开发者的贡献。</p>
<h3>多用户多任务</h3>
<p>Linux支持多用户同时使用系统，每个用户都有自己的权限和文件系统。同时，Linux也能够同时运行多个任务，这使得它非常适合服务器和高性能计算环境。</p>
<h3>稳定性和安全性</h3>
<p>Linux以其稳定性和安全性而著称。它很少需要重启，且对恶意软件的抵抗力强。许多银行和金融机构选择Linux作为他们的服务器操作系统，正是因为这些特性。</p>
<h3>跨平台</h3>
<p>Linux可以在多种硬件平台上运行，从个人电脑到大型服务器，甚至嵌入式系统和超级计算机。</p>
<h2>Linux的发行版</h2>
<p>Linux有数百种发行版，每种发行版都有其特定的目标用户和用途。以下是一些最受欢迎的Linux发行版：</p>
<ul>
<li><strong>Ubuntu</strong>：用户友好，适合初学者和桌面用户。</li>
<li><strong>Debian</strong>：以其稳定性和安全性而闻名，是许多其他发行版的基础。</li>
<li><strong>Fedora</strong>：注重创新，经常包含最新的开源技术。</li>
<li><strong>CentOS</strong>：基于Red Hat Enterprise Linux，适合企业级应用。</li>
<li><strong>Arch Linux</strong>：高度可定制，适合有经验的Linux用户。</li>
</ul>
<h2>Linux的命令行界面</h2>
<p>Linux的命令行界面（CLI）是其核心特性之一。CLI提供了对系统的强大控制，允许用户执行各种任务，从文件管理到系统配置。一些基本的命令包括：</p>
<ul>
<li><code>ls</code>：列出目录内容。</li>
<li><code>cd</code>：更改目录。</li>
<li><code>cp</code>：复制文件或目录。</li>
<li><code>mv</code>：移动或重命名文件或目录。</li>
<li><code>rm</code>：删除文件或目录。</li>
<li><code>chmod</code>：更改文件或目录的权限。</li>
</ul>
<h2>Linux的图形用户界面</h2>
<p>尽管命令行是Linux的强大工具，但许多发行版也提供了图形用户界面（GUI），使得操作系统更加易于使用。常见的GUI包括：</p>
<ul>
<li><strong>GNOME</strong>：Ubuntu的默认桌面环境，用户友好。</li>
<li><strong>KDE Plasma</strong>：功能丰富，高度可定制。</li>
<li><strong>XFCE</strong>：轻量级桌面环境，适合资源有限的系统。</li>
</ul>
<h2>Linux的学习资源</h2>
<p>对于新手来说，学习Linux可能会感到有些困难。以下是一些推荐的资源：</p>
<ul>
<li><strong>官方文档</strong>：大多数Linux发行版都有详细的文档和手册。</li>
<li><strong>在线教程</strong>：网站如Linux Academy和Tutorialspoint提供了大量的教程和指南。</li>
<li><strong>社区论坛</strong>：如Stack Exchange的Unix &amp; Linux板块，是获取帮助的好地方。</li>
<li><strong>书籍</strong>：《鸟哥的Linux私房菜》是一本广受好评的Linux入门书籍。</li>
</ul>
<h2>结论</h2>
<p>Linux是一个强大、灵活且开源的操作系统，适用于从个人用户到企业的各种场景。它的稳定性、安全性和开源特性使其成为许多领域的优选。虽然Linux的学习曲线可能有些陡峭，但通过利用丰富的学习资源和社区支持，新手用户可以快速掌握Linux，并享受到它带来的无限可能。</p>
<p><strong>声明 | 文章由AI(KIMI)创作</strong></p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="Linux"></category>
  </entry>
  <entry>
    <title>Adobe Creative Cloud全家桶破解版 (更新中ing...)【白嫖篇】</title>
    <link href="https://mizuki.mysqil.com/posts/adobe-creative-cloud%E5%85%A8%E5%AE%B6%E6%A1%B6%E7%A0%B4%E8%A7%A3%E7%89%88-%E6%9B%B4%E6%96%B0%E4%B8%ADing%E7%99%BD%E5%AB%96%E7%AF%87/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/adobe-creative-cloud%E5%85%A8%E5%AE%B6%E6%A1%B6%E7%A0%B4%E8%A7%A3%E7%89%88-%E6%9B%B4%E6%96%B0%E4%B8%ADing%E7%99%BD%E5%AB%96%E7%AF%87/</id>
    <published>2024-05-13T00:22:37.000Z</published>
    <updated>2024-05-13T00:22:37.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>持续更新中ing……</h2>
<blockquote>
<ol>
<li><strong>Adobe</strong>系统公司（英语：Adobe Systems Incorporated，发音：宽式IPA：/əˈdoʊbiː/，其官方大中华部门内也常以中文“奥多比”自称。股票代码：NASDAQ：ADBE、LSE：ABS），是美国一家跨国电脑软件公司，总部位于加州的圣何塞。</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li><strong>Adobe Creative Cloud</strong> 创意工具，基于创作者需求打造；持续创新，轻松应对平面设计、音视频、3D 等多领域的创作需要。携 15+热门应用，随需而动，千余种新功能，抓住每一个灵感瞬间。</li>
</ol>
</blockquote>
<p><img src="https://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_adobe_AdobeAll.png" alt="在这里插入图片描述" /></p>
<h2>2024最新版</h2>
<p>最新版更新如下</p>
<table>
<thead>
<tr>
<th>软件名称</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adobe Photoshop</td>
<td>2024 v25.0.0.37</td>
</tr>
<tr>
<td>Adobe Audition</td>
<td>2024 v24.0.0.46</td>
</tr>
<tr>
<td>Adobe Animate</td>
<td>2024 v24.0.0.305</td>
</tr>
<tr>
<td>Adobe Premiere</td>
<td>2024 v24.0.0.58</td>
</tr>
<tr>
<td>Adobe Media Encoder</td>
<td>2024 v24.0.0.54</td>
</tr>
<tr>
<td>Adobe Photoshop LightroomV Classic</td>
<td>2024 v13.0.0.15</td>
</tr>
<tr>
<td>Adobe Illustrator</td>
<td>2024 v28.0.0.88</td>
</tr>
<tr>
<td>Adobe Bridge</td>
<td>2024 v14.0.0.12</td>
</tr>
<tr>
<td>Adobe After Effects</td>
<td>2024 v24.0.0.55</td>
</tr>
</tbody>
</table>
<p>下载链接：<a href="https://www.123pan.com/s/EMm9-2soWh.html">https://www.123pan.com/s/EMm9-2soWh.html</a></p>
<h2>Adobe Photoshop</h2>
<ol>
<li>软件下载</li>
</ol>
<table>
<thead>
<tr>
<th>软件名称</th>
<th>版本</th>
<th>下载地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adobe Photoshop</td>
<td>CC 2024 v25.0.0.37</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Photoshop</td>
<td>CC 2023 v25.2.x.x</td>
<td><a href="https://www.123pan.com/6447680/6447685">https://www.123pan.com/6447680/6447685</a></td>
</tr>
<tr>
<td>Adobe Photoshop</td>
<td>CC 2022 v24.0.0.305</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Photoshop</td>
<td>CC 2021 v24.0.0.58</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Photoshop</td>
<td>CC 2020 v21.2.3</td>
<td><a href="https://www.123pan.com/6447680/6447681">https://www.123pan.com/6447680/6447681</a></td>
</tr>
<tr>
<td>Adobe Photoshop</td>
<td>CC 2019 v13.0.0.15</td>
<td>暂无资源</td>
</tr>
</tbody>
</table>
<p><strong>解压密码</strong>：<strong>photoshop2024-2019</strong>（对应那个使用哪项密码）</p>
<ol>
<li>软件配置</li>
</ol>
<h2>Adobe Premiere Pr</h2>
<ol>
<li>软件下载</li>
</ol>
<table>
<thead>
<tr>
<th>软件名称</th>
<th>版本</th>
<th>下载地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adobe Premiere Pr</td>
<td>CC 2024 v25.0.0.37</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Premiere Pr</td>
<td>CC 2023 v25.2.x.x</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Premiere Pr</td>
<td>CC 2022 v24.0.0.305</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Premiere Pr</td>
<td>CC 2021 v24.0.0.58</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Premiere Pr</td>
<td>CC 2020 v21.2.3</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Premiere Pr</td>
<td>CC 2019 v13.0.0.15</td>
<td>暂无资源</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>解压密码</strong>：<strong>@ALMANGO</strong></li>
</ol>
<h2>Adobe DreamWeaver</h2>
<ol>
<li>软件下载</li>
</ol>
<table>
<thead>
<tr>
<th>软件名称</th>
<th>版本</th>
<th>下载地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adobe DreamWeaver</td>
<td>CC 2024 v25.0.0.37</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe DreamWeaver</td>
<td>CC 2023 v25.2.x.x</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe DreamWeaver</td>
<td>CC 2022 v24.0.0.305</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe DreamWeaver</td>
<td>CC 2021 v24.0.0.58</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe DreamWeaver</td>
<td>CC 2020 v21.2.3</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe DreamWeaver</td>
<td>CC 2019 v13.0.0.15</td>
<td>暂无资源</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>解压密码</strong>：<strong>@ALMANGO</strong></li>
</ol>
<h2>Adobe After Effects</h2>
<ol>
<li>软件下载</li>
</ol>
<table>
<thead>
<tr>
<th>软件名称</th>
<th>版本</th>
<th>下载地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adobe After Effects</td>
<td>CC 2024 v25.0.0.37</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe After Effectsr</td>
<td>CC 2023 v25.2.x.x</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe After Effects</td>
<td>CC 2022 v24.0.0.305</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe After Effects</td>
<td>CC 2021 v24.0.0.58</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe After Effects</td>
<td>CC 2020 v21.2.3</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe After Effects</td>
<td>CC 2019 v13.0.0.15</td>
<td>暂无资源</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>解压密码</strong>：<strong>@ALMANGO</strong></li>
</ol>
<h2>Adobe Illustrator</h2>
<ol>
<li>软件下载</li>
</ol>
<table>
<thead>
<tr>
<th>软件名称</th>
<th>版本</th>
<th>下载地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adobe Illustrator</td>
<td>CC 2024 v25.0.0.37</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Illustrator</td>
<td>CC 2023 v25.2.x.x</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Illustrator</td>
<td>CC 2022 v24.0.0.305</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Illustrator</td>
<td>CC 2021 v24.0.0.58</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Illustrator</td>
<td>CC 2020 v21.2.3</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Illustrator</td>
<td>CC 2019 v13.0.0.15</td>
<td>暂无资源</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>解压密码</strong>：<strong>@ALMANGO</strong></li>
</ol>
<h2>Adobe Audition</h2>
<table>
<thead>
<tr>
<th>软件名称</th>
<th>版本</th>
<th>下载地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adobe Audition</td>
<td>CC 2024 v25.0.0.37</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Audition</td>
<td>CC 2023 v25.2.x.x</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Audition</td>
<td>CC 2022 v24.0.0.305</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Audition</td>
<td>CC 2021 v24.0.0.58</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Audition</td>
<td>CC 2020 v21.2.3</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Audition</td>
<td>CC 2019 v13.0.0.15</td>
<td>暂无资源</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>解压密码</strong>：<strong>@ALMANGO</strong></li>
</ol>
<h2>Adobe Bridge</h2>
<ol>
<li>软件下载</li>
</ol>
<table>
<thead>
<tr>
<th>软件名称</th>
<th>版本</th>
<th>下载地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adobe Bridge</td>
<td>CC 2024 v25.0.0.37</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Bridge</td>
<td>CC 2023 v25.2.x.x</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Bridge</td>
<td>CC 2022 v24.0.0.305</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe  Bridge</td>
<td>CC 2021 v24.0.0.58</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Bridge</td>
<td>CC 2020 v21.2.3</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Bridge</td>
<td>CC 2019 v13.0.0.15</td>
<td>暂无资源</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>解压密码</strong>：<strong>@ALMANGO</strong></li>
</ol>
<h2>Adobe Animate</h2>
<ol>
<li>软件下载</li>
</ol>
<table>
<thead>
<tr>
<th>软件名称</th>
<th>版本</th>
<th>下载地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adobe Animate</td>
<td>CC 2024 v25.0.0.37</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Animate</td>
<td>CC 2023 v25.2.x.x</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Animate</td>
<td>CC 2022 v24.0.0.305</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe  Animate</td>
<td>CC 2021 v24.0.0.58</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Animate</td>
<td>CC 2020 v21.2.3</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Animate</td>
<td>CC 2019 v13.0.0.15</td>
<td>暂无资源</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>解压密码</strong>：<strong>@ALMANGO</strong></li>
</ol>
<h2>Adobe Indesign</h2>
<ol>
<li>软件下载</li>
</ol>
<table>
<thead>
<tr>
<th>软件名称</th>
<th>版本</th>
<th>下载地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adobe Indesign</td>
<td>CC 2024 v25.0.0.37</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Indesign</td>
<td>CC 2023 v25.2.x.x</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Indesign</td>
<td>CC 2022 v24.0.0.305</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe  Indesign</td>
<td>CC 2021 v24.0.0.58</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Indesign</td>
<td>CC 2020 v21.2.3</td>
<td>暂无资源</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>解压密码</strong>：<strong>@ALMANGO</strong></li>
</ol>
<h2>Adobe Media Encoder</h2>
<ol>
<li>软件下载</li>
</ol>
<table>
<thead>
<tr>
<th>软件名称</th>
<th>版本</th>
<th>下载地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adobe Media Encoder</td>
<td>CC 2024 v25.0.0.37</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Media Encoder</td>
<td>CC 2023 v25.2.x.x</td>
<td>暂无资源</td>
</tr>
<tr>
<td>Adobe Media Encoder</td>
<td>CC 2022 v24.0.0.305</td>
<td>暂无资源</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>解压密码</strong>：<strong>@ALMANGO</strong></li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="白嫖"></category>
  </entry>
  <entry>
    <title>Microsoft Office 365免费激活教程【白嫖篇】</title>
    <link href="https://mizuki.mysqil.com/posts/microsoft-office-365%E5%85%8D%E8%B4%B9%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B%E7%99%BD%E5%AB%96%E7%AF%87/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/microsoft-office-365%E5%85%8D%E8%B4%B9%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B%E7%99%BD%E5%AB%96%E7%AF%87/</id>
    <published>2024-05-02T10:30:10.000Z</published>
    <updated>2024-05-02T10:30:10.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>前言</h2>
<ol>
<li>
<p>Microsoft Office是一套由微软公司开发的办公软件，它为 Microsoft Windows 和 Mac OS X而开发。与办公室应用程序一样，它包括联合的服务器和基于互联网的服务。最近版本的 Office 被称为 “Office System” 而不叫 “Office Suite”，反映出它们也包括服务器的事实。</p>
</li>
<li>
<p>随着Office的不断更新换代，已经更新到了如今的Office 365版本了，那么365版本和往期版本如2016，2018，2019又有什么区别呢？</p>
</li>
</ol>
<ul>
<li>购买权限：Office 365的价格是按年计算的，而Office 2019之类的则是一旦购买激活，永久有效。</li>
<li>升级服务：Office 365用户可以享受免费的功能更新和升级，Office 2016用户需要重新购买更高版本以获取更新。</li>
<li>使用方式：Office 365是基于网络的订阅服务，可以在多台设备上使用，Office 2016是本地应用，仅限于在一台设备上使用。</li>
</ul>
<p><strong>3. 说实话，我还是更喜欢国产的WPS Office，微软的破解起来太耗阳寿了，但这次总结了经验，干脆写成文章。
4. 虽然个人认为不如WPS，但嫖到就是赚到。
5. 话不多说，我们直接开始免费激活它。</strong></p>
<h2>开始激活</h2>
<h3>安装Office Tool Plus</h3>
<ol>
<li>首先我们需要先安装"Office Tool Plus"</li>
<li>下载地址：<a href="https://otp.landian.vip/zh-cn/download.html#google_vignette">https://otp.landian.vip/zh-cn/download.html#google_vignette</a></li>
<li>下载完成后将其解压，并启动名为：“Office Tool Plus.exe" 的应用程序</li>
</ol>
<h3>配置并安装Office</h3>
<ol>
<li>
<p>点击侧边栏的 "工具箱"</p>
</li>
<li>
<p>如果电脑中安装过了任何版本的Microsoft Office，则我们需要先将其移除。
<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_office365_1.png" alt="在这里插入图片描述" /></p>
</li>
<li>
<p>移除完毕后，点击 "部署"。</p>
</li>
<li>
<p>选择好对应的 ”体系结构" (计算机对应的架构体系32位/64位)</p>
</li>
<li>
<p>开启 "下载后再部署"，和 "创建桌面快捷方式"。</p>
</li>
<li>
<p>添加有个自己想要的产品版本 (这里选择的是：Microsoft Office 365 企业应用版)
<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_office365_2.png" alt="在这里插入图片描述" /></p>
</li>
<li>
<p>接着下拉，勾选你所需要的Office套件。</p>
</li>
<li>
<p>再添加语言为简体中文。</p>
</li>
<li>
<p>回到顶部，点击 "开始部署"。Office365就开始下载安装了，请耐心等待。
<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_office365_3.png" alt="在这里插入图片描述" /></p>
</li>
<li>
<p>安装完成后，会在桌面生成相应的套件。
<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_office365_4.png" alt="在这里插入图片描述" /></p>
</li>
<li>
<p>点击侧边栏的 "部署"。</p>
</li>
<li>
<p>展开 "许可证管理"，并点击 "安装许可证"，找对 Office Mondo 2016。(当然这取决于你安装的是什么版本)。
<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_office365_5.png" alt="在这里插入图片描述" /></p>
</li>
<li>
<p>下拉找到  "KMS管理"，设置KMS主机为：<code>kms.03k.org</code></p>
</li>
<li>
<p>最后回到顶部，点击 "激活" 即可</p>
</li>
</ol>
<h2>完成</h2>
<ol>
<li>完成后，可以看到产品被成功激活了。</li>
<li>当然了，由于Office 365不同于往届版本，用户使用时最好登录微软账户。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_office365_6.png" alt="在这里插入图片描述" /></p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_office365_7.png" alt="在这里插入图片描述" /></p>
<ol>
<li>好了，本次的白嫖文章就讲到这里吧！（如果不是博客文章的类型太单纯，我可能会懒得搞了，但仔细想一想，这还是十分有必要的。）</li>
<li>下次教大家如何白嫖Adobe的产品。</li>
<li>还有就是：不如WPS。</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="白嫖"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_方法(Medthod)【十六】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%96%B9%E6%B3%95medthod%E5%8D%81%E5%85%AD/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%96%B9%E6%B3%95medthod%E5%8D%81%E5%85%AD/</id>
    <published>2024-05-01T23:29:50.000Z</published>
    <updated>2024-05-01T23:29:50.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>什么是方法？</h2>
<ol>
<li>在编程中，方法（Method）是一个执行特定操作的代码块。它是一种将逻辑封装起来的方式，使得代码更加模块化、重用性更高，并且易于维护。以下是方法的一些关键特性：</li>
</ol>
<ul>
<li>
<p>封装性：方法将一系列的操作封装在一起，形成一个单一的单元。</p>
</li>
<li>
<p>命名：每个方法都有一个名字，以便于调用和引用。</p>
</li>
<li>
<p>参数：方法可以接受输入参数，这些参数允许方法根据传入的数据执行不同的操作。</p>
</li>
<li>
<p>返回值：方法可以返回一个值，这个值的类型由方法的返回类型定义。有些方法不返回任何值，这些方法的返回类型通常是 void。</p>
</li>
<li>
<p>作用域：方法的作用域由其定义的位置决定。在类中定义的方法只能由该类的实例调用，除非它们被声明为 static（静态的），这样它们就可以被类直接调用，而不需要创建类的实例。</p>
</li>
<li>
<p>重载：可以在同一个类中定义多个同名的方法，只要它们的参数列表不同（参数的数量、类型或顺序不同），这称为方法的重载。</p>
</li>
<li>
<p>可访问性：方法的可访问性由其访问修饰符决定，如 public、private、protected 等。</p>
</li>
<li>
<p>异常处理：方法可以处理异常，即在执行过程中可能发生的错误情况。</p>
</li>
<li>
<p>多态性：在面向对象编程中，方法可以被重写（Override），这是多态性的一种形式，允许子类提供其自己的实现方式。</p>
</li>
<li>
<p>递归：方法可以调用自身，这种技术称为递归，它在解决某些类型的问题（如算法问题）时非常有用。</p>
</li>
</ul>
<ol>
<li>在C#中，方法的声明通常如下所示：</li>
</ol>
<pre><code>
[access-modifier] [return-type] MethodName([parameter-list])
{
    // 方法体
}
</code></pre>
<p>例如：</p>
<pre><code>public int Add(int a, int b)
{
    return a + b; // 返回两个数的和
}
</code></pre>
<p>在这个例子中，Add 是一个公共方法（public），它接受两个整数参数并返回它们的和。这个方法可以被任何可以访问它的对象调用。</p>
<p>方法的使用可以大大简化编程任务，因为它们允许你将复杂的逻辑分解成更小、更易于管理的部分。
在C#编程语言中，方法（Method）是执行特定任务的代码块。方法允许你将逻辑封装起来，以便可以在程序的多个地方重复使用，而不必每次都重写相同的代码。方法可以带参数，这些参数允许你自定义方法的行为，并且可以返回一个值。</p>
<h2>方法的定义</h2>
<ol>
<li>方法由访问修饰符、返回类型、方法名、参数列表（可选）和方法体组成。</li>
</ol>
<pre><code>public int CalculateSum(int a, int b)
{
    return a + b;
}
</code></pre>
<ol>
<li>在上面的例子中，CalculateSum是一个公共方法（public），它返回一个int类型的值，并且接受两个int类型的参数。</li>
</ol>
<h2>方法的访问修饰符</h2>
<ul>
<li><strong>public</strong>：方法可以被任何其他类访问。</li>
<li><strong>private</strong>：方法只能在定义它的类内部访问。</li>
<li><strong>protected</strong>：方法只能在定义它的类及其派生类中访问。</li>
<li><strong>internal</strong>：方法只能在当前程序集（Assembly）中访问。</li>
</ul>
<h2>参数和返回类型</h2>
<ol>
<li>方法可以有零个或多个参数，参数是方法执行时所需的输入。方法还可以指定返回类型，表示方法执行完毕后返回的值的类型。</li>
</ol>
<pre><code>public string Concatenate(string str1, string str2)
{
    return str1 + str2;
}
</code></pre>
<ol>
<li>在这个例子中，Concatenate方法接受两个字符串参数，并返回它们的连接结果。</li>
</ol>
<h2>重载方法</h2>
<ol>
<li>C#支持方法重载，即允许在同一个类中定义多个同名的方法，只要它们的参数列表不同（参数的类型、数量或顺序不同）。</li>
</ol>
<pre><code>public int Add(int a, int b)
{
    return a + b;
}
</code></pre>
<pre><code>public int Add(int a, int b, int c)
{
    return a + b + c;
}
</code></pre>
<h2>静态方法与实例方法</h2>
<ul>
<li><strong>静态方法</strong>：使用static关键字定义，它们属于类而不是类的实例。静态方法不能访问非静态成员。</li>
<li><strong>实例方法</strong>：不需要static关键字，它们属于类的具体实例，并且可以访问类的非静态成员。</li>
</ul>
<pre><code>public class Calculator
{
    public static int Add(int a, int b)
    {
        return a + b;
    }

    public int Multiply(int a, int b)
    {
        return a * b;
    }
}
</code></pre>
<h2>扩展方法</h2>
<ol>
<li>扩展方法是C#的一个特性，允许为现有类型“添加”新的方法而不需要修改其源代码。扩展方法是一个静态方法，它们定义在静态类中，并且第一个参数使用this关键字修饰，表示扩展方法所扩展的类型。</li>
</ol>
<pre><code>public static class StringExtensions
{
    public static int CountWords(this string str)
    {
        return str.Split(new char[] { ' ', '.', '?' }, StringSplitOptions.RemoveEmptyEntries).Length;
    }
}
</code></pre>
<ol>
<li>在上面的例子中，我们为string类型添加了一个名为CountWords的扩展方法。</li>
</ol>
<h2>Lambda表达式和委托</h2>
<ol>
<li>C#中的委托（Delegate）是一种特殊的类型，它可以持有对方法的引用。Lambda表达式提供了一种简写委托的方式。</li>
<li></li>
</ol>
<pre><code>Func&lt;int, int, int&gt; addDelegate = (a, b) =&gt; a + b;
int result = addDelegate(5, 3); // result is 8
</code></pre>
<h2>方法的高级特性</h2>
<ol>
<li>C#还提供了一些方法的高级特性，如：</li>
</ol>
<ul>
<li><strong>泛型方法</strong>：允许方法操作类型安全的泛型数据。</li>
<li><strong>迭代器方法</strong>：使用yield关键字，允许方法返回一系列的值。</li>
<li><strong>异步方法</strong>：使用async和await关键字，允许方法在等待异步操作完成时释放执行线程。</li>
</ul>
<h2>使用场景</h2>
<ol>
<li>方法在C#编程中无处不在，它们用于：</li>
</ol>
<ul>
<li>实现业务逻辑。</li>
<li>执行数据操作，如排序、搜索等。</li>
<li>处理用户界面事件。</li>
<li>与外部资源交互，如文件系统、数据库、网络服务等。</li>
</ul>
<h2>最佳实践</h2>
<p>单一职责原则：每个方法应该只做一件事情。
清晰命名：方法名应该清晰地表达其功能。
参数验证：在方法内部检查参数的有效性。
异常处理：适当地使用异常来处理错误情况。</p>
<h2>结语</h2>
<p>C#的方法是构建应用程序的基本构建块，它们使得代码更加模块化、可重用和易于维护。理解并正确使用方法对于成为一名优秀的C#程序员至关重要。</p>
<p>声明 | 文章由AI辅助创作</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_类(Class)【十五】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%B1%BBclass%E5%8D%81%E4%BA%94/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%B1%BBclass%E5%8D%81%E4%BA%94/</id>
    <published>2024-05-01T19:10:24.000Z</published>
    <updated>2024-05-01T19:10:24.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>什么是类？</h2>
<ol>
<li>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础。类是一种用户定义的引用数据类型，也称类类型。每个类包含数据说明和一组操作数据或传递消息的函数。类的实例称为对象。</li>
</ol>
<h2>类的三大特性</h2>
<ol>
<li><strong>封装 (Encapsulation)</strong>
封装是将数据（属性）和行为（方法）结合在一起的机制，同时限制对对象内部实现的直接访问。在C#中，封装通常是通过使用访问修饰符来实现的，比如private、protected、internal和public。封装的主要目的是隐藏对象的内部状态和复杂性，只暴露出一个清晰和简洁的接口供外部调用。</li>
</ol>
<pre><code>public class MyClass
{
    private int myPrivateField; // 私有字段，外部无法直接访问

    public int MyProperty
    {
        get { return myPrivateField; }
        set { myPrivateField = value; }
    }

    public void MyMethod()
    {
        // 方法实现
    }
}
</code></pre>
<ol>
<li><strong>继承 (Inheritance)</strong>
继承是一种可以让新创建的类（子类或派生类）接收另一个类（父类或基类）的属性和方法的机制。继承支持代码的重用，并允许创建分层的类结构。在C#中，使用:操作符来表示继承关系。</li>
</ol>
<pre><code>public class BaseClass
{
    public void BaseMethod()
    {
        // 方法实现
    }
}

public class DerivedClass : BaseClass
{
    public void DerivedMethod()
    {
        // 方法实现
    }
}
</code></pre>
<ol>
<li><strong>多态 (Polymorphism)</strong>
多态是指允许不同类的对象对同一消息做出响应的能力，即同一个接口，不同的表现。在C#中，多态性主要通过虚方法（virtual methods）、抽象类（abstract classes）和接口（interfaces）来实现。</li>
</ol>
<pre><code>public abstract class Animal
{
    public abstract void MakeSound();
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Woof!");
    }
}

public class Cat : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Meow!");
    }
}
</code></pre>
<h2>类的组成</h2>
<ol>
<li>类由 <strong>类名</strong>，<strong>属性</strong>，<strong>方法</strong> 组成，同时我们也可以将它们称作为“<em><strong>类的成员</strong></em>”</li>
</ol>
<ul>
<li>类名：类名是类的标识符，用于定义和区分不同的类。</li>
<li>属性：类的属性是描述类的状态和特征的重要元素，它们可以通过不同的方式进行定义和访问，具体取决于所使用的编程语言和面向对象的设计原则。</li>
<li>方法：方法是类的成员函数，方法的设定赋予了类更多功能，比如我们要完成某个事，只需要提前将方法写好，就可以在同一种事情上充分利用方法。</li>
</ul>
<pre><code>public class ClassName
{
    // 类的属性（字段）
    private int myField; // 私有字段
    public string MyProperty { get; set; } // 公共属性

    // 类的构造函数
    public ClassName() 
    {
        // 默认构造函数
    }
    
    public ClassName(string name) 
    {
        // 带参数的构造函数
    }

    // 类的方法
    public void MyMethod()
    {
        // 方法的实现
    }

    // 可以包含其他方法、属性、事件等
}
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_三个经典算法题【十四】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E4%B8%89%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98%E5%8D%81%E5%9B%9B/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E4%B8%89%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98%E5%8D%81%E5%9B%9B/</id>
    <published>2024-05-01T10:57:18.000Z</published>
    <updated>2024-05-01T10:57:18.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>冒泡排序</h2>
<pre><code>using System;
namespace Prosose
{
    public class Fibonacci
    {
        static void Main(string[] args)
        {
            int[] array = new int[] {3, 5, 1, 8, 6, 4, 33, 13, 26, 13};
            int temp;

            for(int a = 0; a &lt; array.Length - 1; a ++)
            {
                for(int i = 0; i &lt; array.Length -1; i ++)
                {
                    if (array[i] &gt; array[i + 1])
                    {
                        temp = array[i];
                        array[i] = array[i + 1];
                        array[i + 1] = temp;
                    }
                }
            }
            foreach (int Recursive in array)
            {
                Console.Write(Recursive + ",");
            }
        }
    }
}
</code></pre>
<h2>3n + 1问题</h2>
<pre><code>using System;
namespace Prosose
{
    public class Fibonacci
    {
        static void Main(string[] args)
        {
            int a = 7;
            int again = 0;

            while (true)
            {
                if (a % 2 == 0)
                {
                    a /= 2;
                    if (a &lt; 2)
                    {
                        Console.WriteLine("\n" + "一共运行了" + again + "次");
                        break;
                    }
                }
                else
                {
                    a *= 3;
                    a += 1;
                }
                again ++;
            Console.Write(a + ", ");

            }
        }
    }
}
</code></pre>
<h2>九九乘法表</h2>
<pre><code>using System;
namespace Prosose
{
    public class Fibonacci
    {
        static void Main(string[] args)
        {
            int k = 0;
            for(int a = 0; a &lt; 10; a ++)
            {
                k ++;
                
                for(int b = 1; b &lt; k; b ++)
                {
                    Console.Write(b + "*" + a + "=" + a*b + "  ");
                }
                Console.WriteLine("");
            }
        }
    }
}
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Markdown Extended Features</title>
    <link href="https://mizuki.mysqil.com/posts/markdown-extended/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/markdown-extended/</id>
    <published>2024-05-01T00:00:00.000Z</published>
    <updated>2024-11-29T00:00:00.000Z</updated>
    <summary>Read more about Markdown features in Mizuki</summary>
    <content type="html"><![CDATA[<h2>GitHub Repository Cards</h2>
<p>You can add dynamic cards that link to GitHub repositories, on page load, the repository information is pulled from the GitHub API.</p>
<p>::github{repo="matsuzaka-yuki/Mizuki"}</p>
<p>Create a GitHub repository card with the code <code>::github{repo="matsuzaka-yuki/Mizuki"}</code>.</p>
<pre><code>::github{repo="matsuzaka-yuki/Mizuki"}
</code></pre>
<h2>Admonitions</h2>
<p>Following types of admonitions are supported: <code>note</code> <code>tip</code> <code>important</code> <code>warning</code> <code>caution</code></p>
<p>:::note
Highlights information that users should take into account, even when skimming.
:::</p>
<p>:::tip
Optional information to help a user be more successful.
:::</p>
<p>:::important
Crucial information necessary for users to succeed.
:::</p>
<p>:::warning
Critical content demanding immediate user attention due to potential risks.
:::</p>
<p>:::caution
Negative potential consequences of an action.
:::</p>
<h3>Basic Syntax</h3>
<pre><code>:::note
Highlights information that users should take into account, even when skimming.
:::

:::tip
Optional information to help a user be more successful.
:::
</code></pre>
<h3>Custom Titles</h3>
<p>The title of the admonition can be customized.</p>
<p>:::note[MY CUSTOM TITLE]
This is a note with a custom title.
:::</p>
<pre><code>:::note[MY CUSTOM TITLE]
This is a note with a custom title.
:::
</code></pre>
<h3>GitHub Syntax</h3>
<blockquote>
<p>[!TIP]
<a href="https://github.com/orgs/community/discussions/16925">The GitHub syntax</a> is also supported.</p>
</blockquote>
<pre><code>&gt; [!NOTE]
&gt; The GitHub syntax is also supported.

&gt; [!TIP]
&gt; The GitHub syntax is also supported.
</code></pre>
<h3>Spoiler</h3>
<p>You can add spoilers to your text. The text also supports <strong>Markdown</strong> syntax.</p>
<p>The content :spoiler[is hidden <strong>ayyy</strong>]!</p>
<pre><code>The content :spoiler[is hidden **ayyy**]!</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="Examples"></category>
  </entry>
  <entry>
    <title>适合写代码的5款字体【推荐】</title>
    <link href="https://mizuki.mysqil.com/posts/%E9%80%82%E5%90%88%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%845%E6%AC%BE%E5%AD%97%E4%BD%93%E6%8E%A8%E8%8D%90/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E9%80%82%E5%90%88%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%845%E6%AC%BE%E5%AD%97%E4%BD%93%E6%8E%A8%E8%8D%90/</id>
    <published>2024-04-21T16:43:10.000Z</published>
    <updated>2024-04-21T16:43:10.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>Consolas</h2>
<ol>
<li>Consolas是一套等宽字体的字型，属无衬线字体，由Lucas de Groot设计。</li>
<li>这套字型使用了微软的ClearType 字型平滑技术，并随同Windows Vista、Office 2007及Microsoft Visual Studio中发行，或可在微软的网站下载。在Windows Vista的6套新字型中，Consolas近似于前版Windows中 的2款内建字型：Lucida Console与Courier New，主要为程序代码的显示字型而设计的，特别之处是它的“0”字加入了一斜撇，以方便与字母“O”分辨。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_font_1.png" alt="在这里插入图片描述" /></p>
<p>字体下载：<a href="https://font.chinaz.com/929234710.htm">https://font.chinaz.com/929234710.htm</a></p>
<h2>Jetbrains Mono</h2>
<ol>
<li>JetBrains Mono 是一款专为开发者打造的开源编程字体。</li>
<li>在设计 Mono 字体之初，团队充分考虑了长时间查阅代码可能导致的眼睛疲劳问题，以及受影响的因素，比如字母的大小和形状、空间量、自然等宽平衡、不必要的细节、连字、以及难以区分的符号或字母（l 和 I）和连字等。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_font_2.png" alt="在这里插入图片描述" /></p>
<p>字体下载：<a href="https://www.oschina.net/p/jetbrains-mono?hmsr=aladdin1e1">https://www.oschina.net/p/jetbrains-mono?hmsr=aladdin1e1</a></p>
<h2>Monaco</h2>
<ol>
<li>Monaco 是一个无衬线等宽字体</li>
<li>Monaco 作为 Mac OS X 的自带字体之一，字体设计优美、秀丽大方，书写流畅，整体效果非常漂亮，因为具有美观与容易辨识的优点，常作为电脑指令与代码的显示，适合应用于海报设计、书籍装帧、画册封面、产品包装设计等应用。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_font_3.png" alt="在这里插入图片描述" /></p>
<p>字体下载：<a href="https://font.chinaz.com/929238414.htm">https://font.chinaz.com/929238414.htm</a></p>
<h2>Fira Code</h2>
<ol>
<li>Fira Code是一种免费的等宽字体，</li>
<li>包含常用的编程语言中多种字符组合的连字。这只是一个字体呈现功能，底层代码仍然与ASCII兼容。这有助于更快地阅读和理解代码。对于一些常见的序列，如..或//，连字允许我们纠正间距。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_font_4.png" alt="在这里插入图片描述" /></p>
<p>字体下载：<a href="https://font.chinaz.com/929238414.htm">https://font.chinaz.com/929238414.htm</a></p>
<h2>Cascadia Code</h2>
<ol>
<li>Cascadia Code 是由微软出品的一款开源等宽字体，</li>
<li>Cascadia Code 是 Microsoft 提供的一种新的等宽字体，可为命令行应用程序和文本编辑器提供全新的体验。 Cascadia Code 是与 Windows 终端一起开发的。 建议将此字体与终端应用程序和文本编辑器（如 Visual Studio 和 Visual Studio Code）一起使用。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_font_5.png" alt="在这里插入图片描述" /></p>
<p>字体下载：<a href="https://www.fonts.net.cn/font-37973291246.html">https://www.fonts.net.cn/font-37973291246.html</a></p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="推荐分享"></category>
  </entry>
  <entry>
    <title>关于面向对象与面向过程的基本概念</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2024-04-21T14:43:10.000Z</published>
    <updated>2024-04-21T14:43:10.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>什么是面向对象与面向过程编程</h2>
<p>面向对象编程（OOP）和面向过程编程（POP）是两种主要的编程范式，它们在解决问题的方法和组织代码的方式上有所不同。C#和Java都是支持这两种编程范式的语言，但它们在实现细节上有所区别。下面，我将首先介绍面向对象和面向过程的基本概念，然后通过C#和Java的例子来进一步阐释这些概念。</p>
<h3>面向对象编程（OOP）</h3>
<p>面向对象编程是一种编程范式，它使用“对象”来表示数据和方法，这些对象通过封装、继承和多态性来实现代码的复用和模块化。</p>
<p><strong>封装</strong>：封装是将数据（属性）和行为（方法）结合在一起，并隐藏内部实现细节的过程。在C#中，可以通过使用<code>private</code>、<code>protected</code>等访问修饰符来实现封装。</p>
<p><strong>继承</strong>：继承是一种机制，允许一个类（子类）继承另一个类（父类或超类）的属性和方法。在Java中，继承是通过关键字<code>extends</code>来实现的。</p>
<p><strong>多态性</strong>：多态性允许不同类的对象对同一消息做出响应，但具体的行为会根据对象的实际类型而有所不同。在C#中，多态性通常是通过虚方法和接口来实现的。</p>
<h3>面向过程编程（POP）</h3>
<p>面向过程编程是一种编程范式，它侧重于将程序分解为一系列的过程或函数。每个过程或函数执行一个具体的任务，并通过参数传递数据。</p>
<p>在面向过程编程中，数据和函数是分离的，这使得数据结构和算法的复用变得困难。面向过程编程通常使用过程抽象，而不是对象抽象。</p>
<h3>C#和Java中的面向对象编程</h3>
<p>C#和Java都是支持面向对象编程的语言，它们提供了丰富的特性来支持OOP的概念。</p>
<h4>C#中的面向对象编程</h4>
<p>在C#中，类是通过使用<code>class</code>关键字定义的。下面是一个简单的C#类的例子：</p>
<pre><code>public class Animal {
    private string name;

    public Animal(string name) {
        this.name = name;
    }

    public void Speak() {
        Console.WriteLine("Animal speaks");
    }
}
</code></pre>
<p>在这个例子中，<code>Animal</code>类有私有成员<code>name</code>，它通过构造函数进行初始化。<code>Speak</code>方法是类的行为，它被封装在类中。</p>
<p>继承在C#中通过使用<code>:</code>符号来实现。例如，我们可以创建一个<code>Dog</code>类，它继承自<code>Animal</code>类：</p>
<pre><code>public class Dog : Animal {
    public Dog(string name) : base(name) {
    }

    public override void Speak() {
        Console.WriteLine("Woof!");
    }
}
</code></pre>
<p>在这个例子中，<code>Dog</code>类重写了<code>Animal</code>类的<code>Speak</code>方法，展示了多态性。</p>
<h4>Java中的面向对象编程</h4>
<p>Java也是一种面向对象的语言，它同样支持类、继承和多态性。下面是一个Java类的例子：</p>
<pre><code>public class Animal {
    private String name;

    public Animal(String name) {
        this.name = name;
    }

    public void speak() {
        System.out.println("Animal speaks");
    }
}
</code></pre>
<p>Java中的类定义与C#类似，但是有一些语法上的差异，比如方法名通常使用小写字母。</p>
<p>继承在Java中通过使用<code>extends</code>关键字来实现：</p>
<pre><code>public class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }

    @Override
    public void speak() {
        System.out.println("Woof!");
    }
}
</code></pre>
<p>在这个例子中，<code>Dog</code>类继承自<code>Animal</code>类，并且重写了<code>speak</code>方法。</p>
<h3>C#和Java中的面向过程编程</h3>
<p>尽管C#和Java都是面向对象的语言，但它们也支持面向过程的编程风格。面向过程的编程通常涉及到使用函数和过程来处理数据。</p>
<h4>C#中的面向过程编程</h4>
<p>在C#中，可以使用静态类和方法来实现面向过程的编程。例如：</p>
<pre><code>public static class Utility {
    public static void PrintAnimalSpeak(string animalType) {
        if (animalType == "Dog") {
            Console.WriteLine("Woof!");
        } else {
            Console.WriteLine("Animal speaks");
        }
    }
}
</code></pre>
<p>在这个例子中，<code>Utility</code>类包含一个静态方法<code>PrintAnimalSpeak</code>，它根据传入的参数决定输出什么。</p>
<h4>Java中的面向过程编程</h4>
<p>Java同样支持静态方法，这允许开发者以面向过程的方式编写代码。例如：</p>
<pre><code>public class Utility {
    public static void printAnimalSpeak(String animalType) {
        if (animalType.equals("Dog")) {
            System.out.println("Woof!");
        } else {
            System.out.println("Animal speaks");
        }
    }
}
</code></pre>
<p>在这个例子中，<code>Utility</code>类包含一个静态方法<code>printAnimalSpeak</code>，它执行与C#中类似的过程。</p>
<h3>结论</h3>
<p>面向对象编程和面向过程编程各有优势和适用场景。面向对象编程通过封装、继承和多态性提供了一种强大的代码组织和复用方式，而面向过程编程则在某些简单或特定的情况下更为直接和高效。C#和Java作为两种流行的编程语言，都提供了支持这两种编程范式的工具和特性。</p>
<p>在实际的软件开发中，选择哪种编程范式往往取决于项目的需求、团队的熟悉度以及预期的可维护性。理解这两种范式的核心概念和它们在C#和Java中的实现，可以帮助开发者更有效地解决问题，并编写出更加健壮和可维护的代码。</p>
<p>声明 | 文章由AI辅助创作</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="C#"></category>
  </entry>
  <entry>
    <title>Linux 之父：11 岁学习编程，21 岁开发出 Linux 操作系统，活成了多数程序员羡慕的样子【转载】</title>
    <link href="https://mizuki.mysqil.com/posts/linux-%E4%B9%8B%E7%88%B611-%E5%B2%81%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B21-%E5%B2%81%E5%BC%80%E5%8F%91%E5%87%BA-linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%B4%BB%E6%88%90%E4%BA%86%E5%A4%9A%E6%95%B0%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BE%A1%E6%85%95%E7%9A%84%E6%A0%B7%E5%AD%90/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/linux-%E4%B9%8B%E7%88%B611-%E5%B2%81%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B21-%E5%B2%81%E5%BC%80%E5%8F%91%E5%87%BA-linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%B4%BB%E6%88%90%E4%BA%86%E5%A4%9A%E6%95%B0%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BE%A1%E6%85%95%E7%9A%84%E6%A0%B7%E5%AD%90/</id>
    <published>2024-04-21T13:43:10.000Z</published>
    <updated>2024-04-21T13:43:10.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<p>转载文章
<img src="https://img-blog.csdnimg.cn/direct/1949e4797f104f1b9e11194a963b2f99.png" alt="在这里插入图片描述" /></p>
<p>Linux 操作系统相信对做开发的人员来说，已经再熟悉不过了。它具备免费、可靠、安全、稳定、多平台等优势，早在1991 年公布以来，就得到迅猛的发展。以至于现在我们用到的几乎所有的智能设备都有它的应用。比如手机、电脑、路由器、电视等等。而这一切的一切都离不开一个突出贡献，那就是它的创造者——被称为 Linux 之父的林纳斯·托瓦兹(Linus Torvalds)。今天我们就带大家来看看这个林纳斯，到底是何许人也？(不了解 Linux 发展史的童鞋，可以移步看我的另外一篇文章：《影响LINUX发展的四位天才黑客》)</p>
<p>林纳斯早在 11 岁时，就开始接触了编程。这归功于它的外公，一位统计学的教授。不知道这位老人是纯粹的偷懒，还是培养外孙。他经常口述程序命令，让年幼的林纳斯在计算机上实现。聪明的林纳斯很快就发现这个神奇"盒子"的魔法，并很快产生了浓厚的兴趣。因此，花了大把时间"玩"编程的林纳斯，在进入大学之前就有了丰富的编程经验，这为他之后开发出 Linux 系统，打下了夯实的基础
<img src="https://img-blog.csdnimg.cn/direct/7590778b1acb4cd38e3177bd72e0f1e6.png" alt="在这里插入图片描述" /></p>
<p>知道自己兴趣的人，大学生涯就幸运得多。林纳斯进入大学会便经常泡在学校的实验室，倒腾计算机。当时 AT&amp;T 公司开发的 Unix 是学校的教学系统。林纳斯很快就喜欢上了它，并花了一整个夏天的时间钻研它。之后还学了用来开发 Unix 系统的 C 语言。Unix 虽好，但是它毕竟是个商业公司，而且面相个人用户收费价格昂贵，要数千美元，对于当时只是个大二学生的林纳斯来说，简直等同于敲诈勒索。但所幸，当时林纳斯已经参阅过 Unix 系统的核心代码，并掌握了开发 Unix 系统的 C 语言。对于天赋异禀的林纳斯，实现一个类 Unix 的操作系统，也只是一个时间问题，在没有更多选择的情况下，林纳斯便开始着手开发一个属于自己的 "Unix" 系统</p>
<p>当时，还有另外一款红极一时的操作系统——Minix。这个操作系统是生活在阿姆斯特丹自由大学的一位计算机教授，安德鲁·塔能鲍姆，为了辅助教学研发的，他仿照了 Unix 操作系统，并开放了源码，以便学生能够更好的理解操作系统教材。Minix 操作系统不如 Unix 操作系统成熟（但相比林纳斯的版本还是好用很多），一些黑客发现了其中的一些欠缺的功能便给教授贡献代码，并希望作为正式版发布出来，但安德鲁教授觉得，我这个只是教学用的，并不打算做出点什么东西供大家使用。因此拒绝大家的代码提交合并。因此，Minix 发展便陷入了停滞状态
<img src="https://img-blog.csdnimg.cn/direct/78f67250d17a479f9111f157addea919.png" alt="在这里插入图片描述" /></p>
<p>安德鲁·塔能鲍姆教授
1991 年 8 月，林纳斯这个家伙在 Minix 新闻组里面发表了一封后面看来著名的帖子：</p>
<p>各位Minix用户，大家好。我正在制作一个（免费）的操作系统（只是作为爱好，不会像gnu那样专业）。这个项目从4月就启动了，并将要准备好。我想听听大家的意见，特别是大家喜欢或不喜欢Minix的地方，因为我的操作系统将会和Minix有些像。我正在移植bash和gcc。这意味着接下来的几个月里，我将获得一些实质性的成果…… 此外，它没有用Minix的代码……
这看起来像是在和 Minxi 叫板，但却得到了新闻组内绝大多数黑客的支持。社区的力量是强大的，发帖不久后，就有 Minix 用户向林纳斯反馈自己想要的功能。更有用户为林纳斯建立 FTP 服务器，方便上传 Linux 代码。随后林纳斯与社区人员一起，不断迭代完善它，并最终于 1994 年 3 月 14 日正式发布了 1.0 版本。之后的故事我们都很熟悉了，由于 Linux 的开源理念，Linux 一路高歌猛进，并最终成为当下影响力最大的操作系统，没有之一
<img src="https://img-blog.csdnimg.cn/direct/910c1932b9934b11897294f2af760c8e.png" alt="在这里插入图片描述" /></p>
<p>我们事后看来，林纳斯是极其幸运的。因为 Linux 的发展壮大纯属意外。假设当时 Unix 对个人用户降价，或者 Minix 当时将社区维护交由热心者继续开发，又或者当时开发类 Unix 系统的 GNU 项目早一点研发出类 Unix 的内核，那么也就没有现在的 Linux 了。不过历史没有假如，从这一点上来看，时机对一个人来说，相当重要。这一点也可以从 BAT 创始人的身上得到印证。早一批开发出 MSN 软件的马化腾，率先建立电商帝国的马云，和开创近乎垄断国内搜索引擎业务的李彦宏，他们每一个人的成功，都毋庸置疑地抓住了时代的先机</p>
<p>当然，我们并不能因为林纳斯幸运，就忽略了他极大地贡献。而且，如果我们细心，就会发现，林纳斯身上有太多值得我们普通人学习的特质</p>
<p>首先，林纳斯极其专注，和很多功成名就的黑客大师不同，现年 49 岁的林纳斯从不做跨界的事。甚至有传言说，林纳斯因为极度聚焦于自己所擅长的领域，以至于不会搭建 web 服务。可以讲，林纳斯的整个青春是奉献到 Linux 事业当中的，要知道，从 Linux 开发至今 28 个年头，没有超出常人的意志力和耐心是没有办法坚持下来的。不过这一点林纳斯有他自己的理解，他表示他非常想告诉大家“坚持就是胜利”，但是很遗憾的是事实并非如此。最重要的是找到自己感兴趣的事情去做</p>
<p>除此之外，林纳斯淡泊名利，在当年 Windows 帝国的统治下，Linux 系统成为各大公司几乎唯一的选择。《福布斯》杂志将林纳斯的照片刊登在当年的杂志封面上，并觉得这个来自芬兰的穷小子是绝对有望打败微软帝国的黑马。但尽管林纳斯坐拥 Linux 这个商标，却并没有拿它盈利。在我看来，他甚至过的有点寒掺。在 1997 年，林纳斯带着妻女迁居美国的时候，账户里只有几千美元的余额，在美国的第一个晚上，林纳斯不得不和妻子挤在充气床垫上熬过漫漫长夜。如果他愿意，他完全可以选择更好的生活，乔布斯曾经亲自邀请林纳斯加盟苹果公司，Red Hat 及 VA Linux 这样提供 Linux 服务和支持的公司也同时成立起来，如果他愿意，他完全可以大展宏图，名利双收，但林纳斯仅接受了这些公司表达的感谢而赠予的期权。但他不愿意加盟任意一家公司，以避免他自己因为商业利益而无法保持中立</p>
<p><img src="https://img-blog.csdnimg.cn/direct/3e599b1625df443e9d35b0d6a071bb0a.png" alt="在这里插入图片描述" /></p>
<p>讲到这里，我们补充一点林纳斯身上的趣事，你会发现这个人非常爱憎分明。平时他行事非常低调，以至于你很少看到他的报道，但他在网络邮件上，却以脾气火爆著称。例如，在一次与人争论他发明的 Git 为何不使用 C++ 开发时，与对方用 "bullshit"互骂。更曾以“一群自慰的猴子”（原文为“OpenBSD crowd is a bunch of masturbating monkeys”）的称呼来讽刺 OpenBSD 团队。而在 2012 年 6 月 14 日，在出席芬兰的阿尔托大学所主办的一次活动时，称 Nvidia 是他所接触过的“最烂的公司”（the worst company）和 “最麻烦的公司”（the worst trouble spot），因为 Nvidia 从未针对 Linux 平台发布任何官方的 Optimus 支持。随后便做了 NSFW(Not Safe/Suitable For Work 表示不适合在工作场合出现的内容) 的手饰和言论：“Nvidia，操你的! ”（So, Nvidia, fuck you!）</p>
<p><img src="https://img-blog.csdnimg.cn/direct/853ec683cc3c42ca81116dc7a17ac34c.png" alt="在这里插入图片描述" /></p>
<p>另外，我们的 Linux 之父一直都保持不鸣则已一鸣惊人的姿态。因此，留下了很多非常犀利有趣的言论</p>
<p><strong>关于穿着</strong></p>
<p>"我从小不太讲究穿衣，长大后，又突然要由别人来决定我的穿衣，这些人主要是某些高技术公司的销售人员，我就穿他们在会议上免费发送的T恤和夹克。"</p>
<p><strong>关于成长</strong></p>
<p>"妈妈对她的一些朋友们说，我是个非常好养的孩子。她只要把我放在一个黑咕隆咚的储藏柜里，再配上一台电脑，偶尔朝里扔一些意大利面条，我就会感到格外高兴了。她的话不无道理。"</p>
<p><strong>关于入伍</strong></p>
<p>"在那里手拿武器，上了一个月的操练课后，我便觉得有生之年完全有资格从此一动不动，享受平静的生活了。惟一可做的事情就是在键盘上打代码，或者手里端着一瓶啤酒。"</p>
<p><strong>关于打工</strong></p>
<p>"我一贯喜欢室外运动，曾经一度当过邮差，但送的不是报纸而是垃圾邮件。"</p>
<p><strong>关于 Unix</strong></p>
<p>"你在UNIX上完成的大部分任务都是通过六个基本操作完成的，它们被称作"系统呼叫"（system call）。第一个基本操作是"创建子进程"（fork），一个程序把自身完全复制出来，这样你就有了两个相同的拷贝。第二个基本操作是复制出来的程序，再用一个新项目替换自己。其他四个基本系统呼叫--打开、关闭、读和写--都是为了访问文件的。这六个系统呼叫便组成了UNIX的简单操作。然后，你只需在程序之间创造出交流渠道（pipes），就能解决复杂的问题。"</p>
<p><strong>关于编程</strong></p>
<p>"对于任何编程的人来说，编程是世界上最有趣的事，比下棋有乐趣得多，因为你可以自己制订游戏规则。而你制定什么样的规则，也就会导出与此规则相符合的结果。"</p>
<p><strong>关于操作系统</strong></p>
<p>"创造操作系统，就是去创造一个所有应用程序赖以运行的基础环境。从根本上来说，就是在制定规则：什么可以接受，什么可以做，什么不可以做。事实上，所有的程序都是在制定规则，只不过操作系统是在制定最根本的规则。"</p>
<p><strong>关于 Linux 的发明</strong></p>
<p>"这花费了我大量的精力：编程――睡觉――编程――睡觉――编程――吃饭（饼干）――编程――睡觉――编程――洗澡（冲冲了事）――编程。"</p>
<p><strong>关于妹纸</strong></p>
<p>"在那个时候，只要一想到姑娘，Linux系统就变得不再重要了。在某种程度上，今天也还是这样。"</p>
<p><strong>关于网络口水仗</strong></p>
<p>"它们的全部存在意义就是不遗余力地宣传什么东西，也就意味着还要贬损其他的相关物。你在那里经常看到的通常只是些"我的系统比你的系统更好"之类的废话。我们可以把它们看作是某种形式的在线手淫。"</p>
<p><strong>关于攻击者</strong></p>
<p>"有人声称，作为Linux领头人所产生的压力，已经使我从一个电脑迷变成了一个混蛋。他错了，实际上我一直是一个混蛋。"</p>
<p><strong>关于成名</strong></p>
<p>"当人们开始过分认真地对待你时，就为你设下了一个温柔的陷阱。"</p>
<p><strong>关于律师</strong></p>
<p>"那些将人类的创造结果称之为是"财产"的人，不用说，便是律师了。"</p>
<p><strong>关于电子邮件</strong></p>
<p>"我喜欢电子邮件的众多理由之一是，它如此方便又如此容易被忽略。你可以轻松地对某些邮件不加理睬。"</p>
<p><strong>关于生活哲学</strong></p>
<p>"寻找乐趣，做一些有趣的事情，增加财富和提高名声。"</p>
<p><strong>关于技术未来</strong></p>
<p>"当你谈及技术的未来时，真正有意义的是人们想要什么？一旦能够描绘出这一点，剩下的事情就是如何大规模地生产它，并使它足够便宜，以便人们能够在不牺牲另外也想要的东西的同时获得它。除此而外，没有任何事情真正有意义。"</p>
<p>当然还有那句最著名的：</p>
<p>Talk is cheap. Show me the code</p>
<p>林纳斯无疑活成了大多数程序员该活成的样子，极度专注，淡泊名利，能够在自己喜欢的事业上耕耘成长。鸡仔也希望大家能够有幸，走出属于自己的路。希望林纳斯的故事对你有所启发</p>
<p>最后邀请你思考一下："在当下生存压力这么大的情况下，如何培养自己的兴趣，并长期坚持下来？"</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="名人传"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_枚举类型【十三】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_enum%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%8D%81%E4%B8%89/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_enum%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%8D%81%E4%B8%89/</id>
    <published>2024-04-04T11:55:43.000Z</published>
    <updated>2024-04-04T11:55:43.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>什么是枚举类型</h2>
<ol>
<li>枚举类型(Enum)  是由基础整型数值类型的一组命名常量定义的<strong>值类型。</strong></li>
<li>枚举包含自己的值，但<strong>不能继承或传递继承。</strong></li>
</ol>
<h2>语法</h2>
<pre><code>// enum enum_name
// enum_name variable = enum_name.enum_value

// 定义一个枚举类型——例如：
enum enum_name
{
   value_1,
   value_2,
   value_3,
   value_4
}

</code></pre>
<pre><code>enum enum_name {value_1, value_2, value_3, value_4}
</code></pre>
<ol>
<li>enum表示声明为枚举类型，Drink为枚举名，花括号内为枚举值</li>
<li>枚举不能定义在方法内。</li>
<li>枚举名用于指定枚举的类型名称，在方法中可以被当中类型来使用。</li>
<li>若有多个枚举值，则用逗号来分隔开来。</li>
</ol>
<h2>接收和输出枚举值</h2>
<ol>
<li>枚举类型是由基础整型数值类型的一组命名常量定义的<strong>值类型。</strong></li>
<li><strong>枚举类型一旦被定义，则无法修改枚举值</strong>，因为里面的值为常量。</li>
<li>前面已经说过如何定义，所以我们直接来实例：</li>
</ol>
<pre><code>using System;
namespace Enum_Project
{
    public class Program
    {
    
        //定义一个枚举类型
        enum Drink {MilkTea, CocaCola, BlackCoffee, MangoJuice}
        public static void Main(string[] args)
        {
            // 接收值
            Drink client = Drink.CocaCola;
            // 输出值
            Console.WriteLine(client);
        }
    }
}
</code></pre>
<pre><code>
&gt;&gt;&gt; CocaCola
</code></pre>
<h2>关联数值转换</h2>
<ol>
<li>一般来讲，我们只能通过枚举的基本值来获取内容，但其实每个值都有一个对于的数值，就和String类型的index索引一样。</li>
<li>比如我们定义一个枚举类型enum a {我, 是, 帅, 哥}，其中“我”对应的就是数值0，“哥”对应的是数值3。</li>
<li>但要注意的是，我们无法直接用和索引一样的方法来获取枚举值，我们需要通过数值的显示转换才可以。</li>
</ol>
<blockquote>
<p>对于任何枚举类型，枚举类型与其基础整型类型之间存在显式转换。 如果将枚举值转换为其基础类型，则结果为枚举成员的关联整数值。</p>
</blockquote>
<ol>
<li>话不多说，我们直接用实例来观察：</li>
</ol>
<pre><code>using System;
namespace Enum_Project
{
    public class Program
    {
    
        //定义一个枚举类型
        enum Drink {MilkTea, CocaCola, BlackCoffee, MangoJuice}
        public static void Main(string[] args)
        {
            // 显示转换并输出值
            Console.WriteLine((Drink)2);   // 输出数值“2”对应的值
            Console.WriteLine((int)Drink.MangoJuice);  // 输出值对应的数值
        }
    }
}
</code></pre>
<pre><code>&gt;&gt;&gt; BlackCoffee
&gt;&gt;&gt; 3
</code></pre>
<ol>
<li>可以发现，当我们转化为对于的数值2时，输出的就是第三个枚举值。</li>
</ol>
<h2>Switch实际应用</h2>
<ol>
<li>枚举类型用在Switch语句内，在合适不过了，因为枚举类型是定值，值为常量。</li>
</ol>
<pre><code>using System;

namespace Enum_Project
{
    public class Program
    {

        enum Drink {MilkTea, CocaCola, BlackCoffee, MangoJuice}
        public static void Main(string[] args)
        {
            // Drink client = Drink.CocaCola;
            // Console.WriteLine((int)Drink.MangoJuice); 

            Drink Client = Drink.CocaCola;

            switch (Client)
            {
                case Drink.MilkTea:
                Console.WriteLine("您点了一杯奶茶");
                break;

                case Drink.CocaCola:
                Console.WriteLine("您点了一瓶可口可乐");
                break;

                case Drink.BlackCoffee:
                Console.WriteLine("您点了一杯黑咖啡");
                break;

                case Drink.MangoJuice:
                Console.WriteLine("您点了一杯芒果汁");
                break;

            }
        }
    }
}

</code></pre>
<pre><code>&gt;&gt;&gt; 您点了一瓶可口可乐
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Simple Guides for Mizuki</title>
    <link href="https://mizuki.mysqil.com/posts/guide/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/guide/</id>
    <published>2024-04-01T00:00:00.000Z</published>
    <updated>2024-04-01T00:00:00.000Z</updated>
    <summary>How to use this blog template.</summary>
    <content type="html"><![CDATA[<p>This blog template is built with <a href="https://astro.build/">Astro</a>. For the things that are not mentioned in this guide, you may find the answers in the <a href="https://docs.astro.build/">Astro Docs</a>.</p>
<h2>Front-matter of Posts</h2>
<pre><code>---
title: My First Blog Post
published: 2023-09-09
description: This is the first post of my new Astro blog.
image: ./cover.jpg
tags: [Foo, Bar]
category: Front-end
draft: false
---
</code></pre>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>title</code></td>
<td>The title of the post.</td>
</tr>
<tr>
<td><code>published</code></td>
<td>The date the post was published.</td>
</tr>
<tr>
<td><code>pinned</code></td>
<td>Whether this post is pinned to the top of the post list.</td>
</tr>
<tr>
<td><code>description</code></td>
<td>A short description of the post. Displayed on index page.</td>
</tr>
<tr>
<td><code>image</code></td>
<td>The cover image path of the post.&lt;br/&gt;1. Start with <code>http://</code> or <code>https://</code>: Use web image&lt;br/&gt;2. Start with <code>/</code>: For image in <code>public</code> dir&lt;br/&gt;3. With none of the prefixes: Relative to the markdown file</td>
</tr>
<tr>
<td><code>tags</code></td>
<td>The tags of the post.</td>
</tr>
<tr>
<td><code>category</code></td>
<td>The category of the post.</td>
</tr>
<tr>
<td><code>licenseName</code></td>
<td>The license name for the post content.</td>
</tr>
<tr>
<td><code>author</code></td>
<td>The author of the post.</td>
</tr>
<tr>
<td><code>sourceLink</code></td>
<td>The source link or reference for the post content.</td>
</tr>
<tr>
<td><code>draft</code></td>
<td>If this post is still a draft, which won't be displayed.</td>
</tr>
</tbody>
</table>
<h2>Where to Place the Post Files</h2>
<p>Your post files should be placed in <code>src/content/posts/</code> directory. You can also create sub-directories to better organize your posts and assets.</p>
<pre><code>src/content/posts/
├── post-1.md
└── post-2/
    ├── cover.png
    └── index.md
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="Guides"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_变量常量与作用域【十二】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%A8%8B%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8D%81%E4%BA%8C/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%A8%8B%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8D%81%E4%BA%8C/</id>
    <published>2024-03-10T18:26:00.000Z</published>
    <updated>2024-03-10T18:26:00.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>变量</h2>
<ol>
<li>变量是用来存储数据值的标识符。</li>
<li>你可以将变量视为内存中的一个位置，这个位置可以保存不同类型的数据。</li>
<li>同时，变量也被称作为<strong>类中的成员变量</strong></li>
</ol>
<blockquote>
<p>在C#中声明变量时，你需要指定变量的类型，这告诉编译器你打算在变量中存储什么类型的数据。</p>
</blockquote>
<h2>常量</h2>
<ol>
<li>在C#中，常量（也称为字面量或常量值）是一种在编译时确定并在程序执行期间不可更改的值。</li>
<li>常量可以是任何基本数据类型（如整数、浮点数、字符等）的值，也可以是字符串、枚举类型或引用类型的值（只要它们在初始化时被赋值为 null）。</li>
</ol>
<blockquote>
<p>常量必须在声明时初始化，并且一旦初始化后，它们的值就不能被修改。常量的声明通常使用 const 关键字。</p>
</blockquote>
<ol>
<li>声明一个常量</li>
</ol>
<pre><code>const int a = 3;
int b = 2;

Console.WriteLine(a + b);   // 输出：5
</code></pre>
<h2>作用域</h2>
<ol>
<li>C#中的作用域被分为以下几种：</li>
</ol>
<ul>
<li><strong>局部作用域</strong>：通常被包含着方法，循环、条件的{}内在这个作用域内声明的变量（局部变量）只能在该作用域及其嵌套的作用域内被访问。</li>
<li><strong>类作用域</strong>：在类作用域内声明的变量（字段）可以被类的所有方法访问，但需要遵循访问修饰符（如 public、private 等）的规则。在类作用域内声明的变量（字段）可以被类的所有方法访问，但需要遵循访问修饰符（如 public、private 等）的规则。</li>
<li><strong>命名空间作用域</strong>：命名空间作用域指的是命名空间内部的区域。命名空间用于组织和隔离程序中的类和方法。在命名空间作用域内声明的类型（类、接口、枚举等）可以在整个命名空间及其子命名空间中被访问。</li>
<li><strong>全局作用域</strong>：全局作用域通常指的是程序的全局区域，这在C#中通常是整个程序集（Assembly）的上下文。</li>
</ul>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_字符串的常用操作方法【十一】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%E5%8D%81%E4%B8%80/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%E5%8D%81%E4%B8%80/</id>
    <published>2024-03-10T17:36:00.000Z</published>
    <updated>2024-03-10T17:36:00.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<p>@[toc]</p>
<h2>索引字符串( Index )</h2>
<ol>
<li>当我们要查看字符串中的某个字符时，我们可以使用索引功能。</li>
</ol>
<pre><code>string ax = "我是大帅哥";

char temp = ax[2];
Console.WriteLine(temp);
</code></pre>
<ol>
<li>查看运行效果：</li>
</ol>
<pre><code>&gt;&gt;&gt;大
</code></pre>
<h2>遍历字符串( for )</h2>
<ol>
<li>遍历字符串可以使用for语句，通过循环迭代的索引值，获取字符串的每一个字。</li>
<li>其中<strong>ax.Length</strong>表示获取字符串中的字符个数。</li>
</ol>
<pre><code>using System;
namespace tiamo
{
	public class Program
	{
	    static void Main(string[] args)
	    {
	    	string ax = "我是大帅哥";    // 定义一个字符串

	    	for(int i = 0; i &lt; ax.Length; i++)   
	    	{
	    		Console.WriteLine(ax[i]);   // 利用循环索引，打印
	    	}
	    }
	}
}
</code></pre>
<ol>
<li>查看运行效果：</li>
</ol>
<pre><code>&gt;&gt;&gt;我
&gt;&gt;&gt;是
&gt;&gt;&gt;大
&gt;&gt;&gt;帅
&gt;&gt;&gt;哥
</code></pre>
<h2>拆分字符串( Split )</h2>
<ol>
<li>拆分字符串我们通常采用Split()方法，它会以某个字符作为拆分点，并将拆分下来的字符串或字符转变为一个字符串数组。</li>
<li>Split 方法是 System.String 类的一个静态方法，用于将字符串拆分为字符串数组。</li>
<li>该方法的具体语法：<strong>Spilt("分割点")</strong></li>
<li>所以我们需要通过遍历才能拿查看数组内的所有值。</li>
<li>虽然foreach()无法直接遍历字符串类型，但可以遍历出数组类型中的字符串。</li>
<li>其中Split(",")中的,表示将，作为拆分点。更多相关可参考   <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/how-to/parse-strings-using-split">官方文档</a></li>
</ol>
<pre><code>string ax = "我是大帅哥，我很想低调，但这很难";

string[] temp = ax.Split("，");	  

foreach (string x in temp) 
{
	Console.WriteLine(x);
}
</code></pre>
<ol>
<li>查看运行效果：</li>
</ol>
<pre><code>&gt;&gt;&gt;我是大帅哥
&gt;&gt;&gt;我很想低调
&gt;&gt;&gt;但这很难
</code></pre>
<h2>替代字符串( Replace )</h2>
<ol>
<li>完美可以使用Replace( )方法来实现替代字符串。</li>
<li>该方法的具体语法：<strong>Replace("被替代的", "要替代的" )</strong></li>
</ol>
<pre><code>string ax = "精益求精，至臻至善";

string temp = ax.Replace("至臻至善", "成就完美");

Console.WriteLine(temp);
</code></pre>
<ol>
<li>查看运行效果：</li>
</ol>
<pre><code>&gt;&gt;&gt;精益求精，成就完美
</code></pre>
<h2>提取字符串( Substring )</h2>
<ol>
<li>使用Substring( )方法可以从指定的索引值开始提取。</li>
<li>该方法的具体语法：<strong>Substring(index, length)</strong>，其中index表示该索引值开始提取，length表示提取的字符长度，如果只指定一个参数，则默认为index。</li>
</ol>
<pre><code>string ax = "我是大帅哥";  

string temp = ax.Substring(2);     // 从索引2开始提取（包括索引2）
Console.WriteLine(temp);

string temp_2 = ax.Substring(1, 3);  // 从索引1开始提取，只提取3个字符
Console.WriteLine(temp_2);
</code></pre>
<ol>
<li>查看运行效果：</li>
</ol>
<pre><code>&gt;&gt;&gt;大帅哥
&gt;&gt;&gt;是大帅
</code></pre>
<h2>插入字符串( Insert )</h2>
<ol>
<li>Insert( )方法为我们提供了插入字符串的功能。</li>
<li>Insert 方法是 StringBuilder 类的一个成员，它用于在 StringBuilder 对象的指定位置插入一个字符串。</li>
<li>该方法的具体语法：**Insert(index, value)**其中，index表示在该索引值后面插入，value表示要插入的字符串或字符。</li>
</ol>
<pre><code>string ax = "我是大帅哥";

string temp = ax.Insert(2, "超级");
Console.WriteLine(temp);
</code></pre>
<pre><code>&gt;&gt;&gt;我是超级大帅哥
</code></pre>
<h2>移除字符串( Remove )</h2>
<ol>
<li>Remove 方法是 StringBuilder 类的一个成员，它用于从 StringBuilder 对象中删除指定范围的字符。</li>
<li>该方法的具体语法：<strong>Remove(index, value)</strong>，其中index表示该索引值开始移除，length表示移除的字符长度，如果只指定一个参数，则默认为index，如果为0，则表示全部移除为空</li>
</ol>
<pre><code>string ax = "我是大帅哥";

string temp = ax.Remove(1);
Console.WriteLine(temp);

string temp_2 = ax.Remove(2, 2);
Console.WriteLine(temp_2);
</code></pre>
<pre><code>&gt;&gt;&gt;我是
&gt;&gt;&gt;我是哥
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Sublime Text4代码配色自定义方案</title>
    <link href="https://mizuki.mysqil.com/posts/sublime-text4%E4%BB%A3%E7%A0%81%E9%85%8D%E8%89%B2%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E6%A1%88/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/sublime-text4%E4%BB%A3%E7%A0%81%E9%85%8D%E8%89%B2%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E6%A1%88/</id>
    <published>2024-03-05T12:30:10.000Z</published>
    <updated>2024-03-05T12:30:10.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<p>@[toc]</p>
<h2>前言</h2>
<ol>
<li>关于Sublime Text对于我的使用体验，只能说内置的代码主题真的都太low了，一点都不好看。</li>
<li>所以接下来我分享一下我自定义代码配色。</li>
<li>当然，大家也可以通过我给的中文翻译注释来自定义自己喜欢的颜色。</li>
<li>废话不多说，直接上代码</li>
<li><strong>直接将代码复制粘贴到：Preferences &gt; Customize Color Scheme 即可。</strong></li>
</ol>
<pre><code>{
	"variables":
	{
		"white": "hsl(163, 59%, 53%)",
	},
	"globals":
	{
		"foreground": "var(white)",  // 前景色
		"background": "rgb(43, 48, 56 )",  // 背景
	},
	"rules":
	[
		{
            "name": "Comment",  // 注释
            "scope": "comment, punctuation.definition.comment",
            "foreground": "var(green)"
        },
        {
            "name": "String",    // 字符串
            "scope": "string",
            "foreground": "rgb(215, 215, 215)"
        },
        {
            "name": "Punctuation",   // 符号
            "scope": "punctuation.section",
            "foreground": "var(white2)"
        },
  
        {
            "name": "Punctuation",  // 符号
            "scope": "punctuation.definition - punctuation.definition.numeric.base",
            "foreground": "var(blue5)"
        },
        {
            "name": "Number",    // 数字
            "scope": "constant.numeric",
            "foreground": "var(orange)"
        },
        {
            "name": "Number Suffix",    // 数字后缀
            "scope": "storage.type.numeric",
            "foreground": "var(pink)",
            "font_style": "italic"
        },
        {
            "name": "Built-in constant",    // 内置常量值
            "scope": "constant.language",
            "foreground": "var(red)",
            "font_style": "italic"
        },
          {
            "name": "User-defined constant",  // 用户定义的常量
            "scope": "constant.character, constant.other",
            "foreground": "var(pink)"
        },
          {
            "name": "Member Variable",     // 成员变量
            "scope": "variable.member",
            "foreground": "var(red)"
        },
          {
            "name": "Keyword",    // 关键字
            "scope": "keyword - keyword.operator, keyword.operator.word",
            "foreground": "rgb(255, 138, 232)"
        },
        {
            "name": "Operators",   // 运算符号
            "scope": "keyword.operator",
            "foreground": "rgb(239, 239, 239)"
        },
                {
            "name": "Punctuation",    //标点符号(分号)
            "scope": "punctuation.separator, punctuation.terminator",
            "foreground": "var(blue6)"
        },
        {
            "name": "Storage",    // 储存器(public)
            "scope": "storage",
            "foreground": "rgb(255, 84, 90)"
        },
        {
            "name": "Storage type",   // 储存器类型(void)
            "scope": "storage.type",
            "foreground": "rgb(255, 140, 161)",
            "font_style": "italic"
        },
        {
            "name": "Inherited class", // 继承类
            "scope": "entity.other.inherited-class",
            "foreground": "var(blue5)",
            "font_style": "italic"
        },
        {
            "name": "Function argument",   // 函数参数
            "scope": "variable.parameter",
            "foreground": "var(orange)"
        },
        {
            "name": "Language variable",  // 语言变量
            "scope": "variable.language",
            "foreground": "var(red)",
            "font_style": "italic"
        },
        {
            "name": "Tag name",  // 标签名称
            "scope": "entity.name.tag",
            "foreground": "var(red)"
        },
        {
            "name": "Function call",   // 函数调用(方法)
            "scope": "variable.function, variable.annotation",
            "foreground": "rgb(253, 226, 102)"
        },
        {
            "name": "Library class/type",  // 库函数/类类型
            "scope": "support.type, support.class",
            "foreground": "var(blue)",
            "font_style": "italic"
        },
        {
            "name": "CSS Properties",
            "scope": "support.type.property-name",
            "foreground": "var(white3)"
        },
        
	]
}
</code></pre>
<h2>Settings设置</h2>
<ol>
<li>顺便把用户设置也改一下（Preferences &gt; Settings）</li>
</ol>
<pre><code>{
	"ignored_packages":
	[
		"Package Control",
		"Vintage",
	],
	"index_files": true,
	"font_size": 15,
	"theme": "Default Dark.sublime-theme",
	"color_scheme": "Mariana.sublime-color-scheme",
	"dark_color_scheme": "Sixteen.sublime-color-scheme",
	"light_color_scheme": "Mariana.sublime-color-scheme",
		
	"caret_style": "smooth", // 光标样式
	"line_padding_top": 1,    // 行高
	//"font_face": "JetBrains Mono Medium",  // 字体样式
	"auto_complete": true,        // 代码提示

}
</code></pre>
<h2>效果图</h2>
<p>在这里插入图片描述</p>
<p><img src="https://s2.loli.net/2024/03/31/Z13zLGsCmjoh957.png" alt="post_subcustom.png" /></p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="IDE"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_数组的遍历【十】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E5%8D%81/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E5%8D%81/</id>
    <published>2024-03-04T18:43:03.000Z</published>
    <updated>2024-03-04T18:43:03.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>输出数组内容</h2>
<ol>
<li>一般而言，我们会使用索引来输出指定的内容。</li>
</ol>
<pre><code>int[] arrayInt = new int[]  {4, 5, 2, 7, 9};
Console.WriteLine(arrayInt[3]);
</code></pre>
<ol>
<li>但这样只能输出指定的索引指向的内容，无法一下子查看数组全部的值。</li>
<li>所以我们需要用到遍历方法输出所有元素。</li>
</ol>
<h2>几种常用的遍历方法</h2>
<h3>1. foreach( )</h3>
<ol>
<li>forach十分适合用作遍历数组，因为语法很简单。</li>
<li>用过Python的都知道，它就相当于是Python语言中的for循环语句，当然，在C#中它也可以算作是一种循环语句。</li>
<li>它的具体流程是<strong>将数组内的元素，迭代给临时变量，每执行一次迭代一个元素给临时变量，直到全部迭代完成</strong>。</li>
</ol>
<pre><code>foreach (Type in Collection) {}
</code></pre>
<ol>
<li>看下面的案例：</li>
</ol>
<pre><code>int[] arrayInt = new int[]  {4, 5, 2, 7, 9};

foreach (int temp in  arrayInt) 
{
	 Console.WriteLine(temp);
}
</code></pre>
<p>//  运行结果：</p>
<pre><code>&gt;&gt;&gt;4
&gt;&gt;&gt;5
&gt;&gt;&gt;2
&gt;&gt;&gt;7
&gt;&gt;&gt;9
</code></pre>
<h3>2. For</h3>
<ol>
<li>其实用于遍历的主要就是循环语句。</li>
<li>for语句我们可以通过编写特定程序，也能够实现遍历。</li>
<li>直接看实例吧：</li>
</ol>
<pre><code>for (int temp = 0; temp &lt; arrayInt.Length; temp++)
{
	 Console.WriteLine(arrayInt[temp]);
}
</code></pre>
<p>//  运行结果：</p>
<pre><code>&gt;&gt;&gt;4
&gt;&gt;&gt;5
&gt;&gt;&gt;2
&gt;&gt;&gt;7
&gt;&gt;&gt;9
</code></pre>
<ol>
<li>其中：.Length是一种方法，用于获取各种容器中的长度。我们通过循环，将索引叠加，直到无法满足大于该长度即可。</li>
</ol>
<h3>3. While</h3>
<ol>
<li>while遍历数组的原理和for一样，其实没必要用while语句</li>
</ol>
<pre><code>int[] arrayInt = new int[]  {4, 5, 2, 7, 9};

int temp = 0;
while (true) 
{
	Console.WriteLine(arrayInt[temp]);
	if (temp &gt; arrayInt.Length) 
	{
		break;
	}
	else
	{
		temp ++;
    }
}
</code></pre>
<p>//  运行结果：</p>
<pre><code>&gt;&gt;&gt;4
&gt;&gt;&gt;5
&gt;&gt;&gt;2
&gt;&gt;&gt;7
&gt;&gt;&gt;9
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_数组的声明, 初始化与赋值【九】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E8%B5%8B%E5%80%BC%E4%B9%9D/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E8%B5%8B%E5%80%BC%E4%B9%9D/</id>
    <published>2024-03-04T18:33:24.000Z</published>
    <updated>2024-03-04T18:33:24.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>什么是数组？</h2>
<blockquote>
<ol>
<li><strong>可以将同一类型的多个变量存储在一个数组数据结构中</strong>。 <em><strong>通过指定数组的元素类型来声明数组</strong></em>。 如果希望数组存储任意类型的元素，可将其类型指定为</li>
<li>object。 在 C# 的统一类型系统中，所有类型（预定义类型、用户定义类型、引用类型和值类型）都是直接或间接从 Object 继承的。</li>
</ol>
</blockquote>
<ol>
<li>数组具有以下属性：</li>
</ol>
<ul>
<li>数组可以是一维、多维或交错的。</li>
<li>声明数组变量时设置维度数。 创建数组实例时，将建立每个维度的长度。 这些值在实例的生存期内无法更改。</li>
<li>交错数组是数组数组，每个成员数组的默认值为null。</li>
<li>数组从零开始编制索引：包含 n 元素的数组从 0 索引到 n-1。</li>
<li>数组元素可以是任何类型，其中包括数组类型。</li>
<li>数组类型是从抽象的基类型 Array 派生的引用类型。 所有数组都会实现IList和IEnumerable。 可以使用 foreach 语句循环访问数组。 单维数组还实现了 IList&lt;T&gt; 和 IEnumerable&lt;T&gt;。</li>
</ul>
<h2>声明数组</h2>
<ol>
<li>定义有个数组其实很简单：</li>
</ol>
<ul>
<li><strong>datatype</strong>：指数组的数据类型。</li>
<li><strong>[]</strong> ：指定数组的秩（维度）。秩指定数组的大小。</li>
<li><strong>arrayName</strong>：指定数组的名称</li>
</ul>
<pre><code>datatype[] arrayName;
</code></pre>
<h2>初始化数组</h2>
<ol>
<li>当声明有个数组后，这个数组是不含任何值的，赋值，所以我们需要将数组初始化，来使得数组能够被赋值。</li>
</ol>
<blockquote>
<ol>
<li>数组是一个引用类型，所以您需要使用 new 关键字来创建数组的实例。</li>
</ol>
</blockquote>
<p>例如：</p>
<ol>
<li>其中  <strong>[ 5 ]</strong>：表示将这个数组初始化为5大小，<strong>也就是说数组内有5个元素</strong>（也可以被作为<strong>索引</strong>）。</li>
<li>当然，<strong>[ ]</strong> 内也可以不填，如果填写了，那么在没赋值前，值全都为零。</li>
</ol>
<pre><code>int[] arrayInt;    // 声明一个整数数组
arrayInt = new int[5];  // 初始化数组
</code></pre>
<h2>数组赋值</h2>
<blockquote>
<p>声明一个数组不会在内存中初始化数组。当初始化数组变量时，您可以赋值给数组。</p>
<p>数组是一个引用类型，所以您需要使用 new 关键字来创建数组的实例。</p>
</blockquote>
<ol>
<li><strong>方式一</strong>：利用索引进行单个赋值（被称之为：<strong>显式初始化</strong>）</li>
</ol>
<pre><code>int[] arrayInt;    // 声明一个整数数组
arrayInt[0] = 5;   //将索引0赋值为5
</code></pre>
<p>// 输出效果</p>
<pre><code>&gt;&gt;&gt;5
&gt;&gt;&gt;0
&gt;&gt;&gt;0
&gt;&gt;&gt;0
&gt;&gt;&gt;0
</code></pre>
<ol>
<li><strong>方式二</strong>：在声明数组的同时给数组赋值（无法指定数组的大小）（也被称之为：<strong>隐式初始化</strong>）</li>
</ol>
<pre><code>int[] arrayInt = {1, 5, 5, 3, 8};
</code></pre>
<p>// 输出效果</p>
<pre><code>// 输出效果
&gt;&gt;&gt;1
&gt;&gt;&gt;5
&gt;&gt;&gt;5
&gt;&gt;&gt;3
&gt;&gt;&gt;8
</code></pre>
<ol>
<li><strong>方式三</strong>：创建并初始化一个数组，可指定数组大小。</li>
</ol>
<pre><code>int[] arrayInt = new int[]  {4, 5, 2, 7, 9};
</code></pre>
<p>// 输出效果</p>
<pre><code>&gt;&gt;&gt;4
&gt;&gt;&gt;5
&gt;&gt;&gt;2
&gt;&gt;&gt;7
&gt;&gt;&gt;9
</code></pre>
<ol>
<li><strong>方式四</strong>：作为变量赋值给其他数组，（相当于int a=2；b= ）</li>
</ol>
<pre><code>int[] arrayInt = new int[]  {4, 5, 2, 7, 9};
int[] arrayInt_2 = arrayInt;
</code></pre>
<p>// 输出效果</p>
<pre><code>&gt;&gt;&gt;4
&gt;&gt;&gt;5
&gt;&gt;&gt;2
&gt;&gt;&gt;7
&gt;&gt;&gt;9
</code></pre>
<h2>补充</h2>
<pre><code>int[] arrayInt = new int[] {1, 3, 5, 6, 6]
</code></pre>
<ol>
<li>注意：<strong>前面</strong>的中括号[ ]表示是<strong>声明数组</strong>，<strong>后面</strong>的中括号[ ]才表示是指定<strong>数组大小</strong>。</li>
<li>当指定了数组的大小后，在赋值时<strong>不允许超过指定的大小</strong>。</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Sublime Text4配置C#运行环境</title>
    <link href="https://mizuki.mysqil.com/posts/sublime-text4%E9%85%8D%E7%BD%AEcsharp%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/sublime-text4%E9%85%8D%E7%BD%AEcsharp%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</id>
    <published>2024-02-24T15:48:30.000Z</published>
    <updated>2024-02-24T15:48:30.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<p>@<a href="%E8%BF%99%E9%87%8C%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%AE%E5%BD%95%E6%A0%87%E9%A2%98">TOC</a></p>
<h2>前言</h2>
<ol>
<li>今天把家里的9年前的远古神机搬了出来，重装了个win7的精简版，本打算装个VScode测试一下是否能写C#代码，结果是可以的，但，卡成PPT了……</li>
<li>所以就选择了SublimeText，即便捷又快速。</li>
<li>但，网上对于Sublime Text4配置C#的文章实在是少的可怜，而且效果还不咋地。</li>
<li>我琢磨了一下午，终于是琢磨出来了。</li>
<li>今天就带大家学习一下如何快速，简单地在sublime中配置好C#的运行环境。</li>
</ol>
<h2>部署.NET环境</h2>
<ol>
<li>前提当然是部署.NET啦。</li>
<li>我们直接去Microsoft官网下载：<a href="https://dotnet.microsoft.com/zh-cn/download">https://dotnet.microsoft.com/zh-cn/download</a>（<a href="https://blog.csdn.net/weixin_51290138/article/details/136002993?spm=1001.2014.3001.5501">可以参考我往期的文章</a>）</li>
<li>部署的话后面就不赘述了……</li>
</ol>
<h2>Sublime Text4配置C#编译环境</h2>
<h4>1. 下载插件</h4>
<ol>
<li>
<p>GitHub中有个叫 “<em><strong>csharp-build-singlefile-sublime-text-2</strong></em>“的插件，用于直接在Sublime中调用终端并运行程序， 由国外大佬<strong>chrokh</strong>开发。</p>
</li>
<li>
<p>这个插件原本是用在SublimeText2上的，可以看到，作者也已经有8年没更新了，但用在Sublime Text4中效果是一样的。</p>
</li>
<li>
<p>我们直接去GitHub中下载这个插件：<a href="https://github.com/chrokh/csharp-build-singlefile-sublime-text-2">https://github.com/chrokh/csharp-build-singlefile-sublime-text-2</a></p>
</li>
<li>
<p>下载下来后，我们将其解压，将里面的名为：CSharpSingleFileBuild.sublime-build的文件复制到SublimeText的Packges文件夹中（可以从编辑器的Preferences &gt; Browse Packages打开）</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/24/xVdfj4QRU3vLrqZ.png" alt="post_sublimecsharp_1.png" />
6. 打开这个文件，将里面的代码修改为下列代码并保存。</p>
<pre><code>{
  "selector"  : "source.cs",
  "cmd"       : "mcs $file_name",
  "shell"     : true,

  "windows" : {
    "cmd"  : "csc.exe $file_name"
  },

  "variants"  : [
    {
      "cmd"   : "mono $file_base_name.exe",
      "name"  : "Run",
      "shell" : true,

      "windows" : {       
        "cmd": ["start", "cmd", "/k", " dotnet run ${file_path}/${file_base_name}"]
        
      }
    }
  ]
}
</code></pre>
<ol>
<li>最后我们在编辑器中选择 Tool &gt; Build System &gt; CSharpSingleFileBuild  即可。</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/24/Tsw9guXjv4fS2Dq.png" alt="post_sublimecsharp_2.png" /></p>
<h2>运行测试</h2>
<ol>
<li>我们写一段C#程序测试一下是否可以运行。</li>
<li>快捷键&lt;kbd&gt;Ctrl + Shift + B&lt;/kbd&gt; 选择下面的方式运行（以后可以直接使用&lt;kbd&gt;Crtl + B&lt;/kbd&gt;）。</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/24/pTcAGJdvqj3L6kw.png" alt="post_sublimecsharp_3.png" />
3. 结果可以看到，运行成功了！！！</p>
<p><img src="https://s2.loli.net/2024/02/24/CGMmFELSyAvaHi5.png" alt="post_sublimecsharp_4.png" /></p>
<ol>
<li>如果你追求的编译速度，我认为使用Subliem Text是个很不错的选择，毕竟，轻装上阵嘛~</li>
<li>本期讲解就到这，Bye~</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="IDE"></category>
  </entry>
  <entry>
    <title>Hello World</title>
    <link href="https://mizuki.mysqil.com/posts/hello-world/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/hello-world/</id>
    <published>2024-02-24T15:48:30.000Z</published>
    <updated>2024-02-24T15:48:30.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2>Quick Start</h2>
<h3>Create a new post</h3>
<pre><code>git config --global http.proxy http://127.0.0.1:7890
</code></pre>
<pre><code>git config --global -l
</code></pre>
<pre><code>$ hexo new "My New Post"
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3>Run server</h3>
<pre><code>$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3>Generate static files</h3>
<pre><code>$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3>Deploy to remote sites</h3>
<pre><code>$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_编程练习题_输出奇偶数, 九九乘法表, 猜数字游戏【八】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0%E9%A2%98-_%E8%BE%93%E5%87%BA%E5%A5%87%E5%81%B6%E6%95%B0-%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8-%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F%E5%85%AB/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0%E9%A2%98-_%E8%BE%93%E5%87%BA%E5%A5%87%E5%81%B6%E6%95%B0-%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8-%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F%E5%85%AB/</id>
    <published>2024-02-16T16:16:18.000Z</published>
    <updated>2024-02-16T16:16:18.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>1. 输出奇偶数</h2>
<ol>
<li>
<p>要求：输出从1到100的所有偶数</p>
</li>
<li>
<p>分析：</p>
</li>
</ol>
<blockquote>
<ol>
<li>首先我们需要用到循环（while也好，for也好，但for会更加优雅），输出0到100的所以数。</li>
<li>在for的循环体内写入if条件判断语句，条件表达式为：当输出的数除于2等于0时（也就是可以被2整除）则输出这个数。</li>
<li>这样下来，可以被2整除的偶数都会被输出出来。</li>
<li>以此类推，我们只需要在for表达式内将参数改改，就可以输出质数。</li>
</ol>
</blockquote>
<pre><code>using System;
namespace Test_1
{
    public class Program
    {
        static void Main(string[] args){

            // 输出偶数
            for (int i = 0; i &lt; 101; i++){

                if(i % 2 == 0){
                    Console.WriteLine(i);
                }
             }
        }
    }
}
</code></pre>
<h2>2. 九九乘法表</h2>
<ol>
<li>要求：使用循环语句输出九九乘法表</li>
<li>分析：</li>
</ol>
<blockquote>
<ol>
<li>选择for语句进行嵌套循环</li>
<li>最外层循环9次，子循环递增到9次</li>
</ol>
</blockquote>
<pre><code>using System;
namespace jiujiu
{
    public class Program
    {  
        static void Main(string[] args)
        {
            string str = " ";
            int i;
            int j;
            int sum;
            for (i = 1; i &lt; 10; i++)
            {
                for (j = 1; j &lt;=i; j++)
                {
                    sum = i * j;
                    Console.Write(j);
                    Console.Write("*");
                    Console.Write(i);
                    Console.Write("=");
                    Console.Write(sum);
                    Console.Write(str);
                }
                Console.WriteLine();
            }
            Console.Read();
        }
    }
}
</code></pre>
<ol>
<li>输出结果：</li>
</ol>
<pre><code>PS G:\C#\test_1&gt; dotnet run "g:\C#\test_1\Program.cs"
1*1=1 
1*2=2 2*2=4 
1*3=3 2*3=6 3*3=9 
1*4=4 2*4=8 3*4=12 4*4=16 
1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 
1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 
1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 
1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 
1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 
</code></pre>
<h2>3. 猜数字游戏</h2>
<ol>
<li>要求：生成区间为(0, 12)的随机整数，并通过输入进行交互。</li>
<li>分析：</li>
</ol>
<blockquote>
<ol>
<li>可使用Random函数，进行随机整数的生成</li>
<li>将random类型转换为整数类型</li>
<li>将输入写进while循环，并在内使用if进行对错判断，猜对了则break结束循环，否则继续循环。</li>
</ol>
</blockquote>
<pre><code>using System;
namespace Test_2
{
    public class Program
    {
        static void Main(string[] args){

            // 猜数字小游戏
            Random number = new Random();
            int a = Convert.ToInt32(number.Next(0, 12));
             
             Console.WriteLine("请输入你要猜的数字：");
               
               while (true)
               {
                    int b = Convert.ToInt32(Console.ReadLine()!);

                     if (b == a){
                            
                            Console.WriteLine("恭喜你♂，猜对啦！！！Boy Next Door♂");
                            break;
                     }
                     else{
                         
                         Console.WriteLine("猜错了！！！♂");
                 }
               }
        }
    }
}
</code></pre>
<ol>
<li>运行效果如下：</li>
</ol>
<pre><code>猜错了！！！♂
9
猜错了！！！♂
8
猜错了！！！♂
1
猜错了！！！♂
10
恭喜你♂，猜对啦！！！Boy Next Door♂
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_循环语句【七】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%83/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%83/</id>
    <published>2024-02-16T13:46:50.000Z</published>
    <updated>2024-02-16T13:46:50.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>什么是循环语句？</h2>
<blockquote>
<p>循环语句是由循环体及循环的终止条件两部分组成的。</p>
</blockquote>
<blockquote>
<p>在不少实际问题中有许多具有规律性的重复操作，因此在程序中就需要重复执行某些语句。一组被重复执行的语句称之为循环体，能否继续重复，决定循环的终止条件。循环结构是在一定条件下反复执行某段程序的流程结构，被反复执行的程序被称为循环体。</p>
</blockquote>
<ol>
<li>编程语言中的循环语句大致分为两种：<strong>While，For和Do...while</strong>。那么这两种语句的本质区别在哪呢,接下来一起看看吧。</li>
</ol>
<h2>While</h2>
<ol>
<li>While是计算机编程中的一种基本循环模式。若满足条件时则进入循环体，进入循环体后，若条件不满足时，则跳出循环。</li>
</ol>
<p><img src="https://s2.loli.net/2024/03/31/LYsXQF4yz3Dc6vk.png" alt="post_CSharp7_1.png" /></p>
<ol>
<li>这是一种很典型的循环方式，所以语法也很简单。</li>
</ol>
<pre><code>// While语句的表达式

while ( /*条件表达式*/ )
         {
             /*循环体*/
         }
</code></pre>
<ol>
<li>让我们来看看实例吧！</li>
</ol>
<pre><code>using System;
namespace Whiles
{
    class First_6
    {
        static void Main(string[] args){

            int a = 0;
            while (true)                     // 条件为true
            {
                a++;
                Console.WriteLine(a);
                
                if (a &gt; 10){                // 当a大于10时，跳出循环
                    break;
                }
            }
        }
    }
}
</code></pre>
<p>输出的结果为：</p>
<pre><code>1
2
3
4
5
6
7
8
9
10
11
</code></pre>
<ol>
<li>可以看到，当while的条件满足时，则进入循环，不满足则跳出循环。</li>
</ol>
<h2>For</h2>
<ol>
<li>for循环是编程语言中一种循环语句，而循环语句由循环体及循环的判定条件两部分组成。</li>
</ol>
<p><img src="https://s2.loli.net/2024/03/31/Mf2AEcdn8zJ67sI.png" alt="post_CSharp7_2.png" /></p>
<ol>
<li>for相当于While来说要更简洁。它的能够在条件表达式内定义变量并自定义条件。</li>
</ol>
<pre><code>// For语句的表达式

for (  /* 单次表达式 ; 条件表达式 ; 末尾循环体 */)
         {
             /* 循环体 */
         }
</code></pre>
<ol>
<li>看下列代码。在for的条件表达式中，第一项为定义变量，第二项为条件，第三项为变量行为。
<ol>
<li>我们分析一下以下代码：我们定义一个数据类型为整数的i值为1，设置i&lt;11，满足条件，进入循环体，每循环一次递增1，当i递增到11后，i &lt; 11条件不满足，则跳出循环。</li>
<li>所以最后输出的内容和上面while输出的内容是一样。</li>
<li>但我们可以明显的看到，for是要比while简洁的多的。（当然，这也得看应用场合）</li>
</ol>
</li>
</ol>
<pre><code>using System;
namespace Fors
{
    class First_6
    {
        static void Main(string[] args){

         for (int i = 1; i &lt; 11; i++){

            Console.WriteLine(i);
         }
        }
    }
}
</code></pre>
<p>输出的结果为：</p>
<pre><code>1
2
3
4
5
6
7
8
9
10
11
</code></pre>
<h2>Do...while</h2>
<blockquote>
<p>do...while 循环是
while循环的变体。在检查while条件是否为真之前，该循环首先会执行一次do之内的语句，然后在while内检查条件是否为真，如果条件为真的话，就会重复do...while这个循环,直至while为假。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/03/31/7kvKNYX1J3WGidy.png" alt="post_CSharp7_3.png" /></p>
<ol>
<li>do...while的语法也很简单，比while简洁得多。</li>
</ol>
<pre><code>// Do...while 语句的表达式

do
    {
           /* 循环体 */ 
           
    } while ( /*条件表达式*/ );
</code></pre>
<ol>
<li>虽然do...while在实际开发中用的可能并不多，但掌握基础对以后的开发还是有所帮助的。</li>
<li>接下来让我们看代码实例：
<ol>
<li>可以看到，条件表达式被写在了后面，do内为循环体，按照程序的先后顺序，其实已经无条件进入do的循环体了，do会被先执行，随后才开始条件判断，当不满足，第二次的循环黑背跳出。</li>
</ol>
</li>
</ol>
<pre><code>using System;
namespace While
{
    class First_6
    {
        static void Main(string[] args){

            int i = 0;

            do
            {
                Console.WriteLine(i);        // 第一循环无条件执行
                i++;
            } while (i &lt; 10);                // 当不满足时，则跳出循环
        }
    }
}

</code></pre>
<h2>结语</h2>
<ol>
<li>我们时隔10天，终于动笔写了篇文章。</li>
<li>只说基础。</li>
<li>本期讲的是循环语句，当然，这篇文章：不论是C/C++还是C#都是通用的。语法相差不大。</li>
<li>咱们下期见，下期应该要很久……Bye</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>2023年度总结报告</title>
    <link href="https://mizuki.mysqil.com/posts/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/</id>
    <published>2024-02-14T09:39:31.000Z</published>
    <updated>2024-02-14T09:39:31.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>序幕</h2>
<ol>
<li>回首过去的一年，的确发生了许多事呢，不然，我也不可能会写年度总结。</li>
<li>咱就是说了，喜欢上写Markdown笔记了。</li>
</ol>
<h2>往事</h2>
<h4>1. 值得庆幸的是，《我懂得热爱生活》</h4>
<ol>
<li>这对于死宅的我，可能说得上是天方夜谭，但确实呢，8月16日，尽管很热我还是喜欢出去走走。</li>
</ol>
<p><img src="https://s2.loli.net/2024/01/07/O6f2WAdTtcQ8IBC.jpg" alt="life_3.jpg" /></p>
<h4>2. 不听摇滚睡不着</h4>
<ol>
<li>2023年我爱上了摇滚。</li>
<li>对于音乐，我每年的听歌风格都在变，小学爱听Tobu的EDM progressive house风格电音，后来演化为Electronic Dance Music，如Alan Walker，Vicetone的作品。现在，更偏向于Japan Rock和Chillstep、Future Bass。特爱Little End的氛围音乐和じん (Jin)的日式摇滚。</li>
<li>家人们，谁懂啊，不听摇滚睡不着。</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/14/9fsdOakHMwLtqTp.png" alt="post_2023_2.png" /></p>
<h4>3. 夏日陽炎</h4>
<ol>
<li>2023我追的番不如往年多，因为学业太繁忙了。</li>
<li>《MekakuCity Actors》（目隐都市的演绎者）2014年的番，我从半夜11点看到凌晨三点看完，虽然剧情没滤清，但我还是很喜欢。</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/14/ePomQHap4wBgj1x.jpg" alt="post_2023_1.jpg" /></p>
<h4>4 学校运动会：太糟糕了！！</h4>
<ol>
<li>每次提到运动会我都想吐。</li>
<li>去年我只报了一个项目，是的：乒乓球。是的：输了。</li>
<li>今年更离谱，我练习了好久两年半，但是，开始比赛的时候以为是热身，结果就这样送掉了。操！！！</li>
<li>不用说：运动，体育，对于我这么一个死宅来说就是望尘莫及。失败是必然的，要不是班上不积极我真懒得参与。</li>
</ol>
<h5>其实也没啥啦！，大多数都是在网络上度过，现实生活中的更多写照可以在我的相册看到。</h5>
<h2>学习往事</h2>
<blockquote>
<p>肯定不是语数英类的学习啦，那玩意看都不想看（可以说是：<em><strong>一坨答辩</strong></em>）。也不能相提并论。</p>
</blockquote>
<h4>1. Unity游戏开发（2023年1月17）</h4>
<ol>
<li>2022年尾，因为HTML + CSS之类的语言学到头了，又不知道干嘛，后来受B站的影响，我没头绪的去学Unity游戏开发了（这是毫无悬念的），在此之前我没有学过任何一门编程语言，我没有任何C#基础，甚至连Using是什么都不知道。经过我对Standard Assets项目的代码照搬，还成功被我魔改出了一款半成品的游戏“RezspairX”（严格来讲，并不能算是一款游戏，因为我没有掌握它的底层代码）。我也尝试过Unity2D，但最终都毫无悬念的失败了,我最终在3月份暂时放弃了这个计划。
<ol>
<li>虽然失败了，但至少让我提前熟悉了Unity编辑器以及游戏开发的具体过程。</li>
<li>不仅如此，我到如今都没有放弃开发游戏的想法</li>
<li>我觉得以后可能会有机会的，3D可以不说，但2D游戏总得整一个……</li>
</ol>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/02/TOqARJPuDUHhk61.png" alt="post_2023blog_8.png" /></p>
<h4>2. 首次学习编程语言（2023年3月25日）</h4>
<ol>
<li>没错的，我去学Python了，为什么，因为它太流行了，连续五年拿下了 IEEE Spectrum大奖。</li>
<li>不仅如此它也很简单（连我同学都听说：Python不是是个人都能学的会的吗？）</li>
<li>Python掌握基础我只用了两个月的时间，到了6月份的时候，我进阶高级应用：网络爬虫了。</li>
<li>到后面就越来越没劲了，爬虫学m3u8抓取就没不想学了。</li>
<li>总之，至少提前掌握了一门编程语言。</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/14/P9TGKZchJwFVkUB.png" alt="post_20223_3.jpg" /></p>
<h4>3. 初学MySQL数据库（10月24日）</h4>
<ol>
<li>说是学，但开始学之后，并不想用SQL语句，而是使用编程语言内（python）的的SQL库+SQLynx可视化数据库操作工具。</li>
<li>具体点，是PHPStudy + SQLyxn，小皮好呀，启动数据库很便捷，而且还有Web主机。</li>
<li>我发现我目前还用不上它，因为我现在不怎么做前端了，而它刚好主要是应用在前端。</li>
<li>干脆后面就停止了，后面的话，SQL也没必要学得那么精，基本操作还是可以的。</li>
<li>等会用到再说。</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/14/ayORm1eQ26sBhnH.png" alt="post_2023_4.jpg" />
<s>#### 4. 纸飞机开发团官网（）</s>
~~ 1. 基本上，市面上小众的虚拟主机我都找遍了，后来找到了个一个月10块钱的虚拟主机。~~</p>
<p>~~ 2. 使用WordPress框架搭建了一个动态网站，干脆把它变成了纸飞机的官网。~~
~~ 3. 维护是真的好，但就是页面效果我很不满意，真的不然隔壁的Hexo或Halo那样的纯静态框架。~~
~~ 4. 反正到后面资金越来越紧，就停运了。~~</p>
<p>~~ 5. 后面的话，可以不用说了，整天在学校也干不了什么名堂。~~</p>
<h2>期望</h2>
<h4>1. 高考上岸</h4>
<ol>
<li>今年上半年就要高考了，希望能考个理想的成绩。</li>
<li>当然，以我的水平也不至于到本科，只要一个能发展我的兴趣爱好的都行。</li>
</ol>
<h4>2. 精通C/C++/C#</h4>
<ol>
<li>无论如何，也得把这三大C学掉，目前在学C#，只是为了搞桌面应用开发和Unity游戏开发。</li>
</ol>
<h4>3. 希望能买部好手机</h4>
<ol>
<li>妈的，我这手机 已经用了7年了！还是我妈传下来的，真的很垃圾。</li>
<li>虽然在上学，但是也不至于到这种地步吧？</li>
<li>赶紧换掉才行。</li>
</ol>
<h4>4. 多的不说。</h4>
<ol>
<li>以梦为马， 不负韶华。</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="年度总结"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_Switch条件判断分支语句【六】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-switch%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%85%AD/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-switch%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%85%AD/</id>
    <published>2024-02-06T22:56:05.000Z</published>
    <updated>2024-02-06T22:56:05.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>Switch语句</h2>
<blockquote>
<p>Switch在一些计算机语言中是保留字，其作用大多情况下是进行判断选择。以C语言来说，switch（开关语句）常和case break
default一起使用。</p>
</blockquote>
<ol>
<li>Switch语句就相当于是else if语句，有着很相似的作用：根据条件执行相对应的代码。</li>
<li>Switch通常和case,break和deault配合使用。
<ul>
<li><strong>case</strong>：当case条件满足时要执行的代码区快</li>
<li><strong>break</strong>：当执行case内的代码后，跳出Switch语句。</li>
<li><strong>default</strong>：当所有的case条件都不满足时，程序会执行的代码块</li>
</ul>
</li>
<li>语法如下：</li>
</ol>
<pre><code>switch (expression)
{
	case label1:
		code to be executed if expression = label1;
		break;
	case label2:
		code to be executed if expression = label2;
		break;
	default:
		code to be executed
	if expression is different
	from both label1 and label2;
}
</code></pre>
<ol>
<li>实例：</li>
</ol>
<pre><code>int week = 2;

switch (week)
{
    case 1:
        Console.WriteLine("今天星期一");
        break;
    case 2:   
        Console.WriteLine("今天星期二");            // 输出：“今天星期二”
        break;
    case 3:
        Console.WriteLine("今天星期三");
        break;
    case 4:
        Console.WriteLine("今天星期四");
        break;
    case 5:
        Console.WriteLine("今天星期五");
        break;
    case 6:
        Console.WriteLine("今天星期六");
        break;
    case 7:
        Console.WriteLine("今天星期天");
        break;
}
</code></pre>
<h2>结语：</h2>
<ol>
<li>今天暂时先更新到这，明天再写完整一点。</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_If条件判断语句【五】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-if%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5%E4%BA%94/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-if%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5%E4%BA%94/</id>
    <published>2024-02-06T16:50:11.000Z</published>
    <updated>2024-02-06T16:50:11.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>前言：</h2>
<ol>
<li>本期学习的是编程语言中的主要语句：<strong>if</strong>-条件判断语句。</li>
<li>在这里我们会学到：if语法，if-else，和if嵌套。</li>
<li>话不多说，我们开始吧！</li>
</ol>
<h2>什么是条件判断语句？</h2>
<blockquote>
<p>条件语句是用来判断给定的条件是否满足(表达式值是否为0)，并根据判断的结果(真或假)决定执行的语句，选择结构就是用条件语句来实现的。</p>
</blockquote>
<ol>
<li>条件判断语句在程序中扮演着一个重要的角色。</li>
<li>通过条件判断我们可以有更多的选择面对程序中产生的问题。
<img src="https://s2.loli.net/2024/02/06/HbUcnOkpmgl4jCR.png" alt="post_CSharp5_1.png" /></li>
</ol>
<h2>If语句</h2>
<ol>
<li>语法如下：</li>
<li>括号中 “conditional expression” 为<strong>条件表达式</strong>，我们通过在括号中写入条件表达式，语句将判断条件表达式是真还是假。</li>
<li>花括号中的为：当条件为真（True）时，执行的语句。</li>
</ol>
<pre><code>if(conditional expression)
{
   /* 当条件为真时将执行的语句 */
}
</code></pre>
<ol>
<li>下面看实例：</li>
<li>结果成功输出了：Hello World</li>
</ol>
<pre><code>// if代码实例：
int a = 17;

if (a &gt; 16)
{
   Console.WriteLine(Hello World");         // 输出：“Hello World”
}
</code></pre>
<h2>If...else语句</h2>
<ol>
<li>一般来讲，当条件表达式不满足时，程序将不采取采取任何措施。</li>
<li>而else则用来处理当条件为假时的问题。<strong>也就是说当条件不满足时，执行else里的代码。</strong></li>
</ol>
<p><img src="https://s2.loli.net/2024/02/06/bje7XqUrnhfQxkd.png" alt="post_CSharp5_2.png" /></p>
<pre><code>if(conditional expression)
{
   /* 当条件为真时将执行的语句 */
}
else
{
   /* 当条件为假时将执行的语句 */
}
</code></pre>
<ol>
<li>看实例：</li>
<li>发现当条件不满足时，则输出了：”你好世界"</li>
</ol>
<pre><code>// if...else代码实例：
int a = 17;

if (a &gt; 16)
{
   Console.WriteLine(Hello World");         
}
else
{
    Console.WriteLine("你好世界");           // 输出：“你好世界”
}

</code></pre>
<h2>else-if语句</h2>
<ol>
<li>
<p>这个语句是用来处理当if不满足时，可以判断多个if分支的问题，<strong>相当于有多个if语句</strong>。</p>
</li>
<li>
<p>按照编程语言从上往下的执行方式，<strong>当if不满足，则执行else if，再不满足继续下一个else if……</strong>
<img src="https://s2.loli.net/2024/02/06/Cu8lzO3tQaS7xHr.png" alt="post_CSharp5_3.png" /></p>
</li>
<li>
<p>看演示：</p>
</li>
</ol>
<pre><code>// else-if代码实例：
            if (a &gt; 18){
                Console.WriteLine("Hello World");
            }
            else if (a &gt; 19){
                Console.WriteLine("Hello World -2");
            }
            else if (a &gt; 15)
            {
                Console.WriteLine("Hello World -3");        // 输出："Hello World -3"
            }
            else if (a &gt; 16)
            {
                Console.WriteLine("Hello World -4");
            }
</code></pre>
<ol>
<li>要注意的是：因为else if是包含在一个if语句中的，所以当其中一个else if条件满足时，执行完语句后，将跳出else if，结束整个if判断</li>
</ol>
<h2>if-嵌套</h2>
<ol>
<li>在if的执行语句中中我们是可以继续写if语句的，就跟套娃一样。</li>
<li>被嵌套与嵌套的关系我们称为父子级关系，当然也有孙级，爷级……</li>
<li>同理，可以按照这种逻辑往下继续写。</li>
</ol>
<pre><code>// if嵌套代码实例：
int a = 17;

if (a &gt; 15)
{
   Console.WriteLine("Hello World");         // 输出：“Hello World”

    if (a &gt; 16)
    {
       Console.WriteLine("Hello C#");        // 输出：“Hello C#”
    }
    else
    {
       Console.WriteLine("你好世界");
    }
}
</code></pre>
<h2>if-逻辑表达式</h2>
<ol>
<li>因为if语句是用来判断布尔值的，所以我们可以加入逻辑运算符，使得条件更严谨。</li>
<li>我们可以回到上一期参考一下<a href="https://tiamo17.gitee.io/2024/02/03/CSharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%90%E5%9B%9B%E3%80%91/">逻辑运算符</a></li>
<li>我们在条件表达式内设置个 &amp;&amp; :当两个表达式同时满足时则条件为真。看实例：</li>
</ol>
<pre><code>// if-逻辑表达式实例：
int a = 17;

 if (a &gt;= 17 &amp;&amp; a &gt; 16)
 {
       Console.WriteLine("Hello World");     // 输出：“Hello World”
 }
</code></pre>
<h2>结语：</h2>
<ol>
<li>这篇文章大部分时间都用在画图和检查代码上了，总之写完了学会了就是好的！</li>
<li>希望的努力不会白费。</li>
<li>下期见：Bye~~</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_运算符与布尔类型【四】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%9B%9B/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%9B%9B/</id>
    <published>2024-02-03T23:39:43.000Z</published>
    <updated>2024-02-03T23:39:43.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>算术运算符</h2>
<ol>
<li>所谓算术运算符：就是现实中的加减乘除之类的符号，但在编程语言中，它们又有不同于现实的语法。</li>
<li>下面就介绍一下算术运算符的各种符号包括计算案例。</li>
</ol>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例(设a为4；b为2)</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>把两个操作数相加</td>
<td>A + B 将得到 6</td>
</tr>
<tr>
<td>-</td>
<td>从第一个操作数中减去第二个操作数</td>
<td>A - B 将得到 2</td>
</tr>
<tr>
<td>*</td>
<td>把两个操作数相乘</td>
<td>A * B 将得到 8</td>
</tr>
<tr>
<td>/</td>
<td>分子除以分母</td>
<td>B / A 将得到 2</td>
</tr>
<tr>
<td>%</td>
<td>取模运算符，整除后的余数</td>
<td>B % A 将得到 0</td>
</tr>
<tr>
<td>++</td>
<td>自增运算符，整数值增加 1</td>
<td>A++ 将得到 5</td>
</tr>
<tr>
<td>--</td>
<td>自减运算符，整数值减少 1</td>
<td>A-- 将得到 3</td>
</tr>
</tbody>
</table>
<pre><code> //算术运算案例：
 int a = 10;
 int b = 2;

  Console.WriteLine(a + b);     // 输出为：12
  Console.WriteLine(a - b);     // 输出为：8
  Console.WriteLine(a * b);     // 输出为：20
  Console.WriteLine(a / b);     // 输出为：5
  Console.WriteLine(a % b);     // 输出为：0
  Console.WriteLine(++ a);      // 输出为：11
  Console.WriteLine(-- b);      // 输出为：1
</code></pre>
<ol>
<li>在赋值或输出值得注意的一件事（关于自加和自减它们得到的结果会不一样）：
<ul>
<li>a ++：计算过程是先执行a，后在增加1.</li>
<li>++ a：计算过程是先加上1，后再执行a.</li>
<li>a--和--a同理。</li>
</ul>
</li>
</ol>
<p>2、++a:计算过程是先加上1,之后再执行a.</p>
<h2>关系运算符</h2>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>检查两个操作数的值是否相等，如果相等则条件为真。</td>
<td>(A == B) 不为真。</td>
</tr>
<tr>
<td>!=</td>
<td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>
<td>(A != B) 为真。</td>
</tr>
<tr>
<td>&gt;</td>
<td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
<td>(A &gt; B) 不为真。</td>
</tr>
<tr>
<td>&lt;</td>
<td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td>(A &lt; B) 为真。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>
<td>(A &gt;= B) 不为真。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>
<td>(A &lt;= B) 为真。</td>
</tr>
</tbody>
</table>
<h3>布尔值</h3>
<ol>
<li>顺带提一下布尔类型。什么是布尔类型？</li>
</ol>
<blockquote>
<p>布尔值是“真” True 或“假” False 中的一个。动作脚本也会在适当时将值 True 和 False 转换为 1 和 0。布尔值经常与动作脚本语句中通过比较控制脚本流的逻辑运算符一起使用。</p>
</blockquote>
<ol>
<li>布尔值为：<strong>True</strong> 和 <strong>False</strong>或者 <strong>1</strong> 和 <strong>0</strong>。</li>
</ol>
<pre><code>// 关系运算符与布尔类型实例：
bool a = 5 == 3;
bool b = 6 &gt; 7;
bool c = 7 &lt; 8;
bool d = 8 != 8;
bool e = 9 &gt;= 8;
bool f = 10 &lt;= 9;

Console.WriteLine(a);     // 输出：False
Console.WriteLine(b);     // 输出：False
Console.WriteLine(c);     // 输出：True
Console.WriteLine(d);     // 输出：False
Console.WriteLine(e);     // 输出：True
Console.WriteLine(f);     // 输出：False
</code></pre>
<h2>赋值运算符</h2>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
<td>C = A + B 将把 A + B 的值赋给 C</td>
</tr>
<tr>
<td>+=</td>
<td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
<td>C += A 相当于 C = C + A</td>
</tr>
<tr>
<td>-=</td>
<td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
<td>C -= A 相当于 C = C - A</td>
</tr>
<tr>
<td>*=</td>
<td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
<td>C *= A 相当于 C = C * A</td>
</tr>
<tr>
<td>/=</td>
<td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
<td>C /= A 相当于 C = C / A</td>
</tr>
<tr>
<td>%=</td>
<td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
<td>C %= A 相当于 C = C % A</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>左移且赋值运算符</td>
<td>C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>右移且赋值运算符</td>
<td>C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td>
</tr>
<tr>
<td>&amp;=</td>
<td>按位与且赋值运算符</td>
<td>C &amp;= 2 等同于 C = C &amp; 2</td>
</tr>
<tr>
<td>^=</td>
<td>按位异或且赋值运算符</td>
<td>C ^= 2 等同于 C = C ^ 2</td>
</tr>
<tr>
<td>|=</td>
<td>按位或且赋值运算符</td>
<td>C |= 2 等同于 C = C | 2</td>
</tr>
</tbody>
</table>
<h2>逻辑运算符</h2>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>称为逻辑与运算符。如果两个操作数<em><strong>都为真</strong></em>，<em><strong>则条件为真</strong></em>。</td>
<td>(A &amp;&amp; B) 为假。</td>
</tr>
<tr>
<td>||</td>
<td>称为逻辑或运算符。如果两个操作数中<em><strong>有任意一个真</strong></em>，<em><strong>则条件为真</strong></em>。</td>
<td>(A || B) 为真。</td>
</tr>
<tr>
<td>!</td>
<td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假，<em><strong>（将结果进行反转）</strong></em>。</td>
<td>!(A &amp;&amp; B) 为真。</td>
</tr>
</tbody>
</table>
<pre><code>// 逻辑运算符实例：
bool a = (3 &gt; 2) &amp;&amp; (4 &gt; 3);
bool b = (5 &gt; 4) || (6 &lt; 1);
bool c = !(6 &gt; 7);
            
Console.WriteLine(a);        // 输出True
Console.WriteLine(b);        // 输出True
Console.WriteLine(c);        // 输出True
</code></pre>
<h2>结语</h2>
<ol>
<li>本期介绍了各种常用运算符及其实例。</li>
<li>这次干脆把会用到的运算符一下子学完掉，省的后面又要写笔记。</li>
<li>这期写的有点久，一直在刷视频打游戏，耽误了好久，也就两天吧？</li>
<li>还是那句话，下期见。Bye！</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_数据类型与变量赋值【三】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E4%B8%89/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E4%B8%89/</id>
    <published>2024-02-03T23:31:42.000Z</published>
    <updated>2024-02-03T23:31:42.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>前言</h2>
<ol>
<li>本期内容会介绍到C#的数据类型，变量和赋值基本操作。</li>
<li>当然了，我会简略的讲解常用的数据类型的应用及变量和赋值。</li>
</ol>
<h2>1.数据类型</h2>
<ol>
<li>C#中的数据类型与其他编程语言如出一辙，一下为数据类型参考表。</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>布尔值</td>
<td>True 或 False</td>
<td>FALSE</td>
</tr>
<tr>
<td>byte</td>
<td>8 位无符号整数</td>
<td>0 到 255</td>
<td>0</td>
</tr>
<tr>
<td>char</td>
<td>16 位 Unicode 字符</td>
<td>U +0000 到 U +ffff</td>
<td>'\0'</td>
</tr>
<tr>
<td>decimal</td>
<td>128 位精确的十进制值，28-29 有效位数</td>
<td>(-7.9 x 1028 到 7.9 x 1028) / 100 到 28</td>
<td>0.0M</td>
</tr>
<tr>
<td>double</td>
<td>64 位双精度浮点型</td>
<td>(+/-)5.0 x 10-324 到 (+/-)1.7 x 10308</td>
<td>0.0D</td>
</tr>
<tr>
<td>float</td>
<td>32 位单精度浮点型</td>
<td>-3.4 x 1038 到 + 3.4 x 1038</td>
<td>0.0F</td>
</tr>
<tr>
<td>int</td>
<td>32 位有符号整数类型</td>
<td>-2,147,483,648 到 2,147,483,647</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>64 位有符号整数类型</td>
<td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
<td>0L</td>
</tr>
<tr>
<td>sbyte</td>
<td>8 位有符号整数类型</td>
<td>-128 到 127</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>16 位有符号整数类型</td>
<td>-32,768 到 32,767</td>
<td>0</td>
</tr>
<tr>
<td>uint</td>
<td>32 位无符号整数类型</td>
<td>0 到 4,294,967,295</td>
<td>0</td>
</tr>
<tr>
<td>ulong</td>
<td>64 位无符号整数类型</td>
<td>0 到 18,446,744,073,709,551,615</td>
<td>0</td>
</tr>
</tbody>
</table>
<h2>2.声明变量</h2>
<p>1.定义一个字面量的过程就叫做声明变量，在一个变量名前面加个数据类型即完成声明。如以下代码：
3. 以下代码中的 <strong>a</strong> 和 <strong>b</strong> 被称为<strong>变量名</strong>
4. <strong>a</strong>  的数据类型为整数，<strong>b</strong> 的数据类型为字符</p>
<pre><code>//声明变量演示：
  int a;
  char b;
</code></pre>
<ol>
<li>对于变量名也有严格的命名规范：
<ul>
<li>不允许变量名重名。</li>
<li>不允许变量名开头为数字。</li>
<li>不允许有特殊符号，除下划线_外。</li>
</ul>
</li>
</ol>
<h2>3.赋值</h2>
<ol>
<li>将某一数值赋给某个变量的过程，称为赋值。如以下代码：</li>
</ol>
<pre><code>int a = 1;
char b = '帅';
string c = "我就是帅";
</code></pre>
<ol>
<li>但要注意的是：赋值需要严格遵循赋值规则。如一个为整数类型的字面量不能赋值一个小数；一个字符类型的字面量不能赋值一个字符串。以下为<em><strong>错误演示</strong></em>：、
<ul>
<li>还有一个要注意的是对于char和string类型，双引号""和单引号''是要严格区分的（char类型用单引号；string用双引号）</li>
</ul>
</li>
</ol>
<pre><code>int a = 1.2;          // 语法错误1
char b = '帅死了';    // 语法错误2
string c = 2;        // 语法错误3

char d = "你"         // 语法错误4
string e = '它的';     // 语法错误5
...
</code></pre>
<h2>4.正确案例</h2>
<pre><code>using System;

namespace DataType_Fuzhi {

    class First_2 {

        static void Main(string[] args){
            
                    int a = 1;
                    char b = '帅';
                    string c = "我就是帅";

                    Console.WriteLine(a + a);
                    Console.WriteLine(b);
                    Console.WriteLine(c);

        }
    }
}
</code></pre>
<h2>结语</h2>
<ol>
<li>在往后应用数据类型和赋值的时候多注意一下细节，细节往往决定成败。</li>
<li>这期也没啥好写的，主要就是注意细节，咱们还是下期见吧……（累死了，一天写了三篇文章）</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_程序的基本结构【二】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%BA%8C/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%BA%8C/</id>
    <published>2024-02-03T16:08:41.000Z</published>
    <updated>2024-02-03T16:08:41.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>前言：</h2>
<ol>
<li>对于一个初学者来说，理解程序的基本结构是非常有必要的，我们可以知道代码的用途，用法和编写准则。</li>
<li>学习任何一门编程语言第一步都是输出“Hello World”，但途中我们会用到一些代码，而这些就是程序运行的最基本的结构。</li>
<li>看下面代码。是不是除了个“Hello World”，其他啥都不知道？那么接下来就让我们一起了解一下C#的那些基本程序结构吧！（<strong>注意</strong>：以下解释都是本人观点，一部分会拿Python做对比，就是说：通俗易懂吧……）</li>
</ol>
<h2>语法须知：</h2>
<ul>
<li>C#的文件后缀为  <strong>.cs</strong>。</li>
<li>C#的语法和Java非常相似，对于大小写非常敏感，使用注意命名规则。</li>
<li>C#是以 <em><strong>花括号</strong></em>和 <em><strong>分号</strong></em> 来将代码分隔开来。</li>
</ul>
<pre><code>using System;  //引入System命名空间

namespace helloWorld
 {  
    class First_1
     {
        static void Main(string[] args) 
        {
             Console.WriteLine("Hello World");
        }
    }
}
</code></pre>
<h2>Using</h2>
<blockquote>
<p>using是C# 语言中定义一个范围，将在此范围之外释放一个或多个对象。</p>
</blockquote>
<ol>
<li>using（英文翻译：使用；利用），顾名思义就是<strong>引用</strong>的意思，和Python的import引用语句差不多</li>
<li>using是用来引入命名空间的语句，如代码：using System;，在输出“Hello World”时使用的Console方法就需要引入System，因为输出要用到控制台。</li>
<li>我们可以尝试引用外部或内部的命名空间试试（结果是没有报错的）。</li>
</ol>
<pre><code>using System;  //引入System命名空间
using HelloWorld;  //引用本程序内的命名空间
</code></pre>
<h2>NameSpace</h2>
<blockquote>
<p>namespace 关键字用于声明一组相关对象的大小。可以使用命名空间组织代码元素和创建全局唯一类型。</p>
</blockquote>
<ol>
<li>namespace（<strong>命名空间</strong>）类和函数的整体区块，通过命名空间我们可以获取到类和函数。</li>
<li>namespace 是唯一的，如果其他外部人员，如开发团队主要是通过using命名空间来调用命名空间内的代码。</li>
<li>程序的执行从 Main（函数）开始。</li>
<li>namespace的值一般与项目名同名（除非文件内有多个命名空间）</li>
</ol>
<pre><code>namespace HelloWorld {}
</code></pre>
<h2>Class</h2>
<blockquote>
<p>class关键字用来定义一个类，“Program”则是类的名为，类中通常用来存放程序中要使用的数据和函数（也叫方法）。</p>
</blockquote>
<ol>
<li>class（<strong>类</strong>）当需要引用代码时，我们需要先调用namespace再引用class</li>
<li>class命名法：开头字母必须大写；不允许将关键字作为名称；不允许特殊字符</li>
</ol>
<pre><code> class First_1 {}
</code></pre>
<h2>static void Main(string[] args)</h2>
<blockquote>
<p>在class中，该代码的Main 为定义的函数名称，Main 函数是整个 C# 程序的入口，其中包含了程序运行时需要执行的操作。static 和 void 都是用来修饰 Main 函数的关键字。</p>
</blockquote>
<ol>
<li>可以将 static void Main(string[] args) 理解为定义一个<strong>函数</strong>。
<ul>
<li>static：是将Main方法声明为静态， 是应用程序的入口。</li>
<li>void：说明main方法不会返回任何内容。</li>
<li>string[] args：这是用来接收命令行传入的参数。string[]是声明args的数据类型，可以存储字符串数组。</li>
</ul>
</li>
<li>函数名必须唯一</li>
<li>函数名首字母必须大写</li>
</ol>
<pre><code>static void Main(string[] args) {}
</code></pre>
<h2>Console.WriteLine();</h2>
<ol>
<li>程序的根代码，由方法和方法值组成，</li>
<li>分号严格区分。</li>
<li>方法来源于命名空间，比如"Console.WriteLine"就来源于System命名空间。</li>
</ol>
<h2>补充</h2>
<ol>
<li>C#不和Python一样创建一个文件就可以直接运行，在C#中，应该工程项目(又称：解决方案)才是一个文件的主体，应该工程项目不能有两个及更多.cs程序文件。</li>
<li>所以我们将一个文件夹(工程项目)作为一个文件来开发。</li>
</ol>
<h2>结语</h2>
<ol>
<li>当我们理解了C#程序的基本结构后，对于往后阅读代码和理解代码就会轻松很多。</li>
<li>本来是不打算写这篇文章的，但是谁叫我脑子笨。（学了Python再去学其他编程语言，这语法差别是真的大，无情……）</li>
<li>咱们下期见吧，Bye@_@……</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>C#(CSharp)学习笔记_前言及Visual Studio Code配置C#运行环境【一】</title>
    <link href="https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_visual-studio-code%E9%85%8D%E7%BD%AEcsharp%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%B8%80/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_visual-studio-code%E9%85%8D%E7%BD%AEcsharp%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%B8%80/</id>
    <published>2024-02-03T11:10:44.000Z</published>
    <updated>2024-02-03T11:10:44.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>前言</h2>
<blockquote>
<ol>
<li>这可以说是我第一次正式的踏入C#的学习道路，我真没想过我两年前是怎么跳过C#去学Unity3D游戏开发的（当然了，游戏开发肯定是没有成功的，都是照搬代码）。而现在，我真正地学习一下C#，就和去年学的Python那样。</li>
<li>C#对于我来说，可以做的和我想做的有很多，比如：桌面应用开发，移动应用开发，游戏开发，等等，不仅如此，学习C#对于我以后学习C/C++也是起到很大的帮助的。</li>
<li>虽然我对这门语言抱有很多看法，但是学总比不学好，谁叫我和它有如此缘遇。</li>
<li>希望我的路顺风顺水。</li>
</ol>
</blockquote>
<h2>1.什么是C#和.NET？</h2>
<h3>C# (C Sharp)</h3>
<blockquote>
<ol>
<li>
<p>C#是微软公司发布的一种由C和C++衍生出来的面向对象的编程语言、运行于.NET Framework和.NET Core(完全开源，跨平台)之上的高级程序设计语言。并定于在微软职业开发者论坛(PDC)上登台亮相。</p>
</li>
<li>
<p>C#是由C和C++衍生出来的一种安全的、稳定的、简单的、优雅的面向对象编程语言。它在继承C和C++强大功能的同时去掉了一些它们的复杂特性（例如没有宏以及不允许多重继承）。C#综合了VB简单的可视化操作和C++的高运行效率，以其强大的操作能力、优雅的语法风格、创新的语言特性和便捷的面向组件编程的支持成为.NET开发的首选语言</p>
</li>
<li>
<p>C#使得C++程序员可以高效的开发程序，且因可调用由 C/C++ 编写的本机原生函数，而绝不损失C/C++原有的强大的功能。因为这种继承关系，C#与C/C++具有极大的相似性，熟悉类似语言的开发者可以很快的转向C#.。</p>
</li>
</ol>
</blockquote>
<p><img src="https://s2.loli.net/2024/02/03/s6WVpHeEr1xIjD5.jpg" alt="post_CSharp1_1.jpg" /></p>
<h3>.NET</h3>
<blockquote>
<ol>
<li>
<p>.NET 是一个免费的跨平台开放源代码开发人员平台，用于生成多种类型的应用程序。 .NET 可以运行使用多种语言编写的程序，其中 C# 是最常用的语言。 .NET 依赖于许多大规模应用在生产中使用的高性能运行时。</p>
</li>
<li>
<p>.NET 平台专为实现高效工作、性能、安全性和可靠性而设计。 它通过垃圾回收器 (GC) 提供自动内存管理。 由于使用了 GC 和严格的语言编译器，.NET 的类型安全且内存安全。 它通过 async/await 和 Task 基元实现并发。 .NET
包含大量库，这些库具有广泛的功能，并针对多个操作系统和芯片体系结构的性能进行了优化。</p>
</li>
</ol>
</blockquote>
<p><img src="https://s2.loli.net/2024/02/03/rIDQ8mhuFWdxY7S.png" alt="post_CSharp1_2.png" /></p>
<h2>2.安装.NET</h2>
<blockquote>
<p>1 .NET是一种用于构建多种应用的免费开源开发平台，可以使用C#、F#或Visual Basic编写.NET应用。
2. 部署.NET平台用于运行C#程序</p>
</blockquote>
<ol>
<li>
<p>NET8是目前最新的.NET版本，它是世界领先的开发平台之一的最新 LTS 版本。.NET 8 提供了数以千计的性能、稳定性和安全性改进，以及平台和工具增强功能，有助于提高开发人员的工作效率和创新速度。</p>
</li>
<li>
<p>话不多说，直接前往Microsoft官网下载：<a href="https://dotnet.microsoft.com/zh-cn/download">https://dotnet.microsoft.com/zh-cn/download</a></p>
</li>
<li>
<p>点击中间的下载按钮即可。
<img src="https://s2.loli.net/2024/02/03/6qg8dbrSzMo4YHR.png" alt="post_CSharp1_3.png" /></p>
</li>
<li>
<p>下载完成后打开文件直接安装。等待安装完成即可……!
<img src="https://s2.loli.net/2024/02/03/hzoSx4nKUrHwYiG.png" alt="post_CSharp1_4.png" /></p>
</li>
<li>
<p>安装完成后，使用cmd命令验证一下是否成功。</p>
</li>
</ol>
<pre><code>dotnet --version
</code></pre>
<ol>
<li>当显示版本号后，则说明安装成功了。
<img src="https://s2.loli.net/2024/02/03/xYOTFi1RgQtKJsc.png" alt="post_CSharp1_5.png" /></li>
</ol>
<h2>3.VSCode配置环境</h2>
<ol>
<li>启动Visual Studio Code ,搜索“ C#” 扩展，并下载……
<img src="https://s2.loli.net/2024/02/03/LPZhnKABbewN13u.png" alt="post_CSharp1_6 .png" /></li>
<li>下载完成后重启软件。</li>
</ol>
<h2>4.执行"Hello World"代码</h2>
<ol>
<li>C#执行“Hello World”其实也挺简单的。</li>
<li>我们打开终端，确定好文件夹，输入一下命令创建一个工程项目</li>
</ol>
<pre><code>dotnet new console
</code></pre>
<p><img src="https://s2.loli.net/2024/02/03/xy8BEjuJgrWPvG4.png" alt="post_CSharp1_7.png" /></p>
<ol>
<li>选择一个.cs后缀的文件，编写好代码。</li>
<li>在控制台输入一下命令，可直接执行C#代码（当然了，对于初学者来说包括我，什么类，命名空间，是啥都不知道，但是以后我们会慢慢熟悉的）</li>
</ol>
<pre><code>dotnet run
</code></pre>
<p><img src="https://s2.loli.net/2024/02/03/MPkVFjJeQUnXT68.png" alt="post_CSharp1_8.png" />
5. 我们也可以使用快捷键 &lt;kbd&gt;Ctrl + F5&lt;/kbd&gt; 实现调试运行。</p>
<h2>5.Code Runner运行代码</h2>
<ol>
<li>使用cmd命令或者调试运行往往是不太灵活和快速的，为了更加方便，我们可以使用VScode的一个插件：<strong>Code Runner</strong>。</li>
<li>在扩展市场搜索 "<strong>Code Runner</strong>"  ，点击安装。
<img src="https://s2.loli.net/2024/02/03/wBS1gshVQEYxZcd.png" alt="post_CSharp1_10.png" /></li>
<li>安装好后进入该扩展的扩展设置，将 "<strong>Run In Terminal</strong>" 选项勾选上，这样代码就会在终端上执行。
<img src="https://s2.loli.net/2024/02/03/Kqeol73FWkfyb2u.png" alt="post_CSharp1_11.png" /></li>
<li>最后我们点击 "<strong>Executor Map</strong>"的编辑选项，我们找到"csharp"，将里面的参数改为 "<strong>dotnet run</strong>" 即可
<img src="https://s2.loli.net/2024/02/03/w3nrOxpFg2AYvcz.png" alt="post_CSharp1_12.png" /><img src="https://s2.loli.net/2024/02/03/5g9tWuGSaAMFUHd.png" alt="post_CSharp1_13.png" /></li>
<li>OK，完成后我们可以直接点击<strong>右上角的三角形按钮</strong>就可以直接运行C#程序了，十分的方便！</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/03/FTtl3A84CkKYEs9.png" alt="post_CSharp1_14.png" /></p>
<h2>结语</h2>
<ol>
<li>有关C#从认识到搭建运行环境到这里就结束了，如果有地方有问题还请大家指出</li>
<li>下期见 bye……</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Typora序列号破解【白嫖篇】</title>
    <link href="https://mizuki.mysqil.com/posts/typora%E5%BA%8F%E5%88%97%E5%8F%B7%E7%A0%B4%E8%A7%A3%E7%99%BD%E5%AB%96%E7%AF%87/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/typora%E5%BA%8F%E5%88%97%E5%8F%B7%E7%A0%B4%E8%A7%A3%E7%99%BD%E5%AB%96%E7%AF%87/</id>
    <published>2024-01-28T15:48:30.000Z</published>
    <updated>2024-01-28T15:48:30.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h1>Typora编辑器 - 序列号破解</h1>
<blockquote>
<p>Typora 是一款由 Abner Lee 开发的<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7/10002835?fromModule=lemma_inlink">轻量级</a> Markdown 编辑器，与其他 Markdown 编辑器不同的是，Typora 没有采用<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969?fromModule=lemma_inlink">源代码</a>和预览双栏显示的方式，而是采用所见即所得的编辑方式，实现了即时预览的功能，但也可切换至源代码编辑模式</p>
</blockquote>
<h2>前言</h2>
<ol>
<li>因为最近写博客文章的需求多了，所以对于需要一个好一点的面向Markdown的编辑工具，为什么选Markdown呢？这还是因为它本身就是一种独立的文本格式，又因为Markdown其强大的文本编辑功能所以就选择了Markdown。</li>
<li>而Typora是一款面向Md的专业，简洁，快速的Markdown编辑器，对于md博主来说是个很不错的选择。</li>
<li>Typora并不是免费的，所以……</li>
<li>破解就完了！！！</li>
</ol>
<h3>官网下载</h3>
<ul>
<li>
<p>官网：https://typora.io/</p>
</li>
<li>
<p>中文官网：https://typoraio.cn/（推荐）</p>
</li>
</ul>
<h3>安装（省略）</h3>
<h3>序列号破解</h3>
<h4>序列号破解程序下载链接：https://share.feijipan.com/s/MlB5EMCw?code=6666</h4>
<ol>
<li>将node_inject.exe和license-gen.exe文件移入到Typora的根目录中</li>
</ol>
<p><img src="https://s2.loli.net/2024/01/24/2l83DhW9eBvToUb.png" alt="tyopra_1.png" /></p>
<ol>
<li>
<p>按住&lt;kbd&gt;Shift&lt;/kbd&gt;鼠标右键Typora的目录，"以PowerShell的方式打开"。</p>
</li>
<li>
<p>先后直接将node_inject.exe和license-gen.exe鼠标拖入到Shell窗口中并运行。</p>
</li>
<li>
<p>运行后会得到一串序列号，将它复制并粘贴到Typora的序列号激活界面中激活即可。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/01/24/NsGWzryPdCg2Heo.png" alt="tyopra_2.png" /></p>
<ol>
<li>回到激活界面：“以序列号的方式激活“，输入邮箱再把生成的序列号输入进去，点击激活即可！！</li>
<li>这样我们就成功地永久激活了Typora。</li>
</ol>
<p><img src="https://s2.loli.net/2024/01/24/KTHhu8xUy5JO21X.png" alt="tyora_3.png" /></p>
<h2>结语</h2>
<p>祝您使用Typora创作愉快</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="白嫖"></category>
  </entry>
  <entry>
    <title>2023我的创作纪念日</title>
    <link href="https://mizuki.mysqil.com/posts/2023%E6%88%91%E7%9A%84%E5%88%9B%E4%BD%9C%E7%BA%AA%E5%BF%B5%E6%97%A5/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/2023%E6%88%91%E7%9A%84%E5%88%9B%E4%BD%9C%E7%BA%AA%E5%BF%B5%E6%97%A5/</id>
    <published>2024-01-24T23:26:26.000Z</published>
    <updated>2024-01-24T23:26:26.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/02/02/rRaBf7kX5psGCNt.png" alt="post_2023blog_6.png" /></p>
<h2>机缘</h2>
<ol>
<li>
<p>其实是为了记录学习笔记，但更多是为了和大家分享经验。</p>
</li>
<li>
<p>在创作的过程中激发我的开发热心，提高写作水平，</p>
</li>
<li>
<p>通过文章进行与其他博主或访客的技术交流我感到很快乐</p>
</li>
</ol>
<hr />
<h2>收获</h2>
<ol>
<li>
<p>起初我并不在意粉丝量和访问量的，但如果真和我想象中的那样，就说明我的文章质量不太好，所以后来我尽量避免文章水分，将文章写精细点，后来粉丝数和访问量就上来了。</p>
</li>
<li>
<p>我开始喜欢上CSDN平台上的勋章了，为了那几枚勋章，我创作了不少优质文章</p>
</li>
<li>
<p>因为新星计划，我永远不会忘记那个新星导师的名字，使我从Python基础入门到了网络爬虫，这是23年最值得提起的事情</p>
</li>
<li>
<p><img src="https://s2.loli.net/2024/02/02/5ouzAHXbly2k76F.png" alt="post_2023blog_1.png" /><img src="https://s2.loli.net/2024/02/02/9Imj7oEdhVrNbxn.png" alt="post_2023blog_2.png" /><img src="https://s2.loli.net/2024/02/02/Jbmt2fyAKxMiRUq.png" alt="post_2023blog_3.png" /><img src="https://s2.loli.net/2024/02/02/i7Gx1umTpDVgldA.png" alt="post_2023blog_4.png" /></p>
</li>
</ol>
<hr />
<h2>日常</h2>
<ol>
<li>现在处于高三阶段，创作的时间并不充裕，暑假一个月能写15篇文章，现在4个月都没有10篇了。</li>
<li>平时会看看极客资讯，看一下其他博主的写作风格。</li>
<li>每次做完一个项目的时候，我都会计划下一个任务。</li>
</ol>
<hr />
<h2>成就</h2>
<ol>
<li>我写的Python代码，连它的哲学理念：“优雅”都配不上了，用判断语句代替异常捕捉语句；从来不写类，继承和函数封装……</li>
<li>编程第一法则：“<strong>程序不论写的多么乱，能运行就对了</strong>”。这是我去年写的爬虫代码的一部分，全是if，但一个项目完成后，它是完全可以运行没有任何问题的。<img src="https://s2.loli.net/2024/02/02/yT8YmPMGFUjCfEO.png" alt="post_2023blog_10.png" /></li>
</ol>
<pre><code>if  lists!= CANCEL:    
        new_title = jsonpath.jsonpath(json_requests, '$..title')[int(lists) - 1]
        new_urls = jsonpath.jsonpath(json_requests, '$..url')[int(lists) - 1]
        new_author = jsonpath.jsonpath(json_requests, '$..author')[int(lists) - 1]

        new_titles = re.sub('[/;,/\']', '',new_title)
        local_name = f'{PATH_loacl}{new_titles}.mp3'
      
        download_return = requests.get(new_urls, stream=True)

        content_size = int(download_return.headers['Content-Length']) / 1024      # 获取文件的字节大小
        
        
        if os.path.exists(PATH_loacl) == False:
            print(os.path.exists)
            os.mkdir(PATH_loacl)

        files = open(local_name, 'wb')

        for j in tqdm(iterable = download_return.iter_content(1024),  # 分段下载
                      total = content_size,   # 总大小
                      unit = 'k',         # 单位为K
                      desc = '文件大小：'  # 注释下载标题
                      ):
            files.write(j)
</code></pre>
<ol>
<li>2023年做的最具有成就意义的三件事：
<ul>
<li><strong>使用Unity3D+C#开发出了我的第一款游戏：RezspairX</strong>
<img src="https://s2.loli.net/2024/02/02/TOqARJPuDUHhk61.png" alt="post_2023blog_8.png" /><img src="https://s2.loli.net/2024/02/02/voemblJSCjT2RX3.png" alt="post_2023blog_7.png" /></li>
<li><strong>使用Python开发出了爬虫小程序：MufreePro</strong><img src="https://s2.loli.net/2024/02/02/PDlKdOTue6jrzvw.png" alt="post_2023blog_5.png" /></li>
<li><strong>使用Hexo+Anzhiyu发布了我目前最好的个人博客</strong><img src="https://s2.loli.net/2024/02/02/Scn3NCRo9lxuki6.png" alt="post_2023blog_9.png" /></li>
</ul>
</li>
</ol>
<hr />
<h2>憧憬</h2>
<ol>
<li>希望高中毕业后，无论如何都要找个大学大专也好，攻读计算机。</li>
<li>此外，我还希望以后能开发一个项目，并开源。</li>
<li>前端工程师；数据分析师；软件开发或设计者；</li>
<li>未来愿如我所期……</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/02/rRBQMNaw7WvcJx5.jpg" alt="post_2023blog_11.jpg" /><img src="https://s2.loli.net/2024/02/02/C5NA1suTS8R3Ybt.jpg" alt="post_2023blog_12.jpg" /></p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习与成长"></category>
  </entry>
  <entry>
    <title>文章添加标签，封面，标题，日期（Hexo）</title>
    <link href="https://mizuki.mysqil.com/posts/%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE%E5%B0%81%E9%9D%A2%E6%A0%87%E9%A2%98%E6%97%A5%E6%9C%9Fhexo/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE%E5%B0%81%E9%9D%A2%E6%A0%87%E9%A2%98%E6%97%A5%E6%9C%9Fhexo/</id>
    <published>2024-01-24T15:48:30.000Z</published>
    <updated>2024-01-24T15:48:30.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>文章/导航页添加标签，封面，标题，日期（Hexo）</h2>
<h4>我们只需要在写好的Markdown文本中的顶部加入这些代码即可</h4>
<pre><code>`title: Python Socket TCP简单通信【二】 #  设置文章标题`

`date: 2017-05-27 13:47:33       # 设置发布时间（默认不设）`

`cover: img\post_ing\1.jpg       # 设置文章封面（包括标题封面）`

`categories:              # 添加分类`

`- Python`

`- 编程语言`

`- 网络编程`
</code></pre>
<h3>1. 文章添加分类</h3>
<pre><code>categories:                           # 添加分类
- Python
- 编程语言
</code></pre>
<h3>2. 文章添加标签</h3>
<pre><code>tags:                           # 添加标签
- Python
- 编程语言
</code></pre>
<h3>1. 导航页添加封面</h3>
<pre><code>---
title: about               
date: 2024-01-01 22:46:09       
top_img: img/links.jpg         # 顶部封面
comments: false                # 关闭 评论功能
--- 
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="Hexo"></category>
  </entry>
  <entry>
    <title>我的个人博客发布成功啦!!!</title>
    <link href="https://mizuki.mysqil.com/posts/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B8%83%E6%88%90%E5%8A%9F%E5%95%A6/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B8%83%E6%88%90%E5%8A%9F%E5%95%A6/</id>
    <published>2024-01-23T10:19:19.000Z</published>
    <updated>2024-01-23T10:19:19.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h1>我的个人博客发布成功啦！！！</h1>
<blockquote>
<ol>
<li>这大概是两年前的是吧？我曾一直希望自己能搭建并上传自己的个人博客，但是受服务器和虚拟机的影响（太贵了，时间久了，对于我们学生党来说，确实是不小的开支）</li>
<li>此外，还受到框架因素的影响，原本是采用原生的H5+CSS+JavaScript搭建博客的，后来有去WordPress，都不太行（这样的网站框架只能上传到虚拟机中）最后选择了Hexo框架：纯静态框架（因为GitHub和Gitee听说是可以免费托管静态网站的）</li>
<li>时长两年半，我最最终还是在Gitee中发布了。（真的花了我不少时间，尤其是在高三段）</li>
</ol>
</blockquote>
<ul>
<li>网站框架采用：<a href="https://hexo.io/zh-cn/">Hexo</a> （Static Frame）</li>
<li>框架主题源自：<a href="https://github.com/anzhiyu-c/anzhiyu-docs/">Hexo-Theme-Anzhiyu</a>（开源项目）</li>
<li>托管平台：<a href="https://gitee.com/">Gitee</a>（码云）</li>
</ul>
<h3>博客网站正处于持续更新阶段……</h3>
<ol>
<li>因为是基于Hexo-Theme-Butterfly主题，不管怎么样，我们都是要熟悉该主题项目的源码的，所以在魔改和更新的路上并不会很顺利，主要是耗时间……</li>
<li>Anzhiyu主题为我们提供了一本主题手册，这比原生的Butterfly好太多。</li>
</ol>
<h3>现在终于可以安心干其他事了</h3>
<ol>
<li>因为搭建博客原因，我很多事情都被耽误，如我Python网络编程，网络爬虫，C#，还有TypeScript。</li>
<li>个人博客不仅我提供了一个任意处置的个人空间，还能够记录学习笔记，相当于CSDN还好不少</li>
<li>咱就是说，学就完了……</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习与成长"></category>
  </entry>
  <entry>
    <title>FydeOS17国产操作系统全过程安装【保姆级教程】</title>
    <link href="https://mizuki.mysqil.com/posts/fydeos17%E5%9B%BD%E4%BA%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A8%E8%BF%87%E7%A8%8B%E5%AE%89%E8%A3%85/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/fydeos17%E5%9B%BD%E4%BA%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A8%E8%BF%87%E7%A8%8B%E5%AE%89%E8%A3%85/</id>
    <published>2024-01-23T10:15:06.000Z</published>
    <updated>2024-01-23T10:15:06.000Z</updated>
    <summary>基于Linux + Chromium Project国产操作系统开箱。</summary>
    <content type="html"><![CDATA[<p>@[toc]</p>
<h2>系统介绍</h2>
<p><strong>什么是FydeOS ?</strong></p>
<blockquote>
<p>FydeOS （原名 Flint OS）是由燧炻科技创新（北京）有限责任公司基于开源项目 Chromium Project 二次开发，适配
x86 与 ARM 硬件平台，定位于中国版的 Google Chrome OS。
FydeOS提供包括操作系统产品定制化的技术咨询、解决方案以及商业授权服务。
<img src="https://s2.loli.net/2024/02/02/IC489kAt3TnUZz5.png" alt="post_fydeos17_1.png" /></p>
</blockquote>
<blockquote>
<p>FydeOS 是一款基于Linux+Chromium Project开发的轻量级操作系统，它的和Google的Chrome OS极为相似，有着ChromeBook和MacOS类似的使用体验，能够在大部分主流硬件上平稳运行，并且兼容Android应用程序和Linux。
以浏览器平台为基础，加入更多符合国内用户习惯的本地化功能以提升用户体验。经过长期的技术积累，FydeOS 有能力运行在各种主流的硬件设备之中并提供围绕 FydeOS 展开的整体解决方案。</p>
</blockquote>
<blockquote>
<p>FydeOS适应了时代的发展，作为轻量级的操作系统，它能够轻松运行在老旧的计算机中，甚至是十几年前的电脑，从关机到桌面显示只需要几秒钟，正如它的价值观所说：“世间众生平等，硬件亦无高低贵贱之分。”</p>
</blockquote>
<h2>材料：</h2>
<ul>
<li>一个至少空闲16GB的U盘</li>
<li>电脑运行内存至少4GB以上</li>
<li>USB 启动盘的辅助工具</li>
</ul>
<h2>下载安装</h2>
<h3>FydeOS镜像下载</h3>
<ol>
<li>
<p>下载镜像首先登陆Fyde OS的官方网站 <a href="https://fydeos.com/download/">https://fydeos.com/download/</a></p>
</li>
<li>
<p>选择你所对应的设备。支持PC机，虚拟机，和定制系统，</p>
</li>
<li>
<p>我们选择 FydeOS For PC</p>
</li>
<li>
<p>FydeOS For PC有三个选项可选</p>
<p>1.还在使用三代或七代的英特尔(Intel)处理器并且是集成显卡的老电脑可以选择，一般十多年前的老电脑就可以选择。
2.八代到十二代的英特尔(Intel)处理器并且是集成显卡的新机可以选择。
3.搭载的是AMD Radeon系列的集成显卡及处理器的电脑可以选择。</p>
</li>
</ol>
<p>我们选择第一个选项。</p>
<p><img src="https://s2.loli.net/2024/02/02/tSVfuoR9BNEDm2I.png" alt="post_fydeos17_2.png" /></p>
<ol>
<li>我们选择推荐下载："通过OneDrive下载"。
<img src="https://s2.loli.net/2024/02/02/bszCM7hlGUtDaZo.png" alt="post_fydeos17_3.png" /></li>
<li>页面跳转后，直接点击下载。并等待下载完成。
<img src="https://s2.loli.net/2024/02/02/1D4mSjKNrMIy8Vn.png" alt="post_fydeos17_4.png" /></li>
</ol>
<h3>Rufus U盘启动工具下载</h3>
<blockquote>
<p>Rufus 是一个开源免费的快速制作 U 盘系统启动盘和格式化 USB 的实用小工具，它可以快速把 ISO
格式的系统镜像文件快速制作成可引导的 USB 启动安装盘，支持 Windows 或 Linux 启动。Rufus 小巧玲珑，软件体积仅 7
百多 KB，然而麻雀虽小，它却五脏俱全……</p>
</blockquote>
<ol>
<li>前往Rufus中文官网：<a href="https://rufus.ie/zh/">https://rufus.ie/zh/</a></li>
<li>下拉找到最新版本，并点击标准版下载。</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/02/EgBK3NJtnbvTSDO.png" alt="post_fydeos17_5.png" /></p>
<h3>制作U盘系统启动盘</h3>
<ol>
<li>FydeOS镜像和Rufus下载好后，会出现以下文件。
<img src="https://s2.loli.net/2024/02/02/IxKWqZbPXeOMR91.png" alt="post_fydeos17_6.png" /></li>
<li>我们双击打开rufus。</li>
<li>制作U盘系统启动工具我们需要进行一下操作：
<ol>
<li>选择可用的U盘设备（注意：如U盘内有重要文件，请及时备份！！！）</li>
<li>选择一下载好的FydeOS系统镜像文件</li>
<li>其他均默认</li>
<li>当状态显示准备就绪时，则开始制作</li>
</ol>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/02/N8xcMv4fABmgdoQ.png" alt="post_fydeos17_7.png" /></p>
<ol>
<li>再次确认U盘内的数据备份，确认完毕后点击确定。</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/02/QPgsoYKr3pNifXq.png" alt="post_fydeos17_8.png" /></p>
<ol>
<li>最后等待镜像数据写入……
<img src="https://s2.loli.net/2024/02/02/ixa64C3BImhg9EW.png" alt="post_fydeos17_9.png" /></li>
<li>写入完成后点击关闭。
<img src="https://s2.loli.net/2024/02/02/lEHBJSU8jYAi5P7.png" alt="post_fydeos17_10.png" /></li>
</ol>
<h2>安装FydeOS</h2>
<h3>设置U盘UEFI模式启动</h3>
<ol>
<li>我们将U盘插入到需要安装的电脑中，并点击开机</li>
<li>在进入到系统前，我们立即点击&lt;kbd&gt;ESC&lt;/kbd&gt; 或 &lt;kbd&gt;F8&lt;/kbd&gt;键进入到Bios面板。</li>
<li>选择到Boot界面，将Boot Option优先权设置为U盘启动，这样我们在启动时进入的就是U盘中的FydeOS系统。
<img src="https://s2.loli.net/2024/02/02/Bn8klCGKLufyp9c.png" alt="post_fydeos17_11.png" /></li>
<li>选择到Save&amp;Exit界面，选择 "Save Changes and Exit" 保存并退出<img src="https://s2.loli.net/2024/02/02/XejHZ1AmdhqCpTE.png" alt="post_fydeos17_12.png" /></li>
</ol>
<h3>FydeOS部署</h3>
<ol>
<li>
<p>重启后它会自动进入U盘中的FydeOS系统，并出现开机图标。
<img src="https://s2.loli.net/2024/02/02/uUETlxeiGSYFD6L.png" alt="post_fydeos17_13.png" /></p>
</li>
<li>
<p>显示欢迎界面后，选择好语言 [中文（简体）]
<img src="https://s2.loli.net/2024/02/02/HyXNxwR7nc18BrP.png" alt="post_fydeos17_14.png" /></p>
</li>
<li>
<p>直接下一步
<img src="https://s2.loli.net/2024/02/02/kfWJ15EOqt8cNFK.png" alt="post_fydeos17_15.png" /></p>
</li>
<li>
<p>选择 “安装FydeOS” （正式地在电脑中安装FydeOS），选择好后就点击 “下一步”</p>
</li>
<li>
<p>如果你不想保留分区只保留一个FydeOS系统的话，就选择 “全盘安装” ，并 “下一步”
<img src="https://s2.loli.net/2024/02/02/OV2IEvBNyxkYThW.png" alt="post_fydeos17_16.png" /></p>
</li>
<li>
<p>安装需要要在有网络的环境下进行，所以在此之前你需要先连接一下网络，否则会卡在安装界面。在右下角时间栏内可配置网络。</p>
</li>
<li>
<p>完事之后点击安装即可。（大约会花个7-10分钟)
<img src="https://s2.loli.net/2024/02/02/UaiNQmG6cEOwlZS.png" alt="post_fydeos17_17.png" />
<img src="https://s2.loli.net/2024/02/02/b3ySrwQKeB64X1u.png" alt="post_fydeos17_18.png" /></p>
</li>
<li>
<p>安装完成后，重启电脑。</p>
</li>
<li>
<p>重启后可能要重新配置语言，同意服务协议，配置网络信息，和注册本地账号。这里就不再赘述。</p>
</li>
</ol>
<h2>体验</h2>
<ol>
<li>配置完后即可进入桌面，如图：</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/02/X3AV2MYFPZQ7RnK.png" alt="post_fydeos17_19.png" />
2. 我们打开任务正中间的蓝色图标（Chromium浏览器）看看是否能正常浏览网页，我们再下载个壁纸装上试试。一切都很正常！！！
<img src="https://s2.loli.net/2024/02/02/Sre5zTPxmdVLaJv.png" alt="post_fydeos17_20.png" />
<img src="https://s2.loli.net/2024/02/02/uiCZWxI9BtnDXkh.png" alt="post_fydeos17_21.png" />
<img src="https://s2.loli.net/2024/02/02/iPuK2n8sGNwAhxe.png" alt="post_fydeos17_22.png" /></p>
<h3>结语</h3>
<ol>
<li>FydeOS给人第一感受就是非常非常的简约，轻便，和快速。十分适合用来创作，设计，和开发小项目。</li>
<li>我也是首次体验国产操作系统，它的使用效果还是令人出乎意料的，不过目前我对它的认知程度也只是像文章内容的那样。
如果后续有什么新的探索发现我们再分享。
小伙伴们赶紧去体验吧！！!</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="操作系统"></category>
  </entry>
  <entry>
    <title>Encrypted Post</title>
    <link href="https://mizuki.mysqil.com/posts/encrypted-post/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/encrypted-post/</id>
    <published>2024-01-15T00:00:00.000Z</published>
    <updated>2024-01-15T00:00:00.000Z</updated>
    <summary>This is an article for testing the page encryption feature</summary>
    <content type="html"><![CDATA[<p>This blog template is built with <a href="https://astro.build/">Astro</a>. For the things that are not mentioned in this guide, you may find the answers in the <a href="https://docs.astro.build/">Astro Docs</a>.</p>
<h2>Front-matter of Posts</h2>
<pre><code>---
title: My First Blog Post
published: 2023-09-09
description: This is the first post of my new Astro blog.
image: ./cover.jpg
tags: [Foo, Bar]
category: Front-end
draft: false
---
</code></pre>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>title</code></td>
<td>The title of the post.</td>
</tr>
<tr>
<td><code>published</code></td>
<td>The date the post was published.</td>
</tr>
<tr>
<td><code>pinned</code></td>
<td>Whether this post is pinned to the top of the post list.</td>
</tr>
<tr>
<td><code>description</code></td>
<td>A short description of the post. Displayed on index page.</td>
</tr>
<tr>
<td><code>image</code></td>
<td>The cover image path of the post.&lt;br/&gt;1. Start with <code>http://</code> or <code>https://</code>: Use web image&lt;br/&gt;2. Start with <code>/</code>: For image in <code>public</code> dir&lt;br/&gt;3. With none of the prefixes: Relative to the markdown file</td>
</tr>
<tr>
<td><code>tags</code></td>
<td>The tags of the post.</td>
</tr>
<tr>
<td><code>category</code></td>
<td>The category of the post.</td>
</tr>
<tr>
<td><code>licenseName</code></td>
<td>The license name for the post content.</td>
</tr>
<tr>
<td><code>author</code></td>
<td>The author of the post.</td>
</tr>
<tr>
<td><code>sourceLink</code></td>
<td>The source link or reference for the post content.</td>
</tr>
<tr>
<td><code>draft</code></td>
<td>If this post is still a draft, which won't be displayed.</td>
</tr>
</tbody>
</table>
<h2>Where to Place the Post Files</h2>
<p>Your post files should be placed in <code>src/content/posts/</code> directory. You can also create sub-directories to better organize your posts and assets.</p>
<pre><code>src/content/posts/
├── post-1.md
└── post-2/
    ├── cover.png
    └── index.md
</code></pre>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="Technology"></category>
  </entry>
  <entry>
    <title>HarmonyOS4.0应用开发【学习笔记3：安装DevEco Studio开发环境】</title>
    <link href="https://mizuki.mysqil.com/posts/harmonyos40%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E5%AE%89%E8%A3%85deveco-studio%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/harmonyos40%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E5%AE%89%E8%A3%85deveco-studio%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</id>
    <published>2024-01-14T22:47:33.000Z</published>
    <updated>2024-01-14T22:47:33.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>DevEco Studio</h2>
<blockquote>
<ol>
<li>HUAWEI DevEco Studio 是基于IntelliJ IDEA Community开源版本打造，为运行在HarmonyOS和OpenHarmony系统上的应用和服务（以下简称应用/服务）提供一站式的开发平台。</li>
<li>是面向全场景多设备，提供一站式的分布式应用开发平台，支持分布式多端开发、分布式多端调测、多端模拟仿真，全方位的质量与安全保障。</li>
</ol>
</blockquote>
<blockquote>
<h3>特点</h3>
<ul>
<li>高效智能代码编辑：支持ArkTS、JS、C/C++等语言的代码高亮、代码智能补齐、代码错误检查、代码自动跳转、代码格式化、代码查找等功能，提升代码编写效率。更多详细信息，请参考编辑器使用技巧。</li>
<li>低代码可视化开发：丰富的UI界面编辑能力，支持自由拖拽组件和可视化数据绑定，可快速预览效果，所见即所得；同时支持卡片的零代码开发，降低开发门槛和提升界面开发效率。更多详细信息，请参考使用低代码开发应用/服务。</li>
<li>多端双向实时预览：支持UI界面代码的双向预览、实时预览、动态预览、组件预览以及多端设备预览，便于快速查看代码运行效果。更多详细信息，请参考使用预览器预览应用/服务界面效果。</li>
<li>多端设备模拟仿真：提供HarmonyOS本地模拟器，支持手机等设备的模拟仿真，便捷获取调试环境。更多详细信息，请参考使用模拟器运行应用/服务。</li>
</ul>
</blockquote>
<h2>安装DevEco Studio</h2>
<ol>
<li>所谓工欲善其事，必先利其器。在学习开发HarmonyOS应用之前，我们需要安装套件之一DevEco Studio，前面我们也说了，我们可以把这个软件理解为一个总编辑器，相当于Unity引擎一样。</li>
<li>前往官网下载</li>
</ol>
<ul>
<li>HarmonyOS DevEco Studio官网下载：<a href="https://developer.harmonyos.com/cn/develop/deveco-studio/#download">https://developer.harmonyos.com/cn/develop/deveco-studio/#download</a></li>
</ul>
<ol>
<li>在下载安装之前 Windows和Mac操作系统分别需要需要符合以下条件（开发者慎重考虑）</li>
</ol>
<ul>
<li>操作系统：Windows 10/11 64 位  ||  macOS(X86) 10.15/11/12/13 macOS(ARM) 11/12/13</li>
<li>内存：8GB 及以上  ||  8GB 及以上</li>
<li>硬盘：100GB 及以上  || 100GB 及以上</li>
<li>分辨率：1280<em>800 像素及以上  ||  1280</em>800 像素及以上</li>
</ul>
<ol>
<li>选择好对应的系统版本</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/direct/c5e117588f0e43eab6144879290f4cf6.png" alt="在这里插入图片描述" />
5. 下载完成后将安装包解压出来
<img src="https://img-blog.csdnimg.cn/direct/675850efbb8b40718929a739097798da.png" alt="在这里插入图片描述" /></p>
<h2>安装DevEco Studio</h2>
<ol>
<li>选择好安装目录（需要3GB以上的空间)
<img src="https://img-blog.csdnimg.cn/direct/0670f882955a4921ae7abfe8eba38e45.png" alt="在这里插入图片描述" /></li>
<li>安装选项</li>
</ol>
<ul>
<li>勾选 "创建桌面快捷键" 选项（必选）</li>
<li>勾选 "添加环境变量" 选项（必选）</li>
<li>创建Vscode工程项目 可选可不选
<img src="https://img-blog.csdnimg.cn/direct/c600f8e545004570bcad2d1bb2aa1be9.png" alt="在这里插入图片描述" /></li>
</ul>
<ol>
<li>是否重启电脑，选择第二项，单击 "Finish" 完成安装
<img src="https://img-blog.csdnimg.cn/direct/c8a79876c30c40e7be24485a4873286a.png" alt="在这里插入图片描述" /></li>
</ol>
<h2>配置DevEco Studio</h2>
<ol>
<li>是否导入已下载好的开发者工具，不导入选择第二项 并OK<img src="https://img-blog.csdnimg.cn/direct/2b127f1f6ecd46ba88e8ca475564e788.png" alt="在这里插入图片描述" /></li>
<li>Basic Setup安装界面配置：</li>
</ol>
<ul>
<li>安装Node.JS（如果有则选择Local，没有则选择Install，并确定好选择好文件夹）</li>
<li>安装Ohpm环境 （一般都没有，所以选择Install选项，并确定好文件夹）</li>
</ul>
<p><strong>注意：如果你安装了Node.JS环境，一般版本不能大于或晚于所这支持的版本，如果显示了如图所示的提示，那么则说明你需要重新安装一个所需的版本</strong>
<img src="https://img-blog.csdnimg.cn/direct/6d1876a0d7634c93928cdc6b55cfb0ff.png" alt="在这里插入图片描述" /></p>
<ul>
<li>"Next</li>
<li><img src="https://img-blog.csdnimg.cn/direct/e6b1eac79a1740f8aaeb426ae2e27318.png" alt="在这里插入图片描述" /></li>
</ul>
<ol>
<li>
<p>SDK安装界面：选择好安装位置即可。<img src="https://img-blog.csdnimg.cn/direct/a22058f53a9d4bfcb14147dca59ce997.png" alt="在这里插入图片描述" /></p>
</li>
<li>
<p>Summry协议界面：选择Accept，直接一路点击Next即可</p>
</li>
<li>
<p>最后会开始安装所有开发环境（安装可能会花比较长的时间，耐心等待……）。<img src="https://img-blog.csdnimg.cn/direct/527d4425acff426eab57ef201cb85d1c.png" alt="在这里插入图片描述" /></p>
</li>
<li>
<p>出现这个界面，就说明安装完成了，你也可以在左下角的 "Help" &gt; "Diagnose Development Environment" 中检查环境是否完整，如果不完整可以在在里面补全。
<img src="https://img-blog.csdnimg.cn/direct/42e46d13fed0405ea1d8a50aaec71ffa.png" alt="在这里插入图片描述" /></p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/direct/5a72bd389f88443eb3b91be9b8ef2902.png" alt="在这里插入图片描述" /></p>
<ol>
<li>到这里，安装就完成了，总体来说还是比较简单的，唯独环境配置安装却是最有可能出错的，我们有可以通过HarmonyOS官方提供的文档指导安装：<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/deveco_overview-0000001053582387-V3?catalogVersion=V3">https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/deveco_overview-0000001053582387-V3?catalogVersion=V3</a></li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="操作系统"></category>
  </entry>
  <entry>
    <title>Markdown Mermaid</title>
    <link href="https://mizuki.mysqil.com/posts/markdown-mermaid/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/markdown-mermaid/</id>
    <published>2023-10-01T00:00:00.000Z</published>
    <updated>2023-10-01T00:00:00.000Z</updated>
    <summary>A simple example of a Markdown blog post with Mermaid.</summary>
    <content type="html"><![CDATA[<h1>Complete Guide to Markdown with Mermaid Diagrams</h1>
<p>This article demonstrates how to create various complex diagrams using Mermaid in Markdown documents, including flowcharts, sequence diagrams, Gantt charts, class diagrams, and state diagrams.</p>
<h2>Flowchart Example</h2>
<p>Flowcharts are excellent for representing processes or algorithm steps.</p>
<pre><code>graph TD
    A[Start] --&gt; B{Condition Check}
    B --&gt;|Yes| C[Process Step 1]
    B --&gt;|No| D[Process Step 2]
    C --&gt; E[Subprocess]
    D --&gt; E
    subgraph E [Subprocess Details]
        E1[Substep 1] --&gt; E2[Substep 2]
        E2 --&gt; E3[Substep 3]
    end
    E --&gt; F{Another Decision}
    F --&gt;|Option 1| G[Result 1]
    F --&gt;|Option 2| H[Result 2]
    F --&gt;|Option 3| I[Result 3]
    G --&gt; J[End]
    H --&gt; J
    I --&gt; J
</code></pre>
<h2>Sequence Diagram Example</h2>
<p>Sequence diagrams show interactions between objects over time.</p>
<pre><code>sequenceDiagram
    participant User
    participant WebApp
    participant Server
    participant Database

    User-&gt;&gt;WebApp: Submit Login Request
    WebApp-&gt;&gt;Server: Send Auth Request
    Server-&gt;&gt;Database: Query User Credentials
    Database--&gt;&gt;Server: Return User Data
    Server--&gt;&gt;WebApp: Return Auth Result
    
    alt Auth Successful
        WebApp-&gt;&gt;User: Show Welcome Page
        WebApp-&gt;&gt;Server: Request User Data
        Server-&gt;&gt;Database: Get User Preferences
        Database--&gt;&gt;Server: Return Preferences
        Server--&gt;&gt;WebApp: Return User Data
        WebApp-&gt;&gt;User: Load Personalized Interface
    else Auth Failed
        WebApp-&gt;&gt;User: Show Error Message
        WebApp-&gt;&gt;User: Prompt Re-entry
    end
</code></pre>
<h2>Gantt Chart Example</h2>
<p>Gantt charts are perfect for displaying project schedules and timelines.</p>
<pre><code>gantt
    title Website Development Project Timeline
    dateFormat  YYYY-MM-DD
    axisFormat  %m/%d
    
    section Design Phase
    Requirements Analysis      :a1, 2023-10-01, 7d
    UI Design                 :a2, after a1, 10d
    Prototype Creation        :a3, after a2, 5d
    
    section Development Phase
    Frontend Development      :b1, 2023-10-20, 15d
    Backend Development       :b2, after a2, 18d
    Database Design           :b3, after a1, 12d
    
    section Testing Phase
    Unit Testing              :c1, after b1, 8d
    Integration Testing       :c2, after b2, 10d
    User Acceptance Testing   :c3, after c2, 7d
    
    section Deployment
    Production Deployment     :d1, after c3, 3d
    Launch                    :milestone, after d1, 0d
</code></pre>
<h2>Class Diagram Example</h2>
<p>Class diagrams show the static structure of a system, including classes, attributes, methods, and their relationships.</p>
<pre><code>classDiagram
    class User {
        +String username
        +String password
        +String email
        +Boolean active
        +login()
        +logout()
        +updateProfile()
    }
    
    class Article {
        +String title
        +String content
        +Date publishDate
        +Boolean published
        +publish()
        +edit()
        +delete()
    }
    
    class Comment {
        +String content
        +Date commentDate
        +addComment()
        +deleteComment()
    }
    
    class Category {
        +String name
        +String description
        +addArticle()
        +removeArticle()
    }
    
    User "1" -- "*" Article : writes
    User "1" -- "*" Comment : posts
    Article "1" -- "*" Comment : has
    Article "1" -- "*" Category : belongs to
</code></pre>
<h2>State Diagram Example</h2>
<p>State diagrams show the sequence of states an object goes through during its life cycle.</p>
<pre><code>stateDiagram-v2
    [*] --&gt; Draft
    
    Draft --&gt; UnderReview : submit
    UnderReview --&gt; Draft : reject
    UnderReview --&gt; Approved : approve
    Approved --&gt; Published : publish
    Published --&gt; Archived : archive
    Published --&gt; Draft : retract
    
    state Published {
        [*] --&gt; Active
        Active --&gt; Hidden : temporarily hide
        Hidden --&gt; Active : restore
        Active --&gt; [*]
        Hidden --&gt; [*]
    }
    
    Archived --&gt; [*]
</code></pre>
<h2>Pie Chart Example</h2>
<p>Pie charts are ideal for displaying proportions and percentage data.</p>
<pre><code>pie title Website Traffic Sources Analysis
    "Search Engines" : 45.6
    "Direct Access" : 30.1
    "Social Media" : 15.3
    "Referral Links" : 6.4
    "Other Sources" : 2.6
</code></pre>
<h2>Conclusion</h2>
<p>Mermaid is a powerful tool for creating various types of diagrams in Markdown documents. This article demonstrated how to use flowcharts, sequence diagrams, Gantt charts, class diagrams, state diagrams, and pie charts. These diagrams can help you express complex concepts, processes, and data structures more clearly.</p>
<p>To use Mermaid, simply specify the mermaid language in a code block and describe the diagram using concise text syntax. Mermaid will automatically convert these descriptions into beautiful visual diagrams.</p>
<p>Try using Mermaid diagrams in your next technical blog post or project documentation - they will make your content more professional and easier to understand!</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="Examples"></category>
  </entry>
  <entry>
    <title>Python网络爬虫 _简易的翻译小程序【7】</title>
    <link href="https://mizuki.mysqil.com/posts/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-_%E7%AE%80%E6%98%93%E7%9A%84%E7%BF%BB%E8%AF%91%E5%B0%8F%E7%A8%8B%E5%BA%8F7/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-_%E7%AE%80%E6%98%93%E7%9A%84%E7%BF%BB%E8%AF%91%E5%B0%8F%E7%A8%8B%E5%BA%8F7/</id>
    <published>2023-07-26T11:03:11.000Z</published>
    <updated>2023-07-26T11:03:11.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p>1.了解了URL封装和XPath解析后，也掌握了许多爬虫知识，是时候做个实战演练了。
2.本期内容会讲到如何利用爬虫制作一个简易的翻译小程序。</p>
</blockquote>
<h2>制作翻译小程序</h2>
<h3>一. 实战对象</h3>
<ol>
<li><strong>先声明一下</strong>：<em><strong>本次实战案例是以学习为目的，不会有其他恶意行为，文章仅供参考</strong></em>。</li>
<li>这次是利用爬虫制作小程序，那当然离不开网站了，本次我们会以，金山词霸为实战素材。</li>
</ol>
<h3>二. 制作流程</h3>
<h4>1. 英文翻译</h4>
<ol>
<li>首先我们先打开<a href="https://www.iciba.com/">金山词霸</a>的官网页面。</li>
<li>我们直接翻译两个单词，注意一下URL地址的变化，可以发现，，w=后面的就是我们要翻译的中文，连续两次翻译都是只是改变了这一小部分，所以，我们就可以利用到这一发现。</li>
</ol>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider7_1.png" alt="" />
<img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider7_2.png" alt="" />
3. 我们打开编辑器，开始编写代码。</p>
<ol>
<li>我们新建一个Python文件，并导入必要的模块，requests和lxml。</li>
<li>定义一个请求对象，并将链接复制到get方法内。注意，因为我们要利用到URL中的w=,所以我们在这里面写个格式。为了能够得到服务器的响应，我们还需要写一个反爬虫，就是定义一下请求头的User-Agent，将参数传入到请求对象中。</li>
<li>定义一个input用于word接收要查的单词。</li>
<li>这样请求对象就定义好了。</li>
</ol>
<pre><code>import requests  
from lxml import etree

tou = {
"User-Agent": 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36'
   }   # 伪装成浏览器

word = input('请输入你想翻译的单词：')
respon = requests.get(f'https://www.iciba.com/word?w={word}', headers=tou)    # 定义一个请求对象
respon_text = respon.text   # 将请求到的源码储存到容器中
</code></pre>
<ol>
<li>随后我们定义一下XPath解析对象。
<ol>
<li>我们定义一个解析对象，因为是HTML源码，所以我们采用HTML()方法，对象就是respon_text，将它传入方法内。</li>
<li>接着我们回到页面，打开检查&lt;kbd&gt;F12&lt;/kbd&gt;分析一下。利用检查工具，我们可以发现，我们翻译出了两种形态的单词，而这就是我们想要的数据，要想将他提取出来，就需要看右边的源码标签，可以看到，他们虽然不在一个标签内，但是却同属一个属性，利用这一点，我们就可以利用XPath定位到。</li>
</ol>
</li>
</ol>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider7_3.png" alt="" />
5. 提取</p>
<pre><code>6. 分析完，我们就可以利于XPath进行精确提取了，最后将提取到的数据传入到一个容器中。
 7. 最后直接打印。
</code></pre>
<pre><code>analyze = etree.HTML(respon_text)  # 定义解析对象
analyze_xpath = analyze.xpath('ul[@class="Mean_part__UI9M6"]/span[@class="jsx-1012413381"]/text()')  # 提取数据
print(analyze_xpath) # 输出翻译后的单词
</code></pre>
<ol>
<li>我们运行一下，可以看到，效果还是蛮不错的</li>
</ol>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider7_4.png" alt="" /></p>
<h4>2. 中文翻译</h4>
<ol>
<li>我们目前只能中文翻译英文，要想英文翻译中文，还需要继续完善。</li>
<li>我们继续分析一下源码，先翻译一下中文，检查一下。</li>
</ol>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider7_5.png" alt="" />
3. 分析一下标签的层级结构，利用这种结构，我们可以精确的提取出里面的数据。再次写一个容器。由于储存翻译的中文</p>
<pre><code>analyze = etree.HTML(respon_text)  # 定义解析对象
analyze_xpath = analyze.xpath('//ul[@class="Mean_part__UI9M6"]/li/span[@class="jsx-1012413381"]/text()')  # 提取英文数据
analyze_xpath_cn = analyze.xpath('//ul[@class="Mean_part__UI9M6"]/li/div/span/text()')  # 提取中文数据
print(analyze_xpath) # 输出翻译后的英文单词
print(analyze_xpath_cn) # 输出翻译后的中文词语
</code></pre>
<ol>
<li>我们运行一下，可以看到，如果是中译英，它不仅会翻译英文，同时还加上了中文更多形式；而英译中它并不会翻译英文，只会翻译中文，这也正好符合需求。</li>
</ol>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider7_6.png" alt="" /></p>
<h3>美化界面</h3>
<ol>
<li>
<p>最后我们再做最后的处理，美化一下。</p>
</li>
<li>
<p>首先，这个程序只会执行一次，翻译完后，只能重新启动，所以我们可以加个循环，让它翻译完一次还可以继续翻译；不仅如此为了防止爬虫频繁爬取网页信息，我们还要加个结束功能停止访问。</p>
<ol>
<li>直接在input的上面加个无条件循环即可</li>
<li>最后在脚下加个if判断，如果输入了”-quit-“则停止执行。</li>
</ol>
</li>
<li>
<p>这是最终的执行效果，也是非常的Nice！</p>
</li>
</ol>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider7_7.png" alt="" /></p>
<h2>最终代码</h2>
<pre><code>import requests  
from lxml import etree

tou = {
"User-Agent": 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36'
   }   # 伪装成浏览器

while True:
    word = input('请输入你想翻译的单词：')
    respon = requests.get(f'https://www.iciba.com/word?w={word}', headers=tou)    # 定义一个请求对象
    respon_text = respon.text   # 将请求到的源码储存到容器中

    analyze = etree.HTML(respon_text)  # 定义解析对象
    analyze_xpath = analyze.xpath('//ul[@class="Mean_part__UI9M6"]/li/span[@class="jsx-1012413381"]/text()')  # 提取英文数据
    analyze_xpath_cn = analyze.xpath('//ul[@class="Mean_part__UI9M6"]/li/div/span/text()')  # 提取中文数据
    print(analyze_xpath) # 输出翻译后的英文单词
    print(analyze_xpath_cn) # 输出翻译后的中文词语
    if word == '-quit-':   # 判断是否关闭
        print('程序已关闭')
        respon.close()  # 关闭请求
        break   # 跳出循环
                     
</code></pre>
<h2>总结</h2>
<blockquote>
<ol>
<li><strong>最后再次声明一下</strong>：<em><strong>本次实战案例是以学习为目的，不会有其他恶意行为，文章仅供参考</strong></em></li>
<li>虽然我也觉得经常爬别人的网站是不对的，不过，我们也是抱着学习的态度去做，只要没有恶意，或者频繁使用爬虫，都是可以的。</li>
<li>本次制作的翻译小程序我们只是利用到了金山词霸内的信息，目前只能翻译单词或词语，无法翻译语句，若想实现这一功能，同样可以按照上面的方法，添加一些代码即可。</li>
<li>内容为本人学习笔记,难免有不足之处,恳请大家批评指正。</li>
</ol>
</blockquote>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Python网络爬虫 _XPath解析【6】</title>
    <link href="https://mizuki.mysqil.com/posts/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-_xpath%E8%A7%A3%E6%9E%906/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-_xpath%E8%A7%A3%E6%9E%906/</id>
    <published>2023-07-22T15:13:52.000Z</published>
    <updated>2023-07-22T15:13:52.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>问题引入：</h2>
<blockquote>
<p>前面我们可以通过HTTP Requests请求获取到网站的HTML源代码，但是仍没有得到我们想要的信息。 那怎么办呢，这时我们就需要通过代码解析，从复杂的源码中提取出我们想要的信息。</p>
</blockquote>
<h2>爬虫解析器</h2>
<ol>
<li>
<p>爬虫解析器<strong>用作于从复杂的网页代码中解析提取出我们想要的数据</strong>。如下图，通过解析我们可以从结构复杂的代码中提取出我们想要的。</p>
</li>
<li>
<p>爬虫解析器有三大类，分别是正则表达式解析器，Bs解析器和Lxml解析器。
其对于的解析方法如下：</p>
<ul>
<li><strong>正则表达式解析</strong>：正则表达式(Regular Expression) 简称 ‘Re’ 是一种特殊的字符串模式,利用这些元字符可以从结构复杂的文本中简化，提取出匹配的内容，是最传统的爬虫解析方式。</li>
<li><strong>BeautifulSoup解析</strong>：用于从HTML和XML文件中提取数据。它能够解析HTML文档,从中提取出标签、属性、文本等内容,方便我们进行二次开发和数据分析。</li>
<li><strong>XPath解析</strong>：当前最为流行的解析方式，通过标签定位解析提取出目标信息。</li>
</ul>
</li>
<li>
<p>由于XPath相对其他解析方法具有解析<strong>精度高，速度快，和操作灵活</strong>的特点，所以我们才用XPath作为我们解析器去提取数据。</p>
</li>
</ol>
<h2>什么是XPath?</h2>
<ol>
<li><strong>XPath</strong>：<strong>XML路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的语言</strong>。</li>
<li>XPath 的选择功能十分强大，它提供了非常简洁明了的路径选择表达式，另外它还提供了超过 100 个内建函数用于字符串、数值、时间的匹配以及节点、序列的处理等等，几乎所有我们想要定位的节点都可以用XPath来选择。</li>
</ol>
<h3>作用</h3>
<ol>
<li>XPath的最初作用是搜索Xml代码中的目标，但后来也可以用作于HTML的代码搜索，<strong>它可以在复杂的代码中筛选提取出目标代码，以至于现在被称为‘无能标记语’。</strong></li>
<li>在网络爬虫领域中，XPath扮演这重要的角色，爬虫在处理复杂的网页源码时，同样可以利用XPath来解析提取出你想要的数据。</li>
</ol>
<h2>XPath解析</h2>
<ol>
<li>前面说过，当我们拿到页面源码后，并不能直接得到我们想要的数据，这时我们则需要用到爬虫解析器XPath，任何使用呢？看操作：</li>
</ol>
<h3>1.安装Lxml库</h3>
<ol>
<li>
<p>XPath是第三方库，所以我们需要进行安装才可以使用。</p>
</li>
<li>
<p>安装只需要在终端输入一下命令即可：
如果安装失败，可以尝试切换安装源。</p>
<ol>
<li>默认安装</li>
</ol>
<blockquote>
<p>pip install lxml</p>
</blockquote>
<ol>
<li>清华大学镜像源（推荐）</li>
</ol>
<blockquote>
<p>pip install lxml -i https://pypi.tuna.tsinghua.edu.cn/simple</p>
</blockquote>
</li>
<li>
<p>若显示” Successfully installed lxml “则说明安装成功了。
!<img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider6_1.png" alt="" /></p>
</li>
<li>
<p>若显示” Requirement already satisfied “则说明已经安装过了，无需再安装。</p>
</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider6_2.png" alt="" />
3. 完事之后就可以正常使用XPath了。</p>
<h3>2.提取数据</h3>
<ol>
<li>我们先看一下百度的原页面，再看一下运行代码后的效果。可以看到代码杂乱无章，很难让人想到这两张图有任何关联，但其实页面显示的一切都被包含在HTML代码内。只是经过浏览器的渲染，才得到页面内的效果。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider6_3.png" alt="" /></p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider6_4.png" alt="" /></p>
<ol>
<li>现在我们开始真正的使用XPath解析来从代页面代码中提取出我们想要的内容。</li>
</ol>
<blockquote>
<p>假如我们只想要得到百度热搜内的数据，要怎么样提取呢？</p>
</blockquote>
<ol>
<li>首先新建一个Py文档，导入Requests库和安装好的lxml库。定义一个请求对象也就是百度，之后再定义一个请求头传给请求内的headers可选参数这是为了将程序伪装成浏览器，防止服务器拒绝接受请求，将请求到的页面代码储存到容器中，respones_text容器内的就是百度页面的HTML源代码了。</li>
</ol>
<pre><code>import requests  # 导入请求库
from lxml import etree  # 导入Xpath必要库

tou = {
    "User-Agent": 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36'
}   # 定义请求头

respones = requests.get('https://www.baidu.com/', headers=tou)  # 获取请求对象
respones_text = respones.text   #  获取的页面源码储存到容器中
</code></pre>
<ol>
<li>获取到源代码后，我们就可以定义一个要解析的对象了，引用的etree，因为我们解析的对象是HTML代码，使用用HTML()方法，括号参数是获取到的百度源码respones_text。</li>
</ol>
<pre><code>import requests  # 导入请求库
from lxml import etree  # 导入Xpath必要库

tou = {
    "User-Agent": 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36'
}   # 定义请求头

respones = requests.get('https://www.baidu.com/', headers=tou)  # 获取请求对象
respones_text = respones.text   #  获取的页面源码储存到容器中

objects = etree.HTML(respones_text)  # 定义一个解析的对象
</code></pre>
<ol>
<li>定义好解析对象后，就可以使用XPath更加精确的定位到我们想要的内容。在浏览器&lt;kbd&gt;F2&lt;/kbd&gt;打开检查功能，使用圆圈内的定位小箭头指向你想提取的内容，比如百度热搜的第一条内容，右侧就会显示该内容的HTML源码位置。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider6_5.png" alt="" /></p>
<ol>
<li>找到了源码位置后，我们就可以通过分析这串标签代码来完成提取。可以看到内容被包含在Span标签内，我们右键该标签Copy—&gt; Copy XPath复杂该标签的XPath层级位置。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider6_6.png" alt="" />
7. 定义一个容器对象，利用xpath()方法将复制下来的标签路径内的数据提取出来，并保存到容器内。xpath()内的参数就是复制下来的路径。</p>
<pre><code>import requests  # 导入请求库
from lxml import etree  # 导入Xpath必要库

tou = {
    "User-Agent": 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36'
}   # 定义请求头

respones = requests.get('https://www.baidu.com/', headers=tou)  # 获取请求对象
respones_text = respones.text   #  获取的页面源码储存到容器中

objects = etree.HTML(respones_text)  # 定义一个解析的对象
after = objects.xpath('//*[@id="hotsearch-content-wrapper"]/li[1]/a/span[2]') # 获取层级标签内的数据
print(after)
</code></pre>
<ol>
<li>我们运行这串代码，可以看到只是输出span元素的信息，仍没有我们需要的。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider6_7.png" alt="" />
::::: ：别急，我们只需要在路径后面加上个<code>/text()</code>即可</p>
<pre><code>after = objects.xpath('//*[@id="hotsearch-content-wrapper"]/li[1]/a/span[2]/text()') # 获取层级标签内的数据
</code></pre>
<p>运行一下，成功地将我们想要的内容解析提取了出来！！！</p>
<ol>
<li>那有人要问了，如果我想将热搜中所有的词条全搞出来，怎么弄呢？
很简单，通过分析源码我们可以发现，包含内容的span标签的都有一个共同的属性值：class=''title-content-title''，利用这一发现我们XPath快速定位。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider6_8.png" alt="" />
10. 我们可以利用XPath指定标签属性，以快速的定位到目标内容。
这样我们再次运行，就可以得到所有热搜词条了。</p>
<pre><code>after = objects.xpath('//span[@class="title-content-title"]/text()') # 获取层级标签内的数据
</code></pre>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider6_9.png" alt="" /></p>
<ol>
<li>因为XPath提取到到数据一般都是以列表的形式储存的，所以我们可以用循环语句将数据迭代给新的容器以达到自动换行美化数据的效果。</li>
</ol>
<pre><code>import requests  # 导入请求库
from lxml import etree  # 导入Xpath必要库

tou = {
    "User-Agent": 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36'
}   # 定义请求头

respones = requests.get('https://www.baidu.com/', headers=tou)  # 获取请求对象
respones_text = respones.text   #  获取的页面源码储存到容器中

objects = etree.HTML(respones_text)  # 定义一个解析的对象
after = objects.xpath('//span[@class="title-content-title"]/text()') # 获取层级标签内的数据

for x in after:  # 自动换行
    print(x)
</code></pre>
<ol>
<li><strong>怎么样？整个过程下来是不是简单又神奇，这也正是XPath功能强大的所在。</strong></li>
</ol>
<h2>总结</h2>
<blockquote>
<ol>
<li>本次简单地讲到了XPath用作于提取内容的过程。</li>
<li>作为当前最流行火爆的爬虫解析器，其根本因素它拥有强大的数据分析能力和多样的定位功能，让爬虫有了更多的选择。</li>
<li>以上只是XPath的简单操作，其精髓还需要更加深入的探索和学习。</li>
<li>内容为本人学习笔记,难免有不足之处,恳请大家批评指正。</li>
</ol>
</blockquote>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Python网络爬虫 _反爬虫【4】</title>
    <link href="https://mizuki.mysqil.com/posts/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-_%E5%8F%8D%E7%88%AC%E8%99%AB4/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-_%E5%8F%8D%E7%88%AC%E8%99%AB4/</id>
    <published>2023-07-16T11:56:54.000Z</published>
    <updated>2023-07-16T11:56:54.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p>1.由于网络爬虫具有一定的弊端，使用网络爬虫可以悄无声息的从互联网上获取很多资源，包括一些付费，原创和不公开的资源。所以很多大型网站都采取了反爬虫机制，来抵御爬虫的不正当行为。
2.本次介绍了<strong>什么是反网络爬虫？</strong>，<strong>简单的爬虫伪装操作？<strong>以及</strong>如何应对网络爬虫？</strong>。</p>
</blockquote>
<h2>什么是反网络爬虫？</h2>
<ol>
<li>反爬虫：**是指对扫描器中的网络爬虫环节进行反制，它会根据ip访问频率，浏览网页速度和User-Agent等参数来判断是否为网络爬虫，随后通过一些反网络爬虫机制来阻止或妨碍网络爬虫的正常爬取。**以此达到网络爬虫恶意获取网站资源的效果。</li>
</ol>
<h2>爬虫伪装</h2>
<h3>1. 什么是爬虫伪装？</h3>
<ol>
<li>爬虫伪装：<strong>指的是将爬虫伪装成其他工具，</strong></li>
<li>我们知道请求头中的User-Agent是用于告诉服务器请求是通过什么工具发出的（浏览器，程序，），以及工具对应的版本和类型是什么。</li>
<li>现在大多网站，都会根据User-Agent的参数来判断请求是否为网络爬虫发出的，服务器都希望访问网站的用户，是浏览器发出的请求，而不是爬虫程序。因为爬虫本身就是一种程序，所以就会被反爬虫机制给阻止。</li>
<li>我们只需要将User-Agent的参数更改一下即可。</li>
</ol>
<h4></h4>
<h4>2. 反爬实例：</h4>
<ol>
<li>豆瓣网带有反网络爬虫机制。</li>
<li>套用上期代码，当我们正常的去爬取豆瓣页面时，会出现如下错误。</li>
</ol>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider4_1.png" alt="" /></p>
<ol>
<li>什么意思呢？<strong>HTTP Error : 418的意思是服务器检测到是爬虫发来的请求而不是浏览器，所以果断拒绝了请求</strong>。这正是网站的反爬虫机制。</li>
<li>现在我们就可以更改一下User-Agent代码，将爬虫伪装成浏览器。</li>
<li>User-Agent被包含在请求头中，而<strong>请求头的类型是个字典</strong>。所以我们这样定义：</li>
</ol>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider4_2.png" alt="" /></p>
<ul>
<li>ReHeads为请求头的对象，它的类型是个字典</li>
<li>'User-Agent'的值为发送请求的工具及对于的类型和版本。我们需要将浏览器的版本类型等参数传入即可。</li>
</ul>
<ol>
<li>那么怎么查看浏览器的版本类型等参数呢？很简单，我们可以&lt;kbd&gt;F12&lt;/kbd&gt;打开调试，随便复制一份浏览器向其他服务器发送的请求，请求头内就包含了浏览器的相关信息。</li>
</ol>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider4_3.png" alt="" /></p>
<ol>
<li>将它复制下来，传给'User-Agent'，最后将ReHeads赋值给send内的可选参数headers。</li>
</ol>
<pre><code>import requests  # 导入模块


ReHeads = {
    'User-Agent': 'Mozilla/6.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36'
}
send = requests.get('https://www.douban.com/', headers=ReHeads)  # 获取服务器对象
if send.status_code == 200:
    print(f'请求的服务器成功...\n状态码：{send.status_code}')
    print(send.text)  # 获取页面源代码

else:
    print(f'服务器请求失败...\n状态码：{send.status_code}')
</code></pre>
<ol>
<li>运行代码，可以看到，服务接受了请求，并成功返回了源代码。这说明伪装很有效。</li>
</ol>
<p><img src="http://testingcf.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider4_4.png" alt="" /></p>
<h2>如何防范网络爬虫？</h2>
<ol>
<li>近几年，网络爬虫的肆虐，使得各大网络平台的数据防不胜防，保护数据，反对爬虫恶意行为势在必行。</li>
<li>了解了以上的网络爬虫伪装。也可以总结出一些防范方法了：</li>
</ol>
<blockquote>
<ul>
<li><strong>通过user-agent来控制访问</strong>：最经典的反爬虫方法，判断发送请求的对象，来达到反爬虫的目的。</li>
<li><strong>加密服务器内参数</strong>：将网站内的数据加密，返回时利用js代码进行拼接，达到爬虫抓取了而无法使用的效果。</li>
<li><strong>使用IP代理池来反反爬虫</strong>：根据对方IP的频繁访问服务器，可检测到对方对方是否为爬虫，并限制访问。</li>
</ul>
</blockquote>
<ol>
<li>以上是最常用的反爬虫方法。</li>
</ol>
<h2>总结</h2>
<ol>
<li>本期介绍了反爬虫的相关概念，并总结了一些反爬虫方法。</li>
<li>通过本期介绍，将会对爬虫有个更深入的认识。</li>
</ol>
<blockquote>
<p>内容为本人学习笔记,难免有不足之处,恳请大家批评指正。</p>
</blockquote>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Python网络爬虫_URL封装【5】</title>
    <link href="https://mizuki.mysqil.com/posts/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB_url%E5%B0%81%E8%A3%855/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB_url%E5%B0%81%E8%A3%855/</id>
    <published>2023-07-14T11:06:29.000Z</published>
    <updated>2023-07-14T11:06:29.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<p>为了达到便于管理的目的，大多网站会对网页的URL地址采取封装措施。</p>
<h2>URL封装</h2>
<ol>
<li>在我们访问网站时，通常会看到不一样的网址，就如豆瓣电影的动作片排行榜的网页路径一样。并不是一个很层级形式的路径。</li>
<li>这就是URL封装。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider5_1.png" alt="" />
3. 可以发现，URL路径中，从里面的问号开始往后就是封装的内容。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider5_2.png" alt="" />
4. 像URL路径这样的，一般以Json的形式存在于请求的Request Payload，内参数用于指定路径。准确来说应该是一种请求体。
5. 我们打开检查查看Payload
6. 可以发现，Payload参数完全对应着URL的后半部分。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider5_3.png" alt="" /></p>
<ol>
<li>如果我们把这个Payload放入代码中拼接起来会咋样呢
因为像这样的参数我们需要将它们写成字典再传入Params可选参数，即可。</li>
</ol>
<pre><code>import requests  # 导入请求库

tou = {    # 伪装浏览器
    "User-Agent": 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
    }
ts = {   # 组装封装参数
    "type_name" : "动作",
    "type" : "5",
    "interval_id" : "100:90",
    "action" : "",
    
}
resposn = requests.get('https://movie.douban.com/typerank/', headers=tou,  params=ts)

print(resposn.text)   # 输出
</code></pre>
<ol>
<li>可以看到运行后，就获取到了和页面一模一样的豆瓣动作片排行榜的源代码，
这就说明，Payload就是经过拆解后的URL。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider5_4.png" alt="" />
9. 按照这样的思路，我们可以利用封装后的URL举一反三。
比如我们将参数修改一下，将动作换成戏剧，运行后我们就可以拿到豆瓣喜剧片的排行榜源码了。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider5_5.png" alt="" /></p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider5_6.png" alt="" /></p>
<blockquote>
<p>1.内容为本人学习笔记,难免有不足之处,恳请大家批评指正。</p>
</blockquote>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Python网络爬虫_发送HTTP请求【3】</title>
    <link href="https://mizuki.mysqil.com/posts/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-_%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%823/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-_%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%823/</id>
    <published>2023-07-13T15:32:10.000Z</published>
    <updated>2023-07-13T15:32:10.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p>了解HTTP协议相关知识后，我们可以尝试利用Python发送一次HTTP请求。
Request是Python的第三方库，用于构建和发送HTTP请求。</p>
</blockquote>
<h2>安装Requests：</h2>
<ol>
<li>因为是第三方库，所以我们需要用到命令行终端的pip来进行安装。</li>
<li>打开终端，输入 <code>pip install requests</code> 再回车。</li>
<li>当显示如图所示，则表示安装成功了。</li>
</ol>
<p><strong>#安装成功：</strong></p>
<p>&lt;!-- #<img src="https://i-blog.csdnimg.cn/blog_migrate/b773aee387a2d59c3cd7af36a08bb310.png" alt="在这里插入图片描述" /> --&gt;</p>
<ol>
<li>但是如果显示如下，则表示你已经安装过了Requests，不需要再进行安装了。</li>
</ol>
<p><strong>#安装失败（重复）：</strong></p>
<p>&lt;!-- #<img src="https://i-blog.csdnimg.cn/blog_migrate/0d311fd49fef9797c09faf6b2246e715.png" alt="在这里插入图片描述" /> --&gt;
5. 打开该库后可以看到里面包含了很多方法模块，而我们待会就会用到里面的status_codes
&lt;!-- <img src="https://i-blog.csdnimg.cn/blog_migrate/1cbbce7da666de6dd8e049e1f5258d05.png" alt="在这里插入图片描述" /> --&gt;</p>
<h2>编写代码：</h2>
<h3>1. 发送HTTP请求</h3>
<ol>
<li>当Requests库安装好之后，就到了编写Python代码的环节了，新建一个py文本。</li>
<li>导入Requests模块。因为爬虫的主要行为是爬取内容，所以我用GET请求方法，获取一个服务器对象。我们拿百度为例。get内写的是要获取的完整的URL。 <strong>注意</strong>：URL要带上http协议，加密协议带https。</li>
</ol>
<pre><code>import requests  # 导入模块

send = requests.get('https://www.baidu.com/')  # 获取服务器对象
</code></pre>
<ol>
<li>当运行这串代码后，就相当于已经发送了HTTP请求了，而服务器响应的内容在send对象中。但是当我们打印对象内容时，会发现输出的是响应发出的状态码。状态码为200，则说明服务器接受了请求并得到响应。</li>
</ol>
<p>&lt;!-- <img src="https://i-blog.csdnimg.cn/blog_migrate/1b0b8cea35078fe2dddd278a673a71b7.png" alt="在这里插入图片描述" /> --&gt;
4. <strong>有的时候，当我们发送请求是，并不一直都是可以正常进行的。因为服务器的原因，也可能会出现其他状态</strong>。</p>
<p><strong>#常见的状态及状态码有如下：</strong></p>
<ul>
<li>200：服务器接受了请求，并响应页面。</li>
<li>201：服务器接受了请求，但尚未处理。</li>
<li>204：服务器接受了请求，但没有返回任何内容。</li>
<li>300：针对完成的请求,您需要进一步进行操作。</li>
<li>301：请求的URL网页已经移动到新的位置。</li>
<li>400：服务器不理解请求的语法。</li>
<li>403：服务器拒绝接受请求。</li>
<li>404：服务器找不到请求的页面，该页面不存在。</li>
<li>500：服务器发生错误，无法完成请求。</li>
<li>503：服务器目前无法使用，服务器正在维护或停机。</li>
</ul>
<ol>
<li>稍微将代码改动一下，如果请求成功则打印成功状态码，如果失败，则打印失败和状态码。</li>
</ol>
<pre><code>if send.status_code == 200:
    print(f'请求的服务器成功...\n状态码：{send.status_code}')
    print(send.text)  # 获取页面源代码

else:
    print(f'服务器请求失败...\n状态码：{send.status_code}')

</code></pre>
<h3>2. 获取页面内容</h3>
<ol>
<li>简单这么操作后，这也并不是我们想要的内容，我们要的是更多的信息，比如页面源代码。</li>
<li>这很简单，只需要加个方法</li>
</ol>
<pre><code>import requests  # 导入模块

send = requests.get('https://baidu.com/')  # 获取服务器对象
if send.status_code == 200:
    print(f'请求的服务器成功...\n状态码：{send.status_code}')
    print(send.text)  # 获取页面源代码

else:
    print(f'服务器请求失败...\n状态码：{send.status_code}')

</code></pre>
<ol>
<li>运行之后，以下得到的就是页面的HTML源代码。</li>
</ol>
<p>&lt;!-- <img src="https://i-blog.csdnimg.cn/blog_migrate/3c30de91ba43b93a82458cbbcefe37d3.png" alt="在这里插入图片描述" /> --&gt;</p>
<ol>
<li>关于什么是HTML，这个后期会进行讲解。</li>
</ol>
<h2>总结：</h2>
<ol>
<li>本次我们简单地介绍如何用Python Requests模块来发送HTTP请求并得到响应内容。</li>
<li>这下有人可能会说：就这？这不在浏览器就能搞的源码吗？但我想说的是：这只是爬虫的第一步，小试牛刀而言。</li>
<li>我也是学一步，写一步。我相信后面一定会更精彩。</li>
<li>后面讲解反爬虫机制。</li>
</ol>
<blockquote>
<p>内容为本人学习笔记,难免有不足之处,恳请大家批评指正。</p>
</blockquote>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Python网络爬虫_HTTP请求与响应【2】</title>
    <link href="https://mizuki.mysqil.com/posts/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB_http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%942/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB_http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%942/</id>
    <published>2023-07-11T20:02:53.000Z</published>
    <updated>2023-07-11T20:02:53.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>问题引入：</h2>
<blockquote>
<p>网络爬虫爬取的对象的是Web，我们将它称之为服务端，而爬虫就是本地的客户端。那么要怎样才能使客户端与服务端建立连接并爬取数据呢？这时就需要利用HTTP了</p>
</blockquote>
<h2>什么是HTTP?</h2>
<p>1.HTTP：超文本传输协议（Hypertext Transfer Protocol，简称：<a href="https://blog.csdn.net/weixin_51367845/article/details/123313047?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168913470416800227440124%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168913470416800227440124&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123313047-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=HTTP&amp;spm=1018.2226.3001.4187">HTTP</a>）它是一个简单的请求-响应协议，架构运行在TCP之上。这套协议定义了客户端可发送什么样的请求（Request）信号和服务器可返回什么样的响应（Response）。
它的作用是规定www服务器与浏览器之间信息传递规范，是二者共同遵守的协议。</p>
<p>2.<strong>当用户使用浏览器输入网址访问目标网站时，需要向网站服务器发送HTTP请求，通过发送请求即可从服务器获取页面内容的响应。但实际上服务器只会发送网页代码，我们所看到的页面效果是经过浏览器渲染而成的</strong>。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider2_1.jpg" alt="" /></p>
<h2>请求类型：</h2>
<p>1.HTTP请求类型有八种：（GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT）
2.但我们常用的只有两种**：GET**和POST。</p>
<ul>
<li>GET ： 用于获取数据，一般用于搜索排序和筛选之类的操作。</li>
<li>POST ：用于将数据发送给服务器，一般用于修改和写入数据，比如注册一个表单账号。</li>
</ul>
<p>3.因为网络爬虫是爬取数据，获取数据用到的是GET，所以POST很少被用于爬虫。</p>
<h2>HTTP请求的组成</h2>
<ol>
<li>HTTP请求由三部分组成：(<strong>请求行；请求头；请求体</strong>）</li>
</ol>
<blockquote>
<ul>
<li>请求行：请求方法、请求路径、HTTP协议及版本组成。</li>
<li>请求头：包含Host，User-Agent，Accept（用于告诉服务器一些相关的信息）</li>
<li>请求体：向服务器发送的附加信息</li>
</ul>
</blockquote>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider2_2.jpg" alt="" /></p>
<ul>
<li>
<p><em><strong>请求行</strong></em>：</p>
<ul>
<li>GET：请求类型，也可以为POST</li>
<li>User/info：需要访问的URL根路径（你需要访问的服务器资源根URL）</li>
<li>HTTP/1.1：HTTP传输协议及1.1版本</li>
</ul>
</li>
<li>
<p><em><strong>请求头</strong></em>：</p>
<ul>
<li>Host：主机域名，也就是网站域名，结合请求头的路径即可得到一个完整的路径</li>
<li>User-Agent：用于告诉服务器客户端相关的信息（如请求是通过什么工具发出的，工具类型和版本是什么）。</li>
<li>Accpet：用于告诉服务器客户端想要接收的资源类型</li>
</ul>
</li>
<li>
<p><em><strong>请求体</strong></em>：</p>
<ul>
<li>{...}：用于传给服务器任意数据（POST方法为空）</li>
</ul>
</li>
</ul>
<ol>
<li>我们也可以通过浏览器的调试功能来查看这些参数，以百度为例，向百度的服务器发送请求。快捷键&lt;kbd&gt;F12&lt;/kbd&gt;打开调试，刷新，打开NetWork，随便找个文件，即可看到请求数据，</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider2_3.png" alt="" /></p>
<h2>HTTP响应的组成：</h2>
<ol>
<li>当客户端浏览器发送以上请求后，服务器会根据请求内容响应给浏览器相关数据。</li>
<li>响应由三大部分组成：(<strong>状态行；请求头；请求体</strong>）</li>
</ol>
<blockquote>
<ul>
<li>状态行：包含了协议版本，状态码和状态信息</li>
<li>请求头：包含Host，User-Agent，Accept（用于告诉服务器一些相关的信息）</li>
<li>请求体：向服务器发送的附加信息</li>
</ul>
</blockquote>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider2_4.jpg" alt="" /></p>
<ul>
<li>
<p><em><strong>状态行</strong></em>：</p>
<ul>
<li>HTTP/1.1：HTTP传输协议及1.1版本</li>
<li>200：<a href="https://blog.csdn.net/qq_43418737/article/details/121851847?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168912807516800192298756%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=168912807516800192298756&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-121851847-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E7%8A%B6%E6%80%81%E7%A0%81&amp;spm=1018.2226.3001.4187">状态码</a>为200</li>
<li>OK：和状态码相对应，表示服务器请求成功</li>
</ul>
</li>
<li>
<p><em><strong>请求头</strong></em>：</p>
<ul>
<li>Date：表示的是服务器响应的时间</li>
<li>Content-Type：服务器所返回内容的类型及编码格式</li>
</ul>
</li>
<li>
<p><em><strong>请求体</strong></em>：</p>
<ul>
<li>为服务器要给客户端响应的内容。一般是HTML代码，即网页源码</li>
</ul>
</li>
</ul>
<ol>
<li>通过调试，我们同样可以查看服务器的响应</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider2_5.png" alt="" /></p>
<h2>总结</h2>
<blockquote>
<ol>
<li>了解HTTP请求和响应的原理后，将会对网络爬虫有了跟多的看法，对后期的学习也有很大的帮助。</li>
<li>下期将利用Python发送一个爬虫请求。</li>
</ol>
</blockquote>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Python网络爬虫_初识【1】</title>
    <link href="https://mizuki.mysqil.com/posts/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB_%E5%88%9D%E8%AF%861/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB_%E5%88%9D%E8%AF%861/</id>
    <published>2023-07-11T14:39:55.000Z</published>
    <updated>2023-07-11T14:39:55.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p>本次教程是依据个人学习心得与学习记录所做，见证的是我们的成长。</p>
</blockquote>
<h2>什么是网络爬虫?</h2>
<h3>定义：</h3>
<ol>
<li><strong>Web Crawler：网络爬虫</strong>。顾名思义，可以把网络理解成一张网，爬虫就是每天在网上爬来爬去的蜘蛛，因为我们所访问的网页都是互通的，通过跳转，可以访问其他的网络资源，这样，爬虫就可以在网络中爬取我们想要的资源。（所以网络爬虫又被称为<strong>网页蜘蛛，网络机器人，在某一社区中。被称为网页追逐者</strong>）它可以按照指定的规则即网络爬虫的算法自动地在互联网，网页中抓取网络的信息。</li>
</ol>
<h3>应用：</h3>
<ol>
<li>网络爬虫到处可见，例如浏览器的搜索引擎就附带着爬虫，依靠爬虫，可以快速的在庞大的互联网信息中获取指定的信息。算法对于网络爬虫来说十分重要，不同的算法，所爬取的信息的工作效率和结果也有所不同。</li>
<li>随着互联网的发展，到了信息量爆炸的时代，爬虫所扮演的角色愈加重要。为了提高爬行的工作效率，爬虫需要在单位时间内尽可能多的获取高质量页面，成为了它面临的难题之一。</li>
</ol>
<h3>原理：</h3>
<p>1.正如爬虫的名字那样，我们所访问的每个网站网页都属于一个节点，而这些节点都是相互联系的，爬虫便可以借助这种关系，从一个网页扩展到很多网页，以此从中抓取我们所需要的数据内容。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider1_1.jpg" alt="" /></p>
<p><strong>基本原理：</strong></p>
<blockquote>
<ul>
<li>指定初始的URL（该URL地址是我们需要爬取的初始URL网页地址）</li>
<li>爬取对应的初始URL时，从中获取新的URL地址</li>
<li>将新的URL地址列入URL列队中（URL管理器）</li>
<li>从URL列队中读取新的的URL，依据该URL爬取网页，提同时获取新的URL，并不断重复该过程</li>
<li>若在爬取前设置了条件，满足某特定条件即可停止爬取；若未设置条件，爬虫将一直干下去直到无法获取到新的URL地址。</li>
</ul>
</blockquote>
<ol>
<li>爬虫调度管理器会将抓取的数据通过下载器保存到数据存储器中。它将会以音频；文本；视频，图片等形式保持在本地。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Almango/Blog_imgbed@main/post/post_spider1_2.jpg" alt="" /></p>
<h3>利弊：</h3>
<p>1.网络爬虫是把双刃剑，在享受爬虫带来的数据便捷的同时还存在着严重的隐私问题。有人会故意利用爬虫来爬取他人的隐私信息。
2.使用网络爬虫就相当于使用浏览器，但它是个高频的程序，长期高频率的爬取一个网站，可能会导致服务器资源殆尽，给服务器带来很大的负担，严重影响性能，这就相当于一个DDoS攻击。</p>
<h3>首选语言</h3>
<p>1.Python是编写网络爬虫的首选语言，为什么呢？</p>
<ul>
<li>得益于Python的语法简明，通俗易懂，哪怕是零基础也能够快速上手，并且活。</li>
<li>Python内置了丰富的爬虫相关模块和第三方库及其框架，如Requests、mechanize，Beautiful Soup、Scrapy让网络爬虫有了更多的选择和方法。</li>
<li>Python支持多线程，开启多线程能够使得爬取更多的网页，工作效率大大提高，事半功倍。</li>
<li>Python有着强大的数据分析和处理能力，对于抓取数据更加智能与灵活。</li>
</ul>
<p>2.当然了，像Java，C/C++,PHP同样是可以编写爬虫的，就看你能不能接受了。</p>
<h3>总结：</h3>
<p>1.编写网络爬虫程序是一个长期的过程，往后的学习之路还很长。希望通过介绍，能对爬虫有个简单而深刻的认识。</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Python Socket TCP多线程通信【四】</title>
    <link href="https://mizuki.mysqil.com/posts/python-socket-tcp%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%9B%9B/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/python-socket-tcp%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%9B%9B/</id>
    <published>2023-06-22T17:44:10.000Z</published>
    <updated>2023-06-22T17:44:10.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h1>Python Socket TCP多线程通信</h1>
<h2>一.创建客户端连接</h2>
<h3>一.开启多线程通信</h3>
<ol>
<li>前面说到，因为单线程原因，客户端与服务器无法做到自由对话，则需要用到多线程来处理。我们现在的服务端和客户端最多也就是发送消息和接收消息两种行为，所以我们采用双线程。</li>
<li>或许我们可以新建一个Client.py的客户端和Server.py的服务端，代码照搬第一期的。</li>
<li>首先编写客户端代码。导入内置的线程模块，随后调用模块内置函数threading.Thread( )，因为有两个行为（发送消息和接收消息）所以需要定义并启动双线程。</li>
</ol>
<ul>
<li>target：与目标函数对接使得目标函数开启一个线程。</li>
<li>args：向目标函数传入一个参数。这里两个线程同时将socket传入，可以使得socket获得两个线程的处理。</li>
<li>.start：启动线程。</li>
</ul>
<pre><code>import threading  # 导入线程模块
</code></pre>
<pre><code># 启动多线程（多个线程共用一个Socket）
threading.Thread(target=send_msg, args=(Client,)).start()
threading.Thread(target=recv_msg, args=(Client,)).start()
</code></pre>
<h3>二.建立多线程任务</h3>
<ol>
<li>当多线程开启后，就可以写入发送消息和接收消息的行为了，我们称它为多线程要完成的任务，它会被写在自定义函数的循环语句内。</li>
<li>while循环的作用不必多说：无条件，保持持续的通信（当然后期可以添加条件以跳出循环）</li>
<li>要注意的是，<strong>这两个函数在线程启动后会被同时运行，也就是说，在任何时候，不管是对方有没有发送消息，我们都可以直接向对方发送消息或者说接收消息，这就完美的解决了像单线程一对一的受限通信。起到自由对话的效果。</strong></li>
</ol>
<pre><code># 多线程任务
def send_msg(Client):     # 发送消息（任务线程）
    while True:
        send = input('&gt;&gt;&gt;')
        Client.send(send.encode('utf-8'))


def recv_msg(Client):     # 接收消息（任务线程）
    while True:
        recvv = Client.recv(1024).decode('utf-8')
        print("服务器：" + f'{recvv}')
        
</code></pre>
<h2>二.建立服务器连接</h2>
<h3>一.开启多线程通信</h3>
<p>1.服务端也一样，直接套用第一期代码，重复和客户端一样的操作给它定义两个线程，但与前者不同的是，服务端的线程需要写在监听列队的内在循环语句内，这样每次有客户端连接服务器时，accept( )会创建一个新的socket并传给多线程任务。</p>
<pre><code># 循环接纳客户端
while True:
    socket, addr_info = Server.accept()  # 返回值传参赋值
    threading.Thread(target=send_msg, args=(socket,)).start()
    threading.Thread(target=recv_msg, args=(socket,)).start()
    print(f'{addr_info}' + "断开了与服务器的连接...")
</code></pre>
<h3>二.建立多线程任务</h3>
<ol>
<li>和客户端一样，任务写在定义的双线程之上。</li>
<li>if条件不写也没事。</li>
</ol>
<pre><code># 多线程任务
def send_msg(socket):          # 发送消息（任务线程）
    while True:
        msg = input("&gt;&gt;&gt;")
        socket.send(msg.encode('utf-8'))


def recv_msg(socket):          # 接收消息（任务线程）
    while True:
        remsg = socket.recv(1024).decode('utf-8')
        print("客户端：" + f'{remsg}')
        if len(remsg) == 0:
            break
            
</code></pre>
<h2>三. 通信测试</h2>
<h3>一.通信效果</h3>
<ol>
<li>效果还不错的，可以进行自由通信。
<img src="https://s2.loli.net/2024/02/02/sFcBoA7kbzmXTZD.png" alt="post_pysocket4_1.png" /></li>
</ol>
<h2>四. 整体代码与总结</h2>
<h3>一.整体代码</h3>
<ol>
<li>Client.py：</li>
</ol>
<pre><code># 这是客户端
import socket
import threading

# 创建Socket TCP对象
Client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 绑定目标服务器端地址
Client_address = (('127.0.0.1', 2023))  # IP地址为需要连接服务器的IP
# 连接目标服务器
Client.connect(Client_address)
print('---------------------------客户端--------------------------')


# 多线程任务
def send_msg(Client):     # 发送消息（任务线程）
    while True:
        send = input('&gt;&gt;&gt;')
        Client.send(send.encode('utf-8'))


def recv_msg(Client):     # 接收消息（任务线程）
    while True:
        recvv = Client.recv(1024).decode('utf-8')
        print("服务器：" + f'{recvv}')


# 启动多线程（多个线程共用一个Socket
threading.Thread(target=send_msg, args=(Client,)).start()
threading.Thread(target=recv_msg, args=(Client,)).start()
</code></pre>
<p>2.Server.py：</p>
<pre><code># 这是服务器端
import socket
import threading

# 创建Socket TCP对象
Server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
Server.bind(('', 2023))   # 绑定本地端口
print('---------------------------服务器端--------------------------')

# 启动监听列队
Server.listen(5)


# 多线程任务
def send_msg(socket):          # 发送消息（任务线程）
    while True:
        msg = input("&gt;&gt;&gt;")
        socket.send(msg.encode('utf-8'))


def recv_msg(socket):          # 接收消息（任务线程）
    while True:
        remsg = socket.recv(1024).decode('utf-8')
        print("客户端：" + f'{remsg}')
        if len(remsg) == 0:
            break


# 循环接纳客户端
while True:
    socket, addr_info = Server.accept()  # 返回值传参赋值
    threading.Thread(target=send_msg, args=(socket,)).start()
    threading.Thread(target=recv_msg, args=(socket,)).start()
    print(f'{addr_info}' + "客户端与与服务器连接成功...")
</code></pre>
<h3>二. 总结</h3>
<ol>
<li>本次应用到了Python的多线程模块，解决了Socket通信的局部问题。</li>
<li>本次的Python Socket TCP通信目前仅局限于局域网，还无法于外网进行通信，往后会进行补充。</li>
<li>说实话，我也才刚学到这里，真的是学一步做一个笔记，以免下次忘记。这个端午过的很充实呢！写了大半天的博客，让我深感体会到创作的不易，但收获却是满满当当的...</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Python Socket TCP单线程通信【三】</title>
    <link href="https://mizuki.mysqil.com/posts/python-socket-tcp%E5%8D%95%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%89/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/python-socket-tcp%E5%8D%95%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%89/</id>
    <published>2023-06-22T17:43:10.000Z</published>
    <updated>2023-06-22T17:43:10.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>一. 前言</h2>
<ol>
<li>前一期的简单通信只是草草的说到了它能够达到通信的效果，但它并不是很灵活，因为它没法自定义客户端要发送的内容，并且只能够发送一次消息至服务器。现在完善一下代码。</li>
</ol>
<h2>二.客户端持续发送与接收</h2>
<ol>
<li>我们在发送消息时，不可能是发送一次就完事了，那就相当于是邮箱，而如果要持续向服务器发送消息，我们就需要用到while循环，循环send( )函数，为了达到自定义编写消息内容，可以将input( )的内容赋值到send( )内。</li>
</ol>
<pre><code>while True:
    # 发送服务器消息
    Contest_server = input()
    Client.send(Contest_server.encode('utf-8'))
</code></pre>
<ol>
<li>当然了，因为是通信，也不可能是只有一方向另一方发送，应该是彼此之间通信，所以，客户端也可以用到recv( )函数用于接收服务器发送的消息。和上面一样，利用循环语句保持同步。</li>
</ol>
<pre><code>while True:
    # 发送服务器消息
    Contest_server = input()
    Client.send(Contest_server.encode('utf-8'))
    
    # 接收服务器消息
    Data_Server = Client.recv(1024).decode('utf-8')
    print('服务器发来消息&gt;&gt;&gt;' + Data_Server)
</code></pre>
<h2>三.服务器持续发送与接收</h2>
<ol>
<li>服务器和客户端一样，同样拥有发送的功能。这样，客户端和服务器彼此之间就能够进行自定义内容的通信。</li>
</ol>
<pre><code>while True:
    socket, addr_info = Server.accept()  # 返回值传参赋值
    # 循环接收与发送消息（保持在线）
    while True:
        # 接收客户端消息
        data_info = socket.recv(1024).decode('utf-8')         # 接收客户端消息
        print('客户端发来消息&gt;&gt;&gt;' + f'{data_info}')  # 输出该消息
        
         # 发送客户端消息
        data_client = input()
        socket.send(data_client.encode('utf-8'))
</code></pre>
<h2>四. 断开连接</h2>
<ol>
<li>由于两端的循环是无条件的，就会导致两端无法断开连接，这就需要给它添加一个条件，当任意一端发送了‘拜拜’的消息，则跳出循环，最后断开连接。（见整体代码）</li>
</ol>
<h2>五.整体代码与总结</h2>
<ol>
<li>Client.py：</li>
</ol>
<pre><code># 这是客户端
import socket

# 创建Socket TCP对象
Client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 绑定客户端地址
Client_address = (('192.168.0.193', 2023))
Client.connect(Client_address)
print('-----------------客户端----------------')

# 循环接收与发送消息（保持在线）
while True:
    # 发送服务器消息
    Contest_server = input()
    Client.send(Contest_server.encode('utf-8'))
    # 当客户端说拜拜，则断开连接
    if Contest_server == '拜拜':
        break

    # 接收服务器消息
    Data_Server = Client.recv(1024).decode('utf-8')
    print('服务器发来消息&gt;&gt;&gt;' + Data_Server)
    # 当服务器说拜拜，则断开连接
    if Data_Server == '拜拜':
        break


Client.close()  # 断开字节流

</code></pre>
<ol>
<li>Server.py：</li>
</ol>
<pre><code># 这是服务器端
import socket

# 创建Socket TCP对象
Server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
Server.bind(('', 2023))   # 绑定本地端口
print('-----------------服务器端----------------')

# 启动监听
Server.listen(5)

# 循环接纳客户端
while True:
    socket, addr_info = Server.accept()  # 返回值传参赋值
    # 循环接收与发送消息（保持在线）
    while True:
        # 接收客户端消息
        data_info = socket.recv(1024).decode('utf-8')                 # 接收客户端消息
        print('客户端发来消息&gt;&gt;&gt;' + f'{data_info}')  # 输出该消息
        if data_info == '拜拜':  # 当服务器说拜拜，则断开连接
            break

        # 发送客户端消息
        data_client = input()
        socket.send(data_client.encode('utf-8'))
        if data_client == '拜拜':  # 当客户端说拜拜，则断开连接
            break

    socket.close()  # 断开现有的连接...
    print(f'{addr_info}' + "断开了与服务器的连接...")

</code></pre>
<p>3.当我们运行客户端与服务器时，会发现，彼此是能够正常交流的，但是还存在有点问题：两者只能一对一的交流，也就是说，你说一句，我再说一句，不能一下说两句。
<img src="https://s2.loli.net/2024/02/02/J5snf6OrmcUCWH8.png" alt="post_pysocket3_1.png" /></p>
<ol>
<li>对于这种问题，直接原因发送和接收的代码是写在循环语句内的，当发送消息代码完成时，等待的是对方消息的接收，如果对方无作为，则无法执行下一步代码。根本原因还是因为线程。</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Python Socket TCP简单通信【二】</title>
    <link href="https://mizuki.mysqil.com/posts/python-socket-tcp%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1%E4%BA%8C/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/python-socket-tcp%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1%E4%BA%8C/</id>
    <published>2023-06-22T17:42:10.000Z</published>
    <updated>2023-06-22T17:42:10.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h2>一.前言</h2>
<ol>
<li>接着上期的介绍，现在我们开始利用现有的代码让客户端对服务器发出请求并完成简单的通信。</li>
</ol>
<h2>二.TCP协议通信流程</h2>
<ol>
<li>在开始这项工作之前，我们认识一下客户端向服务器发送请求并完成连接的一个Socket TCP通信执行流程。</li>
</ol>
<h3>1.‘三次握手’</h3>
<ol>
<li>当客户端向服务器发送连接请求时，两者之前会发送三次文段，也就是我们俗话说的“三次握手”。</li>
</ol>
<blockquote>
<ol>
<li>它的具体过程是：</li>
</ol>
<ul>
<li>
<ol>
<li>客户端主动向服务器发送连接请求（文段1）。</li>
</ol>
</li>
<li>
<ol>
<li>处于监听状态的服务器被动的接收了来自客户端的请求，并将确认的连接请求返回给客户端（文段2）。</li>
</ol>
</li>
<li>
<ol>
<li>最后客户端也将确认的连接请求返回给了服务器（文段3）   表示客户端完成了与服务器的连接。两端建立连接即可进行通信。</li>
</ol>
</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2024/02/02/WXOScyZkF9wQdpg.png" alt="post_pysocket2_1.png" /></p>
<blockquote></blockquote>
<h3>2. ‘四次挥手’</h3>
<ol>
<li>当想要断开服务器连接时，也是客户端主动地发出断连请求，两者之前会发送四次文段。这就是我们所说的“四次挥手”。具体过程：</li>
</ol>
<blockquote>
<ul>
<li>
<ol>
<li>客户端首先向服务器发送离线请求，客户端进入FIN_WAIT1状态（文段1）。</li>
</ol>
</li>
<li>
<ol>
<li>服务器接收到请求后并将确认返回给客户端，服务器进入CLOSE_WAIT状态。收到回应的客户端进入FIN_WAIT2状态，等待服务器的FIN。（文段2）。</li>
</ol>
</li>
<li>
<ol>
<li>接着服务器将FIN发送给客户端，并进入了LAST_ACK状态，等待客户端的确认。（文段3）</li>
</ol>
</li>
<li>
<ol>
<li>最后客户端将ACK发送给服务器并进入TIME_WAIT状态，服务器则做出回应CLOSE断开了与客户端的连接...（文段4）</li>
</ol>
</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2024/02/02/X4KjuCag5eQSBm6.jpg" alt="post_pysocket2_2.jpeg" /></p>
<blockquote></blockquote>
<blockquote>
<p>理解了Socket TCP通信协议的工作流程后，有利于轻易地掌握网络通信的关键。对往后的开发将也会变得更加灵活。</p>
</blockquote>
<h2>二.客户端发送信息</h2>
<ol>
<li>在客户端文件中调用Socket对象，并写入send( )函数，用于向服务器发送信息。</li>
</ol>
<ul>
<li>send( )内可直接输入需要发送的信息。 send( )内参数必须是bytes字节类型，也就是说，需要将内容转化为utf-8的编码格式，可以利用encode( )进行转化。</li>
</ul>
<ol>
<li>在发送完数据后需要将套接字close掉。</li>
</ol>
<pre><code># 发送文字信息
Client.send('你好，世界！！！'.encode('utf-8'))
# 断开字节流
Client.close()
</code></pre>
<h2>三. 服务器接收信息</h2>
<ol>
<li>客户端发送消息后，服务器就可以接收消息，需要用到内置函数recv( )来读取信息。</li>
</ol>
<ul>
<li>recv( )内参数为容器的大小，也就是可容纳多大的客户端发来的数据，同时也包含了数据。</li>
<li>​recv( )内容纳的数据需要再一次用到decode( )进行转化。</li>
</ul>
<pre><code> # 接收消息
 data_info = socket.recv(1024).decode('utf-8')

 # 输出该消息
 print(f'{addr_info[0]}' + '发来消息&gt;&gt;&gt;' + f'{data_info}')
</code></pre>
<ol>
<li>我们运行一下客户端和服务器，运行效果如下，服务器将会输出客户端发来的信息。</li>
</ol>
<p><img src="https://s2.loli.net/2024/02/02/bmBQNE1CaXL7oFd.png" alt="post_pysocket2_3.png" />
4. 代码解释：</p>
<blockquote>
<p>addr_info是个元组类型，里面包含了两个数据，一个是地址，一个是端口，所以我们可以直接用addr_info[0]来获取地址，而端口直接省略掉。</p>
</blockquote>
<h2>四.整体代码</h2>
<ol>
<li>Client.py：</li>
</ol>
<pre><code># 这是客户端
import socket

# 创建Socket TCP对象
Client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 绑定客户端地址
Client_address = (('192.168.0.193', 2023))
Client.connect(Client_address)

# 发送文字信息
Client.send('你好，世界！！！'.encode('utf-8'))
# 断开字节流
Client.close()
</code></pre>
<ol>
<li>Server.py：</li>
</ol>
<pre><code># 这是服务器端
import socket

# 创建Socket TCP对象
Server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
Server.bind(('', 2023))   # 绑定本地端口

# 启动监听
Server.listen(5)

# 循环接纳客户端
while True:
    socket, addr_info = Server.accept()  # 返回值传参赋值
    # 接收消息
    data_info = socket.recv(1024).decode('utf-8')
    # 输出该消息
    print(f'{addr_info[0]}' + '发来消息&gt;&gt;&gt;' + f'{data_info}')

    socket.close()  # 断开现有的连接...
    print(f'{addr_info}' + "断开了与服务器的连接...")
</code></pre>
<h2>五.总结</h2>
<ol>
<li>以上内容完成了客户端和服务器之间简单的Socket TCP通信。</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Python Socket TCP初始【一】</title>
    <link href="https://mizuki.mysqil.com/posts/python-socket-tcp%E5%88%9D%E8%AF%86%E4%B8%80/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/python-socket-tcp%E5%88%9D%E8%AF%86%E4%B8%80/</id>
    <published>2023-06-22T17:41:10.000Z</published>
    <updated>2023-06-22T17:41:10.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<h1>Python Socket TCP通信初识</h1>
<h2>一.什么是Socket ？</h2>
<ol>
<li>Socket（套接字）：一种独立于协议的网络编程接口，它就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议栈进行交互的接口。</li>
<li>我们使用的任何一个网络通信工具都是以Socket为底层编写出来的，如QQ，WeChat，Email，浏览器等。利用Socket我们可以完成很多与网络通信有关的操作。</li>
</ol>
<h2>二.Socket多人聊天</h2>
<ol>
<li>最近突发奇想，想学一下Python的Socket技术，设计一款属于自己的聊天工具。因为最近太闲了，Python的干货也看不下去了，基本上，那些语法基础，函数，类之类的都已经掌握了，现在先想来点新鲜的。
2.网上还是有很多关于Python Socket的教程的，我也总结一些，给大家和自己也写一份教程，加深记忆。</li>
</ol>
<h2>三. 利用Python 开发Socket多人聊天</h2>
<h3>1.Socket TCP协议开发</h3>
<ol>
<li>基本上TCP协议在Socket的类型上是用的最多的，UDP其实也还可以，但，我是蹭热度。</li>
<li>下面直接开始吧！！！</li>
</ol>
<h3>1.1创建客户端 Socket TCP对象</h3>
<ol>
<li>新建一个Client.py的文件，首先是创建TCP类型的Socket，创建TCP对象之前需要将Socket模块导入。</li>
<li>利用模块内置函数传参，以此定义好Socket对象的类型，这样我们就创建好了一个Socket TCP类型的对象。</li>
</ol>
<pre><code># 这是客户端
import socket # 导入模块
Client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 创建并定义Socket对象
</code></pre>
<p>Socket( )函数内有两个参数，</p>
<ul>
<li>AF_INET是一个地址系列,用于指定套接字可以与之通信的地址类型</li>
<li>SOCK_STREAM 用于定义套接字的通信传输类型，STREAM表示TCP协议，DGRAM表示UDP协议。</li>
</ul>
<h3>1.2.绑定服务器地址</h3>
<ol>
<li>对于通信来说，每个客户端都有唯一一个相当于的IP地址，端口也是唯一不能重复的，在访问服务器时它是代表外网客户端的标志，而绑定一个客户端地址也就相当于创建一个IP连接对象。</li>
<li>首先，写入需要连接的服务器地址和端口，因为在后期的服务器和客户端对接时可以使用tuple元组，str字符串，和byte字节类型的地址，所以我们在写入地址时使用字符串和字节类型。
注意：端口范围（1 - 65535）并且不能占用其他端口。</li>
</ol>
<pre><code>Client_address = ('127.0.0.1', 2023)
</code></pre>
<ol>
<li>服务器地址对象定义后，需要绑定到客户端，告诉它和指定对象连接。</li>
<li>调用Socket对象，并写入connect( ）函数，参数为地址，直接将服务器地址代入。这样就绑定好了服务器地址。</li>
</ol>
<pre><code>Client_address = ('127.0.0.1', 2023)
Client.connect(Client_address)
</code></pre>
<h3>2.1创建服务器Socket TCP对象</h3>
<ol>
<li>有了客户端，当然还得有服务器，这样两者之间才有通信的对象。</li>
<li>创建服务器对象其实和创建客户端对象一样，只是说后面的行为不一样。
创建一个新的文件名为Server.py，直接照搬上面的内容。</li>
</ol>
<pre><code># 这是服务器端
import socket # 导入模块

# 创建Socket TCP对象
Client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  创建并定义Socket对象
</code></pre>
<h3>2.2绑定服务器端口</h3>
<p>1.前面说了，客户端已经绑定了服务器的地址和端口，而服务器也同样要绑定端口，这样的话客户端才可以和服务器端口相对应并完成连接。
2.调用Socket对象并写入bind( )函数，参数为本地地址和端口，同样可以用元组类型的。
注意：地址可以使用空字符串，这代表是服务器的默认地址，端口自定义，但客户端端口一定要追随服务器。</p>
<pre><code>Server.bind(('', 2023)) #绑定服务器端口
</code></pre>
<h3>2.3服务器监听访客</h3>
<ol>
<li>当服务器启动后，要开始监听外网访问，使用listen( )函数</li>
</ol>
<pre><code>Server.listen(10) # 启动监听
</code></pre>
<h3>2.4循环接纳客户端</h3>
<ol>
<li>当客户端访问服务器时，服务器接纳，并做出相应的操作，随后断开连接，并再次接纳下一个客户端，循环操作，这就完成了服务器与客户端的通信。</li>
<li>完成这种操作首先需要写入循环语句，然后调用服务器的Socket对象并写入accept( )函数，当客户端服务器服务器时，该函数会接纳监听列队中的客户端的连接，并创建一个新的Socket以接收客户端发送的数据以及向客户端发送回应信息，最后返回文件描述符。</li>
</ol>
<pre><code># 循环接纳客户端
while True:
    socket, addr_info = Server.accept()  # 返回值传参赋值
    print(socket, addr_info)  # 打印返回值
    socket.close()  # 断开现有的连接...
</code></pre>
<ol>
<li>上述代码，当客户端发送连接服务器后，若没有对服务器发出请求则会立即断开现有的连接 并完成一个对监听列队中客户端的连接。</li>
</ol>
<ul>
<li>socket 为accept函数返回时新建立的Socket的连接。</li>
<li>addr_info 为accept函数返回的为这个新socket的文件描述符。</li>
</ul>
<h3>3.整体代码</h3>
<ol>
<li>客户端Client.py：</li>
</ol>
<pre><code># 这是客户端
import socket

# 创建Socket TCP对象
Client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 绑定目标服务器端地址
Client_address = (('127.0.0.1', 2023)) #IP地址为需要连接服务器的IP
# 连接目标服务器
Client.connect(Client_address)
</code></pre>
<ol>
<li>服务器端Server.py：</li>
</ol>
<pre><code># 这是服务器端
import socket

# 创建Socket TCP对象
Server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
Server.bind(('', 2023))   # 绑定本地端口

# 启动监听列队
Server.listen(5)

# 循环接纳客户端
while True:
    socket, addr_info = Server.accept()  # 返回值传参赋值
    print(socket, addr_info)  # 打印返回值
    socket.close()  # 断开现有的连接...
    print(f'{addr_info}' + "断开了与服务器的连接...")
</code></pre>
<h2>四.总结</h2>
<ol>
<li>以上介绍的是在本地局域网内搭建的Sockect客户端与服务器之间的对接，后期会介绍更多关于Socket相关的通信操作。</li>
</ol>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="学习笔记"></category>
  </entry>
  <entry>
    <title>Include Video in the Posts</title>
    <link href="https://mizuki.mysqil.com/posts/video/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/video/</id>
    <published>2022-08-01T00:00:00.000Z</published>
    <updated>2022-08-01T00:00:00.000Z</updated>
    <summary>This post demonstrates how to include embedded video in a blog post.</summary>
    <content type="html"><![CDATA[<p>Just copy the embed code from YouTube or other platforms, and paste it in the markdown file.</p>
<pre><code>---
title: Include Video in the Post
published: 2023-10-19
// ...
---

&lt;iframe width="100%" height="468" src="https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_" title="YouTube video player" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
</code></pre>
<h2>YouTube</h2>
<p>&lt;iframe width="100%" height="468" src="https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen&gt;&lt;/iframe&gt;</p>
<h2>Bilibili</h2>
<p>&lt;iframe width="100%" height="468" src="//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;p=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" &amp;autoplay=0&gt; &lt;/iframe&gt;</p>
]]></content>
    <author>
      <name>Almango</name>
    </author>
    <category term="Examples"></category>
  </entry>
</feed>